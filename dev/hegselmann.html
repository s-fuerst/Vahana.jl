<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Opinion Model · Vahana Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Vahana Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorial1.html">Tutorial</a></li><li class="is-active"><a class="tocitem" href="hegselmann.html">Opinion Model</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Add-the-graph"><span>Add the graph</span></a></li><li><a class="tocitem" href="#SimpleGraphs"><span>SimpleGraphs</span></a></li><li><a class="tocitem" href="#SNAPDataset.jl"><span>SNAPDataset.jl</span></a></li><li><a class="tocitem" href="#Transition-Function"><span>Transition Function</span></a></li><li class="toplevel"><a class="tocitem" href="#Create-plots"><span>Create plots</span></a></li></ul></li><li><a class="tocitem" href="predator.html">Predator / Prey</a></li></ul></li><li><a class="tocitem" href="performance.html">Performance Tuning</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="definition.html">Model Definition</a></li><li><a class="tocitem" href="initialization.html">Initialization</a></li><li><a class="tocitem" href="transition.html">Transition Function</a></li><li><a class="tocitem" href="global.html">Global Layer</a></li><li><a class="tocitem" href="plots.html">Plots</a></li><li><a class="tocitem" href="hdf5.html">HDF5</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="config.html">Configuration</a></li><li><a class="tocitem" href="misc.html">Misc</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="hegselmann.html">Opinion Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hegselmann.html">Opinion Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-fuerst/Vahana.jl/blob/main/docs/examples/hegselmann.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Opinion-Model"><a class="docs-heading-anchor" href="#Opinion-Model">Opinion Model</a><a id="Opinion-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Opinion-Model" title="Permalink"></a></h1><p>In this example we demonstrate how we can use the Graphs.jl package to add graphs from other sources (or created by the Graphs.jl package itself) to a Vahana simulation.</p><p>For this, we implement a simple version of the <a href="http://jasss.soc.surrey.ac.uk/5/3/2.html">Hegselmann and Krause (2002)</a> opinion dynamics model. An alternative implementation of the same model using the Agents.jl package can be found <a href="https://juliadynamics.github.io/Agents.jl/v4.0/examples/hk/">here</a>.</p><pre><code class="language-julia hljs">using Vahana, Statistics</code></pre><p>We have a finite number <span>$n$</span> of agents, where the state of the agents are a real number <span>$x_i(t)$</span> in the [0,1] interval which represents the opinion of that agent.</p><pre><code class="language-julia hljs">struct HKAgent
    opinion::Float64
end</code></pre><p>This time we also have only one network that determine the agents that will be considered when an agent updates its opinion.</p><pre><code class="language-julia hljs">struct Knows end</code></pre><p>There is a <em>confidence bound</em> <span>$\epsilon &gt; 0$</span>, opinions with a difference greater then <span>$\epsilon$</span> are ignored by the agents in the transition function. All agents have the same confidence bound, so we introduce this bound as a parameter.</p><pre><code class="language-julia hljs">struct HKParams
    ε::Float64
end</code></pre><p>We have now all elements to create an uninitialized simulation.</p><pre><code class="language-julia hljs">const hkmodel = ModelTypes() |&gt;
    register_agenttype!(HKAgent) |&gt;
    register_edgetype!(Knows) |&gt;
    create_model(&quot;Hegselmann-Krause&quot;);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Edgetype Knows is a struct without any field, so you can increase the
performance by setting the :Stateless hint. You can also
calling detect_stateless() before calling register_edgetype!,
then the :Stateless hint will be set automatically for structs without
a field.</code></pre><h1 id="Add-the-graph"><a class="docs-heading-anchor" href="#Add-the-graph">Add the graph</a><a id="Add-the-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Add-the-graph" title="Permalink"></a></h1><p>Vahana allows to add <code>SimpleGraphs</code> and <code>SimpleDiGraphs</code> from the <a href="https://juliagraphs.org/Graphs.jl/dev/">Graphs.jl</a> package via the <a href="initialization.html#Vahana.add_graph!"><code>add_graph!</code></a> function. So it&#39;s possible to use e.g. <a href="https://github.com/JuliaGraphs/SNAPDatasets.jl">SNAPDatasets</a> to run the opinion model on real datasets. Or the SimpleGraphs module from Graphs.jl to create synthetic graphs.</p><p>We show here for both use cases one example and are creating for each one an own simulation</p><pre><code class="language-julia hljs">const cgsim = create_simulation(hkmodel, HKParams(0.2), nothing);
const snapsim = create_simulation(hkmodel, HKParams(0.2), nothing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Simulation Name: Hegselmann-Krause
Parameter(s):
	 :ε : 0.2
Agent(s):
	 Type HKAgent with 0 agent(s)
Edge(s):
	 Type Knows with 0 edge(s) for 0 agent(s)
Still in initialization process!.</code></pre><h2 id="SimpleGraphs"><a class="docs-heading-anchor" href="#SimpleGraphs">SimpleGraphs</a><a id="SimpleGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleGraphs" title="Permalink"></a></h2><p>First we will show how we can add a synthetic graph. For this we need to import the SimpleGraphs module. Since there are many functions in the Graphs.jl package with the same name as in Vahana (e.g. add_edge!) it is advisable to import only the needed parts of Graphs.jl instead of loading the whole package via <code>using Graphs</code>.</p><pre><code class="language-julia hljs">import Graphs.SimpleGraphs</code></pre><p>We want to add a complete graph, where each agent is connected with all the other agents, like in the Agents.jl implementation. We can create such a graph via <code>SimpleGraphs.complete_graph</code>.</p><pre><code class="language-julia hljs">g = SimpleGraphs.complete_graph(50)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{50, 1225} undirected simple Int64 graph</code></pre><p>Vahana needs the information how to convert the nodes and edges of the SimpleGraphs object to the Vahana structure, this is done by the constructor functions in the third and forth arguments of <a href="initialization.html#Vahana.add_graph!"><code>add_graph!</code></a>. We do not need the Graph.vertex and Graph.edge arguments of this constructor functions, but for other use cases e.g. for bipartite graphs, it would be possible to create agents of different types depending on this information.</p><pre><code class="language-julia hljs">const agentids = add_graph!(cgsim,
                            g,
                            _ -&gt; HKAgent(rand()),
                            _ -&gt; Knows());</code></pre><p>Each agent also adds its own opinion to the calculation. We can use the ids returned by the <a href="initialization.html#Vahana.add_graph!"><code>add_graph!</code></a> functions for this.</p><pre><code class="language-julia hljs">foreach(id -&gt; add_edge!(cgsim, id, id, Knows()), agentids)

finish_init!(cgsim)</code></pre><h2 id="SNAPDataset.jl"><a class="docs-heading-anchor" href="#SNAPDataset.jl">SNAPDataset.jl</a><a id="SNAPDataset.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SNAPDataset.jl" title="Permalink"></a></h2><p>The SNAPDataset.jl package deliver Graphs.jl formatted datasets from the <a href="https://snap.stanford.edu/data/index.html">Stanford Large Network Dataset Collection</a>.</p><pre><code class="language-julia hljs">using SNAPDatasets</code></pre><p>With this package we can use the <code>loadsnap</code> function to create the graph that is then added to the Vahana graph, e.g. in our example the facebook dataset.</p><pre><code class="language-julia hljs">const snapids = add_graph!(snapsim,
                           loadsnap(:facebook_combined),
                           _ -&gt; HKAgent(rand()),
                           _ -&gt; Knows());</code></pre><p>Again each agent also adds its own opinion to the calculation.</p><pre><code class="language-julia hljs">foreach(id -&gt; add_edge!(snapsim, id, id, Knows()), snapids)

finish_init!(snapsim)</code></pre><h2 id="Transition-Function"><a class="docs-heading-anchor" href="#Transition-Function">Transition Function</a><a id="Transition-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Transition-Function" title="Permalink"></a></h2><p>Opinions are updated synchronously according to</p><p class="math-container">\[\begin{aligned}
x_i(t+1) &amp;= \frac{1}{| \mathcal{N}_i(t) |} \sum_{j \in \mathcal{N}_i(t)} x_j(t)\\
\textrm{where } \quad \mathcal{N}_i(t) &amp;= \{ j : \| x_j(t) - x_i(t) \| \leq \epsilon \}
\end{aligned}\]</p><p>So we first filter all agents from the neighbors with an opinion outside of the confidence bound, and then calculate the mean of the opinions of the remaining agents. As we have</p><pre><code class="language-julia hljs">function step(agent, id, sim)
    ε = param(sim, :ε)

    opinions = map(a -&gt; a.opinion, neighborstates(sim, id, Knows, HKAgent))

    accepted = filter(opinions) do opinion
        abs(opinion - agent.opinion) &lt; ε
    end

    HKAgent(mean(accepted))
end;</code></pre><p>We can now apply the transition function to the complete graph simulation</p><pre><code class="language-julia hljs">apply!(cgsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Simulation Name: Hegselmann-Krause
Parameter(s):
	 :ε : 0.2
Agent(s):
	 Type HKAgent with 50 agent(s)
Edge(s):
	 Type Knows with 2500 edge(s) for 50 agent(s)</code></pre><p>Or to our facebook dataset</p><pre><code class="language-julia hljs">apply!(snapsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Simulation Name: Hegselmann-Krause
Parameter(s):
	 :ε : 0.2
Agent(s):
	 Type HKAgent with 4039 agent(s)
Edge(s):
	 Type Knows with 180507 edge(s) for 4039 agent(s)</code></pre><h1 id="Create-plots"><a class="docs-heading-anchor" href="#Create-plots">Create plots</a><a id="Create-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Create-plots" title="Permalink"></a></h1><p>Finally, we show the visualization possibilities for graphs, and import the necessary packages for this and create a colormap for the nodes.</p><pre><code class="language-julia hljs">import CairoMakie, GraphMakie, NetworkLayout, Colors, Graphs, Makie</code></pre><p>Since the full graph is very cluttered and the Facebook dataset is too large, we construct a Clique graph using Graphs.jl.</p><pre><code class="language-julia hljs">const cysim = create_simulation(hkmodel, HKParams(0.25), nothing);
const cyids = add_graph!(cysim,
                         SimpleGraphs.clique_graph(7, 8),
                         _ -&gt; HKAgent(rand()),
                         _ -&gt; Knows());


foreach(id -&gt; add_edge!(cysim, id, id, Knows()), cyids)

finish_init!(cysim);</code></pre><p>Vahana implements an interactive plot function based on GraphMakie, where agents and edges are given different colors per type by default, and the state of each agent/edge is displayed via mouse hover actions.</p><pre><code class="language- hljs">vp = create_graphplot(cysim)

figure(vp)</code></pre><p>To modify the created plot, the Makie figure, axis and plot, can be accessed via the methods <code>figure</code>, <code>axis</code> and <code>plot</code>. This allows us to modify the graph layout and to remove the decorations.</p><pre><code class="language- hljs">Vahana.plot(vp).layout = NetworkLayout.Stress()

Makie.hidedecorations!(axis(vp))

figure(vp)</code></pre><p>We want that nodes to show the agent&#39;s opinion. Instead of modifing the Makie plot <code>node_color</code> property directly, it&#39;s also possible to define a helper functions with methods for the different agent and edge types, that are called by <code>create_graphplot</code> to determine properties of the nodes and edges of the plot and also supports interactive plot in the case that GLMakie is used as Makie backend. For details please check <a href="@ref"><code>create_graphplot</code></a>.</p><p>We define such a function and are calling it modify<em>vis, and will set the `update</em>fn<code>keyword of</code>create_graphplot` to this function.</p><pre><code class="language-julia hljs">colors = Colors.range(Colors.colorant&quot;red&quot;, stop=Colors.colorant&quot;green&quot;, length=100)


modify_vis(state::HKAgent, _ ,_) = Dict(:node_color =&gt; colors[state.opinion * 100 |&gt; ceil |&gt; Int],
                                       :node_size =&gt; 15)

modify_vis(_::Knows, _, _, _) = Dict(:edge_color =&gt; :lightgrey,
                                     :edge_width =&gt; 0.5);</code></pre><p>We are using a helper function to modify the node colors to indicate the agent&#39;s opinion and add a color bar to the plot.</p><pre><code class="language-julia hljs">function plot_opinion(sim)
    vp = create_graphplot(cysim,
                          update_fn = modify_vis)
    Vahana.plot(vp).layout = NetworkLayout.Stress()
    Makie.hidedecorations!(axis(vp))
    Makie.Colorbar(figure(vp)[:, 2]; colormap = colors)
    figure(vp)
end;</code></pre><p>And now we can plot the initial state</p><pre><code class="language- hljs">plot_opinion(cysim)</code></pre><p>And then the state after 500 iterations</p><pre><code class="language- hljs">for _ in 1:500
    apply!(cysim, step, [ HKAgent ], [ HKAgent, Knows ], [ HKAgent ])
end

plot_opinion(cysim)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial1.html">« Tutorial</a><a class="docs-footer-nextpage" href="predator.html">Predator / Prey »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 19 July 2023 11:18">Wednesday 19 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
