<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Initialization · Vahana Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Vahana Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorial1.html">Tutorial</a></li><li><a class="tocitem" href="hegselmann.html">Opinion Model</a></li><li><a class="tocitem" href="predator.html">Predator / Prey</a></li></ul></li><li><a class="tocitem" href="performance.html">Performance Tuning</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="definition.html">Model Definition</a></li><li class="is-active"><a class="tocitem" href="initialization.html">Initialization</a><ul class="internal"><li><a class="tocitem" href="#Graphs"><span>Graphs</span></a></li><li><a class="tocitem" href="#Raster"><span>Raster</span></a></li><li><a class="tocitem" href="#Finish-initialization"><span>Finish initialization</span></a></li></ul></li><li><a class="tocitem" href="transition.html">Transition Function</a></li><li><a class="tocitem" href="global.html">Global Layer</a></li><li><a class="tocitem" href="plots.html">Plots</a></li><li><a class="tocitem" href="hdf5.html">HDF5</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="config.html">Configuration</a></li><li><a class="tocitem" href="misc.html">Misc</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="initialization.html">Initialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="initialization.html">Initialization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-fuerst/Vahana.jl/blob/main/docs/src/initialization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h1><p>After we created a simulation by calling <a href="definition.html#Vahana.create_simulation"><code>create_simulation</code></a>, we must build the initial state of the simulation. As in Vahana the state of a model is represented as a graph, this means we must add the nodes (our agents) and edges to the graph.</p><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_agent!" href="#Vahana.add_agent!"><code>Vahana.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_agent!(sim, agent::T)::AgentID</code></pre><p>Add a single agent of type T to the simulation <code>sim</code>.</p><p>T must have been previously registered by calling <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>.</p><p><code>add_agent!</code> returns a new AgentID, which can be used to create edges from or to this agent until <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> is called (in the case that <code>add_agent!</code> is called in the initialization phase), or until the transition funcion is finished (in the case that <code>add_agent!</code> is called in an <a href="transition.html#Vahana.apply!"><code>apply!</code></a> callback). Do not use the ID for other purposes, they are not guaranteed to be stable.</p><p>See also <a href="initialization.html#Vahana.add_agents!"><code>add_agents!</code></a>, <a href="initialization.html#Vahana.add_edge!"><code>add_edge!</code></a> and <a href="initialization.html#Vahana.add_edges!"><code>add_edges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Agent.jl#L111-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_agents!" href="#Vahana.add_agents!"><code>Vahana.add_agents!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_agents!(sim, agents)::Vector{AgentID}</code></pre><p>Add multiple agents at once to the simulation <code>sim</code>.</p><p><code>agents</code> can be any iterable set of agents, or an arbitrary number of agents as arguments. </p><p>The types of the agents must have been previously registered by calling <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>.</p><p><code>add_agents!</code> returns a vector of AgentIDs, which can be used to create edges from or to this agents before <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> is called (in the case that <code>add_agents!</code> is called in the initialization phase), or before the transition funcion is finished (in the case that <code>add_agents!</code>  is called in an <a href="transition.html#Vahana.apply!"><code>apply!</code></a> callback). Do not use the ID for other purposes, they are not guaranteed to be stable.</p><p>See also <a href="initialization.html#Vahana.add_agent!"><code>add_agent!</code></a>, <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>, <a href="initialization.html#Vahana.add_edge!"><code>add_edge!</code></a> and <a href="initialization.html#Vahana.add_edges!"><code>add_edges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Agent.jl#L132-L153">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The IDs created by <code>add_agent(s)!</code> contain Vahana internal information, that can change after an <a href="transition.html#Vahana.apply!"><code>apply!</code></a> or the <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> call. It is even possible that  different agents have the same ID at different times. This has the implication, that  the IDs can only be used temporary and should not be stored in the state of an agent or edge.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Vahana.Edge" href="#Vahana.Edge"><code>Vahana.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Edge{T} 
    from::AgentID
    state::T
end</code></pre><p>An edge between to agents with (optionally) additional state. T can be also a struct without any field.</p><p>The AgentID of the agent at the target of the edge is not a field of <code>Edge</code> itself, since this information is already part of the containers in which the edges are stored.</p><p>See also <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Edge.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_edge!" href="#Vahana.add_edge!"><code>Vahana.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_edge!(sim, to::AgentID, edge::Edge{T})</code></pre><p>Add a single edge to the simulation <code>sim</code>. The edges is directed from the agent with ID <code>edge.from</code> (the source) to the agent with ID <code>to</code> (the target).</p><pre><code class="nohighlight hljs">add_edge!(sim, from::AgentID, to::AgentID, state::T)</code></pre><p>Add a single edge to the simulation <code>sim</code>. The edge is directed from the agent with ID <code>from</code> (the source) to the agent with ID <code>to</code> (the target) and has the state <code>state</code>.</p><p><code>T</code> must have been previously registered in the simulation by calling <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a>.</p><p>See also <a href="initialization.html#Vahana.Edge"><code>Edge</code></a> <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a> and <a href="initialization.html#Vahana.add_edges!"><code>add_edges!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Edge.jl#L33-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_edges!" href="#Vahana.add_edges!"><code>Vahana.add_edges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_edges!(sim, to::AgentID, edges)</code></pre><p>Add multiple <code>edges</code> at once to the simulation <code>sim</code>, with all edges are directed to <code>to</code>.</p><p><code>edges</code> can be any iterable set of agents, or an arbitrary number of edges as arguments. </p><p>See also <a href="initialization.html#Vahana.Edge"><code>Edge</code></a> <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a> and <a href="initialization.html#Vahana.add_edge!"><code>add_edge!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Edge.jl#L67-L77">source</a></section></article><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><p>It is also possible to use <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/simplegraphs_generators/">graph generators</a> from the Graphs.jl package to construct the initial state. Or parts of it, since you can combine it with all the other functions described on this page. Since Graphs.jl has overlapping function names with Vahana, it is advisable to import only the SimpleGraphs module from Graphs.jl.</p><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_graph!" href="#Vahana.add_graph!"><code>Vahana.add_graph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_graph!(sim::Simulation, graph, agent_constructor, edge_constructor) -&gt; Vector{AgentID}</code></pre><p>Adds a <code>graph</code> from the Graphs.jl package to <code>sim</code>, incl. all vertices of <code>graph</code> as new agents.</p><p><code>graph</code> must be a Graphs.Graph or a Graphs.DiGraph.</p><p>For each vertix of <code>graph</code> the <code>agent_constructor</code> function is called, with the Graphs.vertix as argument. For each edge of <code>graph</code> the <code>edge_constructor</code> function is called, with the Graphs.edge as argument.</p><p>The agent types of agents created by the <code>agent_constructor</code> must be already registered via <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a> and vis a vis the edge type via <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>add_graph! is only available when the Graphs.jl package is imported by the model implementation. </p></div></div><p>Returns a vector with the IDs of the created agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/GraphsSupport.jl#L11-L33">source</a></section></article><p>There is also two function with works the other way and converts the underlying graph of an simulation (or a subset of this graph) to a structure that fulfills the AbstractGraph or AbstractSimpleGraph interface from the Graphs.jl package.</p><article class="docstring"><header><a class="docstring-binding" id="Vahana.vahanagraph" href="#Vahana.vahanagraph"><code>Vahana.vahanagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vahanagraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true, drop_multiedges = false])</code></pre><p>Creates a subgraph with nodes for all agents that have one of the <code>agenttypes</code> types, and all edges that have one of the <code>edgetypes</code> types and whose both adjacent agents have are of a type in <code>agenttypes</code>.</p><p>The default values for <code>agenttypes</code> and <code>edgetypes</code> are all registered agents/edgetypes (see <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a> and <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a>).</p><p>This subgraphs implements the AbstractGraph interface from the Graphs.jl package, so that e.g. GraphMakie can be used to visualize the subgraph. See also <a href="plots.html#Vahana.create_graphplot"><code>create_graphplot</code></a>.</p><p>The AbstractGraph interface allows multiple edges between two nodes, but some functions (e.g. those that convert the graph to a binary (sparse) matrix) may produce undefined results for these graphs, e.g. when graphplot is called from GraphMakie.jl. If the keyword <code>drop_multiedges</code> is true and there are multiple edges, only the edge of the type that is first in the edgetypes vector is added to the generated graph.</p><p>The edge types must not have the :IgnoreFrom property. If there are edge types with this property in the <code>edgetypes</code> vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting <code>show_ignorefrom_warning</code> to false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/GraphsSupport.jl#L184-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Vahana.vahanasimplegraph" href="#Vahana.vahanasimplegraph"><code>Vahana.vahanasimplegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vahanasimplegraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true])</code></pre><p>Creates a subgraph with nodes for all agents that have one of the <code>agenttypes</code> types, and all edges that have one of the <code>edgetypes</code> types and whose both adjacent node types are in <code>agenttypes</code>.</p><p>The default values for <code>agenttypes</code> and <code>edgetypes</code> are all registered agents/edgetypes (see <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a> and <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a>).</p><p>This subgraphs implements the AbstractSimpleGraph interface from the Graphs.jl package.</p><p>The edge types must not have the :IgnoreFrom property. If there are edge types with this property in the <code>edgetypes</code> vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting <code>show_ignorefrom_warning</code> to false.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The AbstractGraph interface allows multiple edges between two nodes, but some function (e.g. those that convert the graph into a binary (sparse)matrix can produce undefined results for those graphs. So use this function with care. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/GraphsSupport.jl#L81-L106">source</a></section></article><h2 id="Raster"><a class="docs-heading-anchor" href="#Raster">Raster</a><a id="Raster-1"></a><a class="docs-heading-anchor-permalink" href="#Raster" title="Permalink"></a></h2><p>Spatial information can be added to the simulation in the form of one or more n-dimensional rasters. </p><article class="docstring"><header><a class="docstring-binding" id="Vahana.add_raster!" href="#Vahana.add_raster!"><code>Vahana.add_raster!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_raster!(sim, name::Symbol, dims::NTuple{N, Int}, agent_constructor)</code></pre><p>Adds a n-dimensional grid to <code>sim</code>, with the dimensions <code>dims</code>.</p><p>For each cell a new node/agent is added to the graph. To create the agent, the <code>agent_constructor</code> function is called, with the cell position in form of an <code>CartesianIndex</code> as argument.</p><p>The symbol <code>name</code> is an identifier for the created raster, as it is allowed to add multiple rasters to <code>sim</code>. </p><p>The types of the agents created by the <code>agent_constructor</code> must be already registered via <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>.</p><p>Returns a vector with the IDs of the created agents.</p><p>Can be only called before <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a>.</p><p>See also <a href="global.html#Vahana.calc_raster"><code>calc_raster</code></a> <a href="initialization.html#Vahana.connect_raster_neighbors!"><code>connect_raster_neighbors!</code></a> and <a href="initialization.html#Vahana.move_to!"><code>move_to!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Raster.jl#L6-L27">source</a></section></article><p>Such a raster is only a collection of nodes in the graph incl. an Vahana internal mapping from the cartesian coordinates to the cell IDs. Beside this mapping, cells are also just agents, but there are some Vahana functions like <a href="global.html#Vahana.calc_raster"><code>calc_raster</code></a> that utilize the internal cartesian coordinates to create a n-dimensional representation of the state space.</p><p>The ID and the state of the cells can not be accessed directly, instead it&#39;s necessary to create edges between the cells, or between the cells and agents of other types via the following two helper functions.</p><article class="docstring"><header><a class="docstring-binding" id="Vahana.connect_raster_neighbors!" href="#Vahana.connect_raster_neighbors!"><code>Vahana.connect_raster_neighbors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connect_raster_neighbors!(sim, name::Symbol, edge_constructor; [distance::Int, metric:: Symbol, periodic::Bool])</code></pre><p>All cells that are at most <code>distance</code> from each other (using the metric <code>metric</code>) are connected with edges, where the edges are created with the <code>edge_constructor</code>.</p><p>The <code>edge_constructor</code> must be a function with one argument with type Tuple{CartesianIndex, CartesianIndex}. The first CartesianIndex is the position of the source node, and the second CartesianIndex the position of the target node.</p><p>Valid metrics are :chebyshev, :euclidean and :manhatten.</p><p>The keyword periodic determines whether all dimensions are cyclic (e.g., in the two-dimensional case, the raster is a torus).</p><p>The default values of the optional keyword arguments are 1 for <code>distance</code>, :chebyshev for <code>metric</code> and true for <code>periodic</code>. which is equivalent to a Moore neighborhood. The :manhatten metric can be used to connect cells in the von Neumann neighborhood.</p><p>The agent types of agents created by the <code>agent_constructor</code> must be already registered via <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>.</p><p>See also <a href="initialization.html#Vahana.add_raster!"><code>add_raster!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Raster.jl#L97-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Vahana.move_to!" href="#Vahana.move_to!"><code>Vahana.move_to!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_to!(sim, name::Symbol, id::AgentID, pos, edge_from_raster, edge_to_raster; [distance = 0, metric = :chebyshev, periodic = true])</code></pre><p>Creates up to two edges of type between the agent with ID <code>id</code> and the cell from the raster <code>name</code> at the position <code>pos</code>.</p><p><code>pos</code> must be of type CartesianIndex or a Dims{N}. </p><p><code>edge_from_raster</code> is the edge that will be added with the cell as source node and the agent as target node. <code>edge_from_raster</code> can be <code>nothing</code>, in this case no edge will be added with the agent as target node.</p><p><code>edge_to_raster</code> is the edge that will be added with the agent as source node and the cell as target node. <code>edge_to_raster</code> can be <code>nothing</code>, in this case no edge will be added with the agent as source node.</p><p>Using the keyword arguments, it is possible to add additional edges to the surroundings of the cell at position <code>pos</code> in the same raster, i.e. to all cells at distance <code>distance</code> under metric <code>metric</code>, where valid metrics are :chebyshev, :euclidean and :manhatten<code>. And the keyword</code>periodic` determines whether all dimensions are cyclic.</p><p>See also <a href="initialization.html#Vahana.add_raster!"><code>add_raster!</code></a> and <a href="initialization.html#Vahana.connect_raster_neighbors!"><code>connect_raster_neighbors!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Raster.jl#L288-L312">source</a></section></article><h2 id="Finish-initialization"><a class="docs-heading-anchor" href="#Finish-initialization">Finish initialization</a><a id="Finish-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Finish-initialization" title="Permalink"></a></h2><p>After all the initial state has been built using the functions described above, <code>finish_init!</code> must be called before the first call of <a href="transition.html#Vahana.apply!"><code>apply!</code></a></p><article class="docstring"><header><a class="docstring-binding" id="Vahana.finish_init!" href="#Vahana.finish_init!"><code>Vahana.finish_init!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finish_init!(sim::Simulation; [distribute = true, 
             partition::Dict{AgentID, ProcessID}, 
             partition_algo = :Metis])</code></pre><p>Finish the initialization phase of the simulation. </p><p><code>partition</code> is an option keyword and allows to specify an assignment of the agents to the individual MPI ranks. The dictonary must contain all agentids created on the rank as key, the corresponding value is the rank on which the agent &quot;lives&quot; after <code>finish_init!</code>.</p><p>In the case that no <code>partition</code> is given and <code>distribute</code> is set to true, the Graph will be partitioned with the given <code>partition_algo</code>. Currently two algorithms are supported:     - :Metis uses the Metis library for the graph partitioning.      - :EqualAgentNumbers just ensures that per agent type more or less       the same number of agents are distributed to each process.</p><p><code>finish_init!</code> must be called before applying a transition function. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>When a simulation is run on multiple PEs, per default the graph found on rank 0 will be partitioned using Metis, and distributed to the different ranks. Which means that it&#39;s allowed to run the initialization phase on all ranks (there is no need for a mpi.isroot check), but then all added agents and edges on other ranks then 0 will be discarded. If this is not intended <code>distribute</code> must be set to false.</p></div></div><p>See also <a href="definition.html#Vahana.register_agenttype!"><code>register_agenttype!</code></a>, <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a>, <a href="transition.html#Vahana.apply!"><code>apply!</code></a> and <a href="misc.html#Vahana.finish_simulation!"><code>finish_simulation!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-fuerst/Vahana.jl/blob/866ed9a0dd8fab4f8625ec040d5b5159df372cff/src/Simulation.jl#L286-L319">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="definition.html">« Model Definition</a><a class="docs-footer-nextpage" href="transition.html">Transition Function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 3 January 2024 18:56">Wednesday 3 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
