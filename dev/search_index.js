var documenterSearchIndex = {"docs":
[{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"CurrentModule = Vahana","category":"page"},{"location":"global.html#Modify-Globals","page":"Global Layer","title":"Modify Globals","text":"","category":"section"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"You can add a new or additional value to the globals struct with:","category":"page"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"set_global!\npush_global!\nmodify_global!\nVahana.mapreduce","category":"page"},{"location":"global.html#Vahana.set_global!","page":"Global Layer","title":"Vahana.set_global!","text":"set_global!(sim::Simulation, name, value)\n\nSet the value of the field name of the globals struct for simulation sim.\n\nIn parallel simulations, set_global! must be called on all processes, and with identical value across all processes.\n\nset_global! must not be called within a transition function. \n\nSee also create_simulation, mapreduce, modify_global! push_global! and get_global\n\n\n\n\n\n","category":"function"},{"location":"global.html#Vahana.push_global!","page":"Global Layer","title":"Vahana.push_global!","text":"push_global!(sim::Simulation, name, value)\n\nIn the case that a field of the globals struct from the Simulation constructor is a vector (e.g. for time series data), push_global! can be used to add a value to this vector, instead of writing set_global!(sim, name, push!(get_global(sim, name), value).\n\nIn parallel simulations, push_global! must be called on all processes, and with identical value across all processes.\n\npush_global! must not be called within a transition function. \n\nSee also create_model, mapreduce, set_global! and get_global\n\n\n\n\n\n","category":"function"},{"location":"global.html#Vahana.modify_global!","page":"Global Layer","title":"Vahana.modify_global!","text":"modify_global!(sim::Simulation, name, f)\n\nModify the value of the name field of the globals structure for the simulation sim using the f function, which receives the current value as an argument.\n\nThis is a combination of set_global! and get_global: set_global!(sim, name, f(get_global(sim, name))).\n\nmodify_global! must not be called within a transition function.\n\nIn parallel simulations, push_global! must be called on all processes, and with identical value across all processes.\n\nSee also create_simulation, mapreduce, set_global! push_global! and get_global\n\n\n\n\n\n","category":"function"},{"location":"global.html#Base.mapreduce","page":"Global Layer","title":"Base.mapreduce","text":"mapreduce(sim, f, op, ::Type{T}; [kwargs ...])\n\nCalculate an aggregated value, based on the state of all agents or edges of type T.\n\nf is applied to all of these agents or edges and then op is used to reduce (aggregate) the values returned by f.\n\nmapreduce is calling Base.mapreduce, f, op and kwargs are passed directly to mapreduce, while sim and T are used to determine the iterator.\n\n\n\n\n\n","category":"function"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"warning: Warning\nThe state of the globals struct (the globals argument of the  create_simulation function can not be changed  inside of a transition function, as a transition function is calculated on  a per agent basis with many evaluations in parallel, and changes to the global layer must be a single, synchronized operation.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"EditURL = \"../examples/predator.jl\"","category":"page"},{"location":"predator.html#Adding-Spatial-Information","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"","category":"section"},{"location":"predator.html#Goal","page":"Adding Spatial Information","title":"Goal","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"This example demonstrates how spatial information can be integrated into an agent-based model using Vahana. While Vahana's primary focus is on graph-based simulations, it support the inclusion of spatial information into models.  It allows you to define a spatial grid, associate agents with specific locations, and implement interactions based on spatial proximity, even though the underlying implementation still operates on graph structures.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"It's worth noting that in its current version, Vahana may not be the optimal choice for models that primarily depend on frequent movement of agents across space. However, as this example will show, it is entirely possible to implement those models.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"It allows you to define a spatial grid, associate agents with specific locations, and implement interactions based on spatial proximity, all while leveraging Vahana's efficient graph-based computations.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"For the understanding of how Vahana handles spatial information and rasters, you may find it helpful to watch also the corresponding section of the Vahana.jl Juliacon video. The video provides a visual explanation of how rasters are implemented within Vahana's graph-based framework and demonstrates some key concepts that we'll be applying in this tutorial.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"In this tutorial, we'll implement a predator-prey model with spatial components, showcasing how Vahana's raster functionality can be used to create a spatially-explicit ecological simulation.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The model is based on the Predator-Prey for High-Performance Computing (PPHPC) model. In PPHPC the agents move randomly, in our implementation the prey move to locations with grass (if one is in sight) and the predators move to locations with prey to demonstrate how features like this can be implemented in Vahana.","category":"page"},{"location":"predator.html#Agent-and-Edge-Types","page":"Adding Spatial Information","title":"Agent and Edge Types","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"using CairoMakie, Vahana, Random\n\nRandom.seed!(1); #hide\ndetect_stateless(true) #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"In our spatial predator-prey model, we define separate structures for predators and prey, even though they share the same fields:","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct Predator\n    energy::Int64\n    pos::CartesianIndex{2}\nend\n\nstruct Prey\n    energy::Int64\n    pos::CartesianIndex{2}\nend","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Despite their identical structure, we define them as separate types because Vahana uses these types as tags for differentiating between agent categories.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"In the following sections, we'll use \"Species\" as an umbrella term to refer to both Predator and Prey. Functions that are applicable to both types will take the type as a parameter, which we'll denote as Species in the function arguments.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Aside from the predator and prey agents, the spatial environment is represented by grid cells, which are also implemented as agents and consequently function as nodes within the graph structure.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct Cell\n    pos::CartesianIndex{2}\n    countdown::Int64\nend","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"All agents maintain their position as part of their internal state. However, a cell can only perceive the animals if they are directly connected to the cell through an edge. Vahana facilitates the establishment of such edges via the move_to! function.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Edges represent connections from prey or predators to cells. We define Position as a parametric type, enabling cells to distinguish between prey and predators based on the type of the edges.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct Position{T} end","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Views are also edges from the cells to the prey and predators respectively. These edges represent the cells that are visible to a prey or predator so that, for example, it is possible to check which cell in the visible area contains food.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct View{T} end","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"VisiblePrey edges represent connections from prey to predator. Currently, all edge types link animals to cells, and without an incoming edge from prey, a predator lacks awareness of prey positions. The VisiblePrey edges are generated by cells through the find_prey transition function, as cells possess knowledge of which Prey entities are directly located on the cell via the Position{Prey} edges, and consequently within the view of a predator via the View{Predator} edges.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct VisiblePrey end","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The last two edge types are messages to inform the agents that they must die or find something to eat.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"struct Die end\n\nstruct Eat end","category":"page"},{"location":"predator.html#Params-and-Globals","page":"Adding Spatial Information","title":"Params and Globals","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We follow the parameter structure from the PPHPC model, but use (besides the initial population) the same parameters for Prey and Predator for the example run.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Base.@kwdef mutable struct SpeciesParams\n    init_population::Int64 = 500\n    gain_from_food::Int64 = 5\n    loss_per_turn::Int64 = 1\n    repro_thres::Int64 = 5\n    repro_prob::Int64 = 20\nend\n\nBase.@kwdef struct AllParams\n    raster_size::Tuple{Int64, Int64} = (100, 100)\n    restart::Int64 = 5\n    predator::SpeciesParams = SpeciesParams()\n    prey::SpeciesParams = SpeciesParams()\nend;\n\nparams = AllParams()\nparams.prey.init_population = 2000;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We are creating timeseries (in the form of Vectors) for the predator and prey population, the number of cells with food, and the average energy of the predators and prey.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Base.@kwdef mutable struct PPGlobals\n    predator_pop = Vector{Int64}()\n    prey_pop = Vector{Int64}()\n    cells_with_food = Vector{Int64}()\n    mean_predator_energy = Vector{Float64}()\n    mean_prey_energy = Vector{Float64}()\nend;\nnothing #hide","category":"page"},{"location":"predator.html#Create-the-Simulation","page":"Adding Spatial Information","title":"Create the Simulation","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We have now defined all the Julia structs needed to create the model and a simulation.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"const ppsim = ModelTypes() |>\n    register_agenttype!(Predator) |>\n    register_agenttype!(Prey) |>\n    register_agenttype!(Cell) |>\n    register_edgetype!(Position{Predator}) |>\n    register_edgetype!(Position{Prey}) |>\n    register_edgetype!(View{Predator}) |>\n    register_edgetype!(View{Prey}) |>\n    register_edgetype!(VisiblePrey) |>\n    register_edgetype!(Die) |>\n    register_edgetype!(Eat) |>\n    create_model(\"Predator Prey\") |>\n    create_simulation(params, PPGlobals())","category":"page"},{"location":"predator.html#Initialization","page":"Adding Spatial Information","title":"Initialization","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"First we add the Cells to the Simulation. Therefore we define a constructor function for the cells. There is a 50% probability that a cell contains food (and in this case countdown is 0).","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"init_cell(pos::CartesianIndex) =\n    Cell(pos, rand() < 0.5 ? 0 : rand(1:param(ppsim, :restart)))\n\nadd_raster!(ppsim, :raster, param(ppsim, :raster_size), init_cell);\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We define a auxiliary functions to facilitate the relocation of an agent to a new position. These functions will add a single Position edge from the animal to the cell at the newpos position, and for all cells within a Manhattan distance of 1, View edges will be established from those cells to and from the animal, as well as to the cell itself.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function move!(sim, id, newpos, Species)\n    move_to!(sim, :raster, id, newpos, nothing, Position{Species}())\n    move_to!(sim, :raster, id, newpos, View{Species}(), View{Species}();\n             distance = 1, metric = :manhatten)\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The add_animals function is a generic initializer for both predators and prey, taking species-specific parameters and the species type as arguments. It creates a specified number of agents, each with a random position on the raster and a random initial energy within a defined range, then adds them to the simulation and places them on the raster using the move! function.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function add_animals(params, Species)\n    energyrange = 1:(2*params.gain_from_food)\n    foreach(1:params.init_population) do _\n        pos = random_pos(ppsim, :raster)\n        id = add_agent!(ppsim, Species(rand(energyrange), pos))\n        move!(ppsim, id, pos, Species)\n    end\nend\n\nadd_animals(param(ppsim, :prey), Prey)\nadd_animals(param(ppsim, :predator), Predator)","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"At the end of the initialization phase we have to call finish_init!","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"finish_init!(ppsim)","category":"page"},{"location":"predator.html#Transition-Functions","page":"Adding Spatial Information","title":"Transition Functions","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"As mentioned in the comment for the View type, the cells are responsible for connecting the Prey with the Predators. So each cell iterate over each prey on the cell and add edges to all predators that can view the cell.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The underscore () as the first argument in the findprey function signifies that we don't need to access the state of the cell itself. This is because the function only needs to check for the presence of edges and create new connections based on those edges, without using any information from the cell's internal state. As a result, when we call apply! for findprey, we don't include Cell in the read argument. Consequently, Vahana passes Val(Cell) as the first argument to findprey for multiple dispatch purposes, rather than the actual cell state. This approach optimizes performance by avoiding unnecessary data access and allows the function to operate solely on the graph structure of the simulation.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function find_prey(_::Val{Cell}, id, sim)\n    if has_edge(sim, id, Position{Prey}) && has_edge(sim, id, View{Predator})\n        for preyid in neighborids(sim, id, Position{Prey})\n            for predid in neighborids(sim, id, View{Predator})\n                add_edge!(sim, preyid, predid, VisiblePrey())\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"If a predator has enough energy left to move and there is a prey in the predator's field of view, a random prey is selected and its position is used as the new position. If no prey is visible, a random cell in the predator's field of view is selected as the new position.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"If there is not enough energy left, the transition function returns nothing, which means that the predator dies and is no longer part of the graph.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function move(state::Predator, id, sim)\n    e = state.energy - param(sim, :predator).loss_per_turn\n    if e > 0\n        # we need to access the pos of the prey which is part of it's state\n        prey = neighborstates(sim, id, VisiblePrey, Prey)\n        newpos = if isnothing(prey)\n            nextcellid = rand(neighborids(sim, id, View{Predator}))\n            agentstate(sim, nextcellid, Cell).pos\n        else\n            rand(prey).pos\n        end\n        move!(sim, id, newpos, Predator)\n        Predator(e, newpos)\n    else\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The movement logic for prey differs from that of predators in terms of their target. While predators seek cells containing prey, prey agents search for cells with available grass. In our implementation of the PPHPC (Predator-Prey for High-Performance Computing) model, grass availability is indicated by the countdown field of a cell. Specifically, grass is considered available for consumption when a cell's countdown value equals 0.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function move(state::Prey, id, sim)\n    e = state.energy - param(sim, :prey).loss_per_turn\n    if e > 0\n        withgrass = filter(neighborids(sim, id, View{Prey})) do id\n            agentstate(sim, id, Cell).countdown == 0\n        end\n        nextcellid = if length(withgrass) == 0\n            rand(neighborids(sim, id, View{Prey}))\n        else\n            rand(withgrass)\n        end\n        newpos = agentstate(sim, nextcellid, Cell).pos\n        move!(sim, id, newpos, Prey)\n        Prey(e, newpos)\n    else\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"If a cell has no grass and the countdown field is therefore > 0, the countdown is decreased by 1.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function grow_food(state::Cell, _, _)\n    Cell(state.pos, max(state.countdown - 1, 0))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The try_eat transition function simulates the predator-prey interactions and feeding processes within each cell. When both predators and prey occupy the same cell, the function generates random predator-prey pairings, ensuring each prey is targeted at most once and each predator consumes no more than one prey. These interactions are represented by creating Die edges from the cell to the consumed prey and Eat edges from the cell to the successful predators. If any prey survive this process and the cell contains available grass (indicated by a countdown of 0), an Eat edge is established between the cell and a randomly selected surviving prey, simulating grazing behavior.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function try_eat(state::Cell, id, sim)\n    predators = neighborids(sim, id, Position{Predator})\n    prey = neighborids(sim, id, Position{Prey})\n\n    # first the predators eat the prey, in case that both are on the cell\n    if ! isnothing(predators) && ! isnothing(prey)\n        prey = Set(prey)\n        for pred in shuffle(predators)\n            if length(prey) > 0\n                p = rand(prey)\n                add_edge!(sim, id, p, Die())\n                add_edge!(sim, id, pred, Eat())\n                delete!(prey, p)\n            end\n        end\n    end\n\n    # then check if there is prey left that can eat the grass\n    if  ! isnothing(prey) && length(prey) > 0 && state.countdown == 0\n        add_edge!(sim, id, rand(prey), Eat())\n        Cell(state.pos, param(sim, :restart))\n    else\n        state\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The reproduction mechanism for both predators and prey follows a similar pattern, allowing us to define a generic function applicable to both species. This function first determines if the animal found something to eat by checking for the presence of an Eat edge targeting the animal, a result of previous transition functions. If such an edge exists, the animal's energy increases.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The function then evaluates if the animal's energy exceeds a specified threshold parameter. When this condition is met, reproduction occurs: a new offspring is introduced to the simulation via the add_agent call, inheriting half of its parent's energy, and is positioned at the same location as its parent using the move! function.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function try_reproduce_imp(state, id, sim, species_params, Species)\n    if has_edge(sim, id, Eat)\n        state = Species(state.energy + species_params.gain_from_food, state.pos)\n    end\n    if state.energy > species_params.repro_thres &&\n        rand() * 100 < species_params.repro_prob\n\n        energy_offspring = Int64(round(state.energy / 2))\n        newid = add_agent!(sim, Species(energy_offspring, state.pos))\n        move!(sim, newid, state.pos, Species)\n        Species(state.energy - energy_offspring, state.pos)\n    else\n        state\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"For the Predator we can just call the reproduce function with the necessary arguments.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"try_reproduce(state::Predator, id, sim) =\n    try_reproduce_imp(state, id, sim, param(sim, :predator), Predator)","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The prey animal needs an extra step because it might have been eaten by a predator. So, we check if there is a Die edge leading to the prey animal, and if so, the prey animal is removed from the simulation (by returning nothing). Otherwise, we again just call the reproduce function defined above.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function try_reproduce(state::Prey, id, sim)\n    if has_edge(sim, id, Die)\n        return nothing\n    end\n    try_reproduce_imp(state, id, sim, param(sim, :prey), Prey)\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We update the global values and use the mapreduce method to count the population and the number of cells with food. Based on the values, we can then also calculate the mean energy values.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function update_globals(sim)\n    push_global!(sim, :predator_pop, mapreduce(sim, _ -> 1, +, Predator; init = 0))\n    push_global!(sim, :prey_pop, mapreduce(sim, _ -> 1, +, Prey; init = 0))\n    push_global!(sim, :cells_with_food,\n                mapreduce(sim, c -> c.countdown == 0, +, Cell))\n    push_global!(sim, :mean_predator_energy,\n                mapreduce(sim, p -> p.energy, +, Predator; init = 0) /\n                    last(get_global(sim, :predator_pop)))\n    push_global!(sim, :mean_prey_energy,\n                mapreduce(sim, p -> p.energy, +, Prey; init = 0) /\n                    last(get_global(sim, :prey_pop)))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"We add to our time series also the values after the initialization.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"update_globals(ppsim);\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"And finally we define in which order our transitions functions are called. Worth mentioning here are the keyword arguments in find_prey and try_reproduce.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"The addexisting keyword in the tryreproduce transition function signify that the currently existing position and view edges should not be removed, and only additional edges should be added, in our case the position of the potential offspring.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function step!(sim)\n    apply!(sim, move,\n           [ Prey ],\n           [ Prey, View{Prey}, Cell ],\n           [ Prey, View{Prey}, Position{Prey} ])\n\n    apply!(sim, find_prey,\n           [ Cell ],\n           [ Position{Prey}, View{Predator} ],\n           [ VisiblePrey ])\n\n    apply!(sim, move,\n           [ Predator ],\n           [ Predator, View{Predator}, Cell, Prey, VisiblePrey ],\n           [ Predator, View{Predator}, Position{Predator} ])\n\n    apply!(sim, grow_food, Cell, Cell, Cell)\n\n    apply!(sim, try_eat,\n           [ Cell ],\n           [ Cell, Position{Predator}, Position{Prey} ],\n           [ Cell, Die, Eat ])\n\n    apply!(sim, try_reproduce,\n           [ Predator, Prey ],\n           [ Predator, Prey, Die, Eat ],\n           [ Predator, Prey, Position{Predator}, Position{Prey},\n             View{Predator}, View{Prey} ];\n           add_existing = [ Position{Predator}, Position{Prey},\n                            View{Predator}, View{Prey} ])\n\n    update_globals(sim)\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"Now we can run the simulation","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"for _ in 1:400 step!(ppsim) end","category":"page"},{"location":"predator.html#Plots","page":"Adding Spatial Information","title":"Plots","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"To visualize the results we use the Makie package.","category":"page"},{"location":"predator.html#Time-series","page":"Adding Spatial Information","title":"Time series","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"First, we will generate a line chart for the time series data stored in the global state. Vahana provides the plot_globals function for this purpose. This function not only returns the Makie Figure itself but also the Axis and Plots, allowing for further processing of the result. If you wish to display the default result, you can utilize the Julia first function to extract the figure from the returned tuple.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"plot_globals(ppsim, [ :predator_pop, :prey_pop, :cells_with_food ]) |> first","category":"page"},{"location":"predator.html#Spatial-distribution","page":"Adding Spatial Information","title":"Spatial distribution","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"To visualize the spatial information we can use heatmap in combination with the Vahana's calc_raster function. E.g. the number of Position{Prey} edges connected to a cell give us the number of Prey individuals currently on that cell.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"It would be nice to have a colorbar for the heatmaps so we define a small helper function that can be used in a pipe.","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"function add_colorbar(hm)\n    Makie.Colorbar(hm.figure[:,2], hm.plot)\n    hm\nend;\nnothing #hide","category":"page"},{"location":"predator.html#Predators-Positions","page":"Adding Spatial Information","title":"Predators Positions","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"calc_raster(ppsim, :raster, Int64, [ Position{Predator} ]) do id\n    num_edges(ppsim, id, Position{Predator})\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html#Prey-Positions","page":"Adding Spatial Information","title":"Prey Positions","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"calc_raster(ppsim, :raster, Int64, [ Position{Prey} ]) do id\n    num_edges(ppsim, id, Position{Prey})\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html#Cells-that-contains-food","page":"Adding Spatial Information","title":"Cells that contains food","text":"","category":"section"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"calc_raster(ppsim, :raster, Int64, [ Cell ]) do id\n    agentstate(ppsim, id, Cell).countdown == 0\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"","category":"page"},{"location":"predator.html","page":"Adding Spatial Information","title":"Adding Spatial Information","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"EditURL = \"../examples/hegselmann.jl\"","category":"page"},{"location":"hegselmann.html#Utilizing-Graphs.jl","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"","category":"section"},{"location":"hegselmann.html#Goal","page":"Utilizing Graphs.jl","title":"Goal","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"This tutorial illustrates how to integrate graphs that support the AbstractGraph interface from the Graphs.jl package into a Vahana simulation and the visualization support for Vahana graphs.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"For this purpose, we implement the opinion dynamics model of Hegselmann and Krause (2002). An alternative implementation of the same model using the Agents.jl package can be found here.","category":"page"},{"location":"hegselmann.html#Agent-and-Edge-Types","page":"Utilizing Graphs.jl","title":"Agent and Edge Types","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"using Vahana, Statistics","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"We have a finite number n of agents, where the state of the agents are a real number x_i(t) in the [0,1] interval which represents the opinion of that agent.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"struct HKAgent\n    opinion::Float64\nend","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"This time we have only one network that determine the agents that will be considered when an agent updates its opinion.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"struct Knows end","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Beside these two types there is a confidence bound epsilon  0, opinions with a difference greater than epsilon are ignored by the agents in the transition function. All agents have the same confidence bound, so we introduce this bound as a parameter.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"const hkmodel = ModelTypes() |>\n    register_agenttype!(HKAgent) |>\n    register_edgetype!(Knows) |>\n    register_param!(:ϵ, 0.02) |> # the confidence bound\n    create_model(\"Hegselmann-Krause\");\nnothing #hide","category":"page"},{"location":"hegselmann.html#Adding-a-Graph","page":"Utilizing Graphs.jl","title":"Adding a Graph","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Vahana allows adding SimpleGraphs and SimpleDiGraphs from the Graphs.jl package via the add_graph! function. So it is possible to use e.g. SNAPDatasets to run the opinion model on real datasets, or the SimpleGraphs module from Graphs.jl to create synthetic graphs.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"We demonstrate here both use cases and are creating a separate simulation for each one.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"const cgsim = create_simulation(hkmodel);\nconst snapsim = create_simulation(hkmodel)","category":"page"},{"location":"hegselmann.html#SimpleGraphs","page":"Utilizing Graphs.jl","title":"SimpleGraphs","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"First we will show how we can add a synthetic graph. For this we need to import the SimpleGraphs module. Since there are many functions in the Graphs.jl package with the same name as in Vahana (e.g. add_edge!), it is advisable to import only the needed parts of Graphs.jl instead of loading the whole package via using Graphs.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"import Graphs.SimpleGraphs","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"We want to add a complete graph, where each agent is connected with all the other agents, like in the Agents.jl implementation. We can create such a graph via SimpleGraphs.complete_graph.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"g = SimpleGraphs.complete_graph(50)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Vahana needs the information how to convert the nodes and edges of the SimpleGraphs object to the Vahana structure. This is done by the constructor functions in the third and forth arguments of add_graph!. We do not need the Graph.vertex and Graph.edge arguments of this constructor functions, but for other use cases e.g. for bipartite graphs, it would be possible to create agents of different types depending on this information.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"const agentids = add_graph!(cgsim,\n                            g,\n                            _ -> HKAgent(rand()),\n                            _ -> Knows());\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Each agent also adds its own opinion to the calculation. We can use the ids returned by the add_graph! functions for this.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"foreach(id -> add_edge!(cgsim, id, id, Knows()), agentids)\n\nfinish_init!(cgsim)","category":"page"},{"location":"hegselmann.html#SNAPDataset.jl","page":"Utilizing Graphs.jl","title":"SNAPDataset.jl","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"The SNAPDataset.jl package delivers Graphs.jl formatted datasets from the Stanford Large Network Dataset Collection.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"using SNAPDatasets","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"With this package we can use the loadsnap function to create the graph that is then added to the Vahana graph, e.g. in our example the facebook dataset.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"const snapids = add_graph!(snapsim,\n                           loadsnap(:facebook_combined),\n                           _ -> HKAgent(rand()),\n                           _ -> Knows());\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Again each agent adds its own opinion to the calculation.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"foreach(id -> add_edge!(snapsim, id, id, Knows()), snapids)\n\nfinish_init!(snapsim)","category":"page"},{"location":"hegselmann.html#The-Transition-Function","page":"Utilizing Graphs.jl","title":"The Transition Function","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Opinions are updated synchronously according to","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"beginaligned\nx_i(t+1) = frac1 mathcalN_i(t)  sum_j in mathcalN_i(t) x_j(t)\ntextrmwhere  quad mathcalN_i(t) =  j   x_j(t) - x_i(t)  leq epsilon \nendaligned","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"So we first filter all agents from the neighbors with an opinion outside of the confidence bound, and then calculate the mean of the opinions of the remaining agents.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"function step(agent, id, sim)\n    ϵ = param(sim, :ϵ)\n\n    opinions = map(a -> a.opinion, neighborstates(sim, id, Knows, HKAgent))\n\n    accepted = filter(opinions) do opinion\n        abs(opinion - agent.opinion) < ϵ\n    end\n\n    HKAgent(mean(accepted))\nend;\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"We can now apply the transition function to the complete graph simulation","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"apply!(cgsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Or to our facebook dataset","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"apply!(snapsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)","category":"page"},{"location":"hegselmann.html#Creating-Plots","page":"Utilizing Graphs.jl","title":"Creating Plots","text":"","category":"section"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Finally, we show the visualization possibilities for graphs, and import the necessary packages for this and create a colormap for the nodes.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"import CairoMakie, GraphMakie, NetworkLayout, Colors, Graphs, Makie","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Since the full graph is very cluttered and the Facebook dataset is too large, we construct a Clique graph using Graphs.jl.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"const cysim = create_simulation(hkmodel) |> set_param!(:ϵ, 0.25);\n\nconst cyids = add_graph!(cysim,\n                         SimpleGraphs.clique_graph(7, 8),\n                         _ -> HKAgent(rand()),\n                         _ -> Knows());\n\n\nforeach(id -> add_edge!(cysim, id, id, Knows()), cyids)\n\nfinish_init!(cysim);\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Vahana implements an interactive plot function based on GraphMakie, where agents and edges are given different colors per type by default, and the state of each agent/edge is displayed via mouse hover actions.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"vp = create_graphplot(cysim)\n\nfigure(vp)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"To modify the created plot, the Makie figure, axis and plot, can be accessed via the methods figure, axis and plot. This allows us to modify the graph layout and to remove the decorations.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"Vahana.plot(vp).layout = NetworkLayout.Stress()\n\nMakie.hidedecorations!(axis(vp))\n\nfigure(vp)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"To visualize the agents' opinions, we can leverage Vahana's integration with Makie's plotting capabilities. Instead of directly modifying the node_color property of the Makie plot, we can define custom visualization functions. These functions, which can have methods for different agent and edge types, are used by create_graphplot to determine various properties of nodes and edges in the plot.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"This approach not only allows for more dynamic and type-specific visualizations but also supports interactive plots when using GLMakie as the backend. We'll define a function called modify_vis that specifies how different elements should be displayed. This function will be passed to create_graphplot via the update_fn keyword argument.","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"colors = Colors.range(Colors.colorant\"red\", stop=Colors.colorant\"green\", length=100)\n\n\nmodify_vis(state::HKAgent, _ ,_) = Dict(:node_color => colors[state.opinion * 100 |> ceil |> Int],\n                                       :node_size => 15)\n\nmodify_vis(_::Knows, _, _, _) = Dict(:edge_color => :lightgrey,\n                                     :edge_width => 0.5);\n\nfunction plot_opinion(sim)\n    vp = create_graphplot(cysim,\n                          update_fn = modify_vis)\n    Vahana.plot(vp).layout = NetworkLayout.Stress()\n    Makie.hidedecorations!(axis(vp))\n    Makie.Colorbar(figure(vp)[:, 2]; colormap = colors)\n    figure(vp)\nend;\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"And now we can plot the initial state","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"plot_opinion(cysim)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"And then the state after 500 iterations","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"for _ in 1:500\n    apply!(cysim, step, [ HKAgent ], [ HKAgent, Knows ], [ HKAgent ])\nend\n\nplot_opinion(cysim)","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"","category":"page"},{"location":"hegselmann.html","page":"Utilizing Graphs.jl","title":"Utilizing Graphs.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"CurrentModule = Vahana","category":"page"},{"location":"config.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"The following functions allows to configure Vahana's behaviour:","category":"page"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"enable_asserts\nsuppress_warnings\ndetect_stateless\nset_compression","category":"page"},{"location":"config.html#Vahana.enable_asserts","page":"Configuration","title":"Vahana.enable_asserts","text":"enable_asserts(enable::Bool)\n\nVahana comes with some internal consistency checks, at the cost of run-time performance (e.g., in agentstate there are checks that the specified agenttype matches the agent's ID, which creates of course some overhead). The assertions that could degrade the run performance can be disabled by calling enable_asssertions(false).\n\nThe recommended approach is therefore to leave the assertions enabled during the development of the model, but to disable them when the model goes \"into production\", e.g. before the start of a parameter space exploration.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.suppress_warnings","page":"Configuration","title":"Vahana.suppress_warnings","text":"suppress_warnings(suppress::Bool)\n\nIn some cases Vahana print some hints or warnings to the stdout. This can be suppressed by calling the suppress_warnings(true) function after importing Vahana.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.detect_stateless","page":"Configuration","title":"Vahana.detect_stateless","text":"detect_stateless(detect::Bool = true)\n\nPer default, Vahana expects that the :Stateless hint is set manually.\n\nThis design decision was made so as not to confuse users, since then, for example, the edges is not available.\n\nThis behaviour can be customized by calling detect_stateless before calling register_edgetype!.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.set_compression","page":"Configuration","title":"Vahana.set_compression","text":"set_compression(level::Int, parallel_hdf5_compression = false)\n\nSet the compression level of HDF5 files. \n\nHowever, by default, HDF5 datasets are not compressed when the used HDF5 library supports Parallel HDF5 due to encountered issues. While the necessary code to compress datasets in the Parallel HDF5 case is implemented, its activation via the parallelhdf5compression argument is considered experimental and should be used with awareness of potential risks and the specificities of the HDF5 implementation in use.\n\n\n\n\n\n","category":"function"},{"location":"performance.html#Performance-Tuning","page":"Performance Tuning","title":"Performance Tuning","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"This section provides some explanations on how to fine-tune the simulation performance.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"These tips are specific to Vahana. Of course, all the generic performance tips, such as writing type-stable functions, still apply.","category":"page"},{"location":"performance.html#Optional-Assertions","page":"Performance Tuning","title":"Optional Assertions","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Vahana includes some checks on the usage of the Vahana API that can impact runtime performance. For example, in agentstate, there are checks to ensure that the specified agenttype matches the agent's ID. These assertions that could degrade performance can be disabled by calling disable_asserts(false).","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The recommended approach is to enable assertions during the model development phase but disable them when the model \"goes into production\", such as before starting a parameter space exploration.","category":"page"},{"location":"performance.html#Type-Hints","page":"Performance Tuning","title":"Type Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"It is possible to provide Vahana with hints about the types of agents or edges to improve the runtime performance and/or reduce memory requirements. You can use either hint independently or combine them as needed for your specific types.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Aside from the :SingleEdge hint, there is generally no requirement to modify the model code when a type hint is introduced to a type. The interface to Vahana remains consistent, with the restriction that certain functions may be unavailable. For instance, if the :IgnoreFrom hint is specified for an edge type, there is no edgestates method available for this type, as Vahana has not retained the identifiers of neighboring entities and, consequently, cannot retrieve their corresponding states.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"When implementing a model, it is a sensible approach to keep the assertions active and disregard hints. Upon completing the implementation, the next step should be to activated hints and evaluate their impact on performance. Subsequently, after selecting the best hint combination that does not trigger assertions, these can be deactivated as well.","category":"page"},{"location":"performance.html#Agent-Hints","page":"Performance Tuning","title":"Agent Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Vahana supports two hints for agent types: :Immortal and :Independent. When an agent type is marked as :Immortal, it indicates that agents of this type will never be removed from the simulation. By default, Vahana assumes that agents can be removed (by returning nothing in a transition function). The :Immortal hint allows Vahana to skip certain checks and operations related to agent removal, potentially improving performance.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The :Independent hint indicates that agents of this type do not access the state of other agents of the same type during transition functions. This information allows Vahana to optimize memory usage and reduce unnecessary data copying.","category":"page"},{"location":"performance.html#Edge-Hints","page":"Performance Tuning","title":"Edge Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Almost all hints can be combined in any way you prefer. For example, the combination of :IgnoreFrom and :Stateless may seem useless at first because no concrete edge information will be stored when add_edge! is called. However, Vahana still keeps track of the number of edges that have the agent as the target node. This information alone, or combined with the :SingleEdge hint, can often be sufficient. You can refer to the Die or Eat edges in the Predator example for an illustration.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The only combination that is not allowed is :SingleType + :SingleEdge, unless you also set :Stateless and :IgnoreFrom.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Vahana supports five hints for edge types, which can be specified as optional arguments in the register_edgetype! function:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":":IgnoreFrom: Excludes storage of the source node's ID.\n:Stateless: Stores only the source node's ID, omitting any additional state information.\n:SingleType: Indicates that all target nodes are of the same type, while source nodes can vary. This hint requires setting the target keyword (explained below).\n:SingleEdge: Specifies that each agent can be the target of at most one edge of this type. In the case that also the :IgnoreFrom and :Stateless hint are also set, multiple edges to an agent of this type can be created, but the only information available later is that at least one edge exists, as only the has_edge is defined.\n:IgnoreSourceState: Indicates that the source agent's ID is not used to access its state. This hint is particularly relevant for parallel simulations and is explained here.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"These hints can be combined flexibly to suit your model's needs. For instance, combining :IgnoreFrom and :Stateless might seem redundant as it stores no explicit edge information when add_edge! is called. However, Vahana still maintains a count of edges targeting each agent per type. E.g. the Die and Eat edges in the Adding Spatial Information tutorial only needs the information that such an edge exists for an agent. Therefore for both types the :IgnoreFrom, :Stateless and :SingleEdge (or the :HasEdgeOnly) hints could be set.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Most hint combinations are permissible, with one exception: :SingleType and :SingleEdge cannot be used together unless :Stateless and :IgnoreFrom are also specified.","category":"page"},{"location":"performance.html#:SingleType-target-keyword-argument","page":"Performance Tuning","title":":SingleType target keyword argument","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"When the :SingleType hint is set, it is necessary to add the target keyword argument to the register_edgetype! function. The value of this argument should be the type of the target agents.","category":"page"},{"location":"performance.html#Defined-Functions","page":"Performance Tuning","title":"Defined Functions","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The following functions can be used to access the graph within apply!, but their availability depends on the edge type hints:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"function not available for edge type with the hint (combination)\nedges :IgnoreFrom or :Stateless\nneighborids :IgnoreFrom\nneighborstates :IgnoreFrom\nedgestates, mapreduce :Stateless\nnum_edges :SingleEdge\nhas_edge always available","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"As mentioned earlier, the Vahana API differs slightly when the :SingleEdge hint is set. This specifically affects the functions listed here, with the exception of num_edges, has_edges, and mapreduce. Normally, these functions return a vector containing edges, IDs, or states (or nothing). However, when used in combination with the :SingleEdge hint, they return only a single edge, ID, or state (or nothing), as the hint implies that there can be at most one edge of that type.","category":"page"},{"location":"performance.html#Special-Hint-Combinations","page":"Performance Tuning","title":"Special Hint Combinations","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Additionally, there are two property combinations that can be set in register_edgetype! using a single symbol, which directly expresses the intended combination:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":":NumEdgesOnly: This corresponds to the combination of :IgnoreFrom and :Stateless. In this case, only the number of edges is counted, so only calls to num_edges and has_edge are possible.\n:HasEdgeOnly: This corresponds to the combination of :IgnoreFrom, :Stateless, and :SingleEdge. In this case, only calls to has_edge are possible.","category":"page"},{"location":"performance.html#Iterator-Versions-of-Edge-Functions","page":"Performance Tuning","title":"Iterator Versions of Edge Functions","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Vahana offers iterator versions of several functions used to access edge and neighbor information, including neighborids_iter, edgestates_iter, neighborstates_iter, and neighborstates_flexible_iter. ","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The iterator functions work similarly to their non-iterator counterparts but return an iterator instead of a vector. This approach can be more memory-efficient as it doesn't create a full vector in memory. Instead, values are computed on-demand, which can be faster if you don't need to process all elements. They work well with Julia's built-in functions like map, filter, and reduce, allowing for efficient chaining of operations.","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"CurrentModule = Vahana ","category":"page"},{"location":"misc.html#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Here are the remaining exported Vahana definitions that do not fit into any of the previous categories:","category":"page"},{"location":"misc.html#Agents","page":"Misc","title":"Agents","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"ProcessID\nAgentID\nall_agents\nall_agentids\nnum_agents\nadd_agent_per_process!","category":"page"},{"location":"misc.html#Vahana.ProcessID","page":"Misc","title":"Vahana.ProcessID","text":"ProcessID\n\nThe rank on which the agent is currently managed.\n\n\n\n\n\n","category":"type"},{"location":"misc.html#Vahana.AgentID","page":"Misc","title":"Vahana.AgentID","text":" AgentID\n\nThe AgentID is a combination of different (Vahana internal) information about an agent, like e.g. the position where the agent state is stored. It's important to understand that at different times different agents can have the same agent id, therefore those ids can not be used to identify an agent a simulation run. If you need this, you must add an field to the agent state and create an unique value for this field in the agent constructor by yourself.\n\n\n\n\n\n","category":"type"},{"location":"misc.html#Vahana.all_agents","page":"Misc","title":"Vahana.all_agents","text":"all_agents(sim, ::Type{T}, [all_ranks=true])\n\nThis function retrieves a vector of the states for all agents of type T of the simulation sim.\n\nThe all_ranks argument determines whether to include agents from all ranks or just the current rank in parallel simulations. When all_ranks is true, the function returns a vector of all agent identifiers across all ranks.  \n\nThe states and IDs of the agents returned by all_agents and all_agentids are in the same order.\n\ninfo: Info\nall_agents cannot be called within a transition function if the  argument all_ranks is set to true.\n\nSee also all_agentids, add_agents! and num_agents.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.all_agentids","page":"Misc","title":"Vahana.all_agentids","text":"all_agentids(sim, ::Type{T}, [all_ranks=true])\n\nThis function retrieves a vector of the current ids for all agents of type T of the simulation sim. \n\nThese ids are not stable and can change during parallel simulations, e.g. by calling finish_init! (and hopefully in the future through dynamic load balancing).\n\nThe all_ranks argument determines whether to include agents from all ranks or just the current rank in parallel simulations. When all_ranks is true, the function returns a vector of all agent identifiers across all ranks.  \n\nThe states and IDs of the agents returned by all_agents and all_agentids are in the same order.\n\ninfo: Info\nall_agentids cannot be called within a transition function if the  argument all_ranks is set to true.\n\nSee also all_agents, add_agents! and num_agents.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.num_agents","page":"Misc","title":"Vahana.num_agents","text":"num_agents(sim, ::Type{T}, [all_ranks=true])\n\nIf all_ranks is true this function retrieves the number of agents of type T of the simulation sim. When it is set to false, the function will return the number of agents managed by the process.\n\nSee also [add_agents!] and all_agents.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.add_agent_per_process!","page":"Misc","title":"Vahana.add_agent_per_process!","text":"add_agent_per_process!(sim::Simulation, agent::T) where T\n\nAdd a single agent of type T to each process in the simulation. This function is designed to be used after initialization (when the simulation is distributed to the different processes in a parallel run) but outside of transition functions. It allows each process to have its own dedicated agent, useful for tasks like random agent selection or process-specific operations.\n\nThe function takes the simulation and the agent to be added as arguments. It returns the AgentID of the agent created on the current process.\n\nwarning: Warning\nThis function is not designed or optimized for adding many agents. Use it sparingly, typically to create a single agent per process for special purposes. For adding multiple agents, use the standard add_agent! or add_agents! functions within the appropriate simulation phases.\n\nSee also add_agent! and add_agents!.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Edges","page":"Misc","title":"Edges","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"all_edges\nnum_edges(sim, t::Type{T}, sum_ranks = true; write = nothing) where T","category":"page"},{"location":"misc.html#Vahana.all_edges","page":"Misc","title":"Vahana.all_edges","text":"all_edges(sim, ::Type{T}, [all_ranks=true])\n\nThis function retrieves a vector of (AgentID, Edge) tuples for all edges of type T of the simulation sim.\n\nThe AgentID in the tuple is the target of the edge. The specific form of the edge in the tuple depends on the hints for type T.\n\nThe all_ranks argument determines whether to include edges from all ranks or just the current rank in parallel simulations. When all_ranks is true, the function returns a vector of all edges identifiers across all ranks.  \n\nSee also add_edge! and num_edges.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.num_edges-Union{Tuple{T}, Tuple{Any, Type{T}}, Tuple{Any, Type{T}, Any}} where T","page":"Misc","title":"Vahana.num_edges","text":"num_edges(sim, ::Type{T}, [sum_ranks=true])\n\nIf all_ranks is true this function retrieves the number of edges of type T of the simulation sim. When it is set to false, the function will only return the number of edges of type T managed by the process.\n\n\n\n\n\n","category":"method"},{"location":"misc.html#REPL","page":"Misc","title":"REPL","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Vahana has some features that support model development via Julia's interactive command line REPL. In this case, the simulation is not parallelized, but the same code runs later via parallelization without requiring any (or minimal) changes.","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Beside the pretty-printing of a simulation as shown in the tutorial(s), there are also additional functions that allows to investigate the current state of a simulation:","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"show_agent\nDataFrames.DataFrame(sim::Simulation, T::DataType)","category":"page"},{"location":"misc.html#Vahana.show_agent","page":"Misc","title":"Vahana.show_agent","text":"show_agent(sim, Type{T}, [id=0; max=5, neighborstate = []]) \nshow_agent(sim, id=0; [max=5, neighborstate = []])\n\nDisplay detailed information about the agent with ID id, or in the case that id is a value < 2^36, the information of the nth agent of type T. If id is 0 (the default value), a random agent of type T is selected.\n\nReturns the ID of the agent (which is especially useful when a random agent is selected).\n\nKeyword arguments:\n\nmax controls the maximal number of edges that are shown per network (per direction).\n\nIf a field of an agent on the source side of an edge is listed in the neighborstate vector, the value of this field will be also shown.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#DataFrames.DataFrame-Tuple{Vahana.Simulation, DataType}","page":"Misc","title":"DataFrames.DataFrame","text":"DataFrame(sim::Simulation, T::DataType; types = false, localnr = false)\n\nCreates a DataFrame with the current state of agents or edges of type T.  By default, the ID columns show the complete AgentID. for readability (and the use of show_agent) it may be useful to show only the lowest 36 bits, which gives a much more readable value, by setting the localnr argument to true. Since for edges the type information of the source and target agents is no longer available in this case, the types argument can be used to create additional columns containing the types of these agents.\n\ninfo: Info\nDataFrame is only available when the DataFrame.jl package is imported by the model implementation. \n\nwarning: Warning\nIn parallel simulations, the DataFrame method converts only the local graph partition (agents or edges) residing on the current MPI rank. It does not provide a global view of the entire distributed graph. To obtain a complete list of all agent states across all ranks, use the all_agents function. Similarly, for edges, use the all_edges function to get a global view of all edges in the distributed graph.\n\n\n\n\n\n","category":"method"},{"location":"misc.html","page":"Misc","title":"Misc","text":"apply can be used to calculate a transition function without modifying the original state. This can be useful in the development process, but for the final simulation the function should be replaced with the modifying version apply!.","category":"page"},{"location":"misc.html#Simulation","page":"Misc","title":"Simulation","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"copy_simulation\nfinish_simulation!","category":"page"},{"location":"misc.html#Vahana.copy_simulation","page":"Misc","title":"Vahana.copy_simulation","text":"copy_simulation(sim)\n\nCreate an independent copy of the simulation sim. Since part of the memory is allocated via MPI, you should not use deepcopy. \n\nAlso, the copy is detached from any output or logger file so that not sim and copy tried to write to the same file(s). If these are needed, you can create these files for the copy by calling create_h5file! and/or create_logger! and assigning the results to the h5file/logging field of the returned simulation.\n\nReturns the copy of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.finish_simulation!","page":"Misc","title":"Vahana.finish_simulation!","text":"finish_simulation!(sim)\n\nRemove all agents/edges and rasters from the simulation to minimize the memory footprint. The parameters and globals of the simulation are still available, the remaining state of the simulation is undefined.\n\nThe function serves as a finalizer for the simulation object ('sim'). While it executes automatically during garbage collection, it can also be called explicitly to provide more precise control over memory management (e.g. if you only want to keep the globals as the result from the simulation).  \n\nReturns the globals of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"parallel.html#Parallel-simulations","page":"Parallel Simulations","title":"Parallel simulations","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Vahana supports parallel simulations using MPI (Message Passing Interface), allowing for significant performance improvements when running large-scale models. To run a Vahana simulation in parallel, you can use the mpirun or mpiexec command, specifying the number of processes with the -np parameter. For example:","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"mpirun -np 4 julia your_model.jl","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"The -np parameter indicates the number of processes/threads to be used for the simulation.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"This approach works without any additional changes in the model code. However, there are ways to further optimize performance in a parallel simulation:","category":"page"},{"location":"parallel.html#MPI.jl-Integration","page":"Parallel Simulations","title":"MPI.jl Integration","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Vahana utilizes the MPI.jl package for its parallel computing capabilities. While no specific MPI knowledge is required to use Vahana's parallel features, users may find it beneficial to review the Configuration section of the MPI.jl documentation for a deeper understanding of the underlying parallel computing framework.  For advanced users or specific scenarios, it's possible to work directly with MPI.jl functions within your Vahana model. When using Vahana in parallel mode, MPI is automatically initialized, and the following MPI-related variables are available:","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"mpi.comm: The MPI communicator object.\nmpi.rank: An integer identifying the current process (0-based).\nmpi.size: The total number of processes in the parallel computation.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Remember that while direct use of MPI functions can provide additional flexibility, it also requires careful handling to maintain consistency across all processes and avoid potential race conditions or deadlocks.","category":"page"},{"location":"parallel.html#Partitioning","page":"Parallel Simulations","title":"Partitioning","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"The simulation graph is partitioned and distributed in the finish_init! call. By default, the Metis.jl package is used for this. However, during this process, the information about the different agent types is lost. As a result, if multiple agent types are used, it is possible that the number of agents is unevenly distributed for a single agent type.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"To address this issue, an alternative partitioning scheme, :EqualAgentNumbers, is available. However, this scheme ignores the edges and number of cuts in the graph.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"In order to optimize the partitioning for your specific model, it can be very useful to perform your own partitioning and pass it to finish_init!. An example of this can be seen in the create_partition function of the Vahana Episim Example.","category":"page"},{"location":"parallel.html#Using-@rootonly","page":"Parallel Simulations","title":"Using @rootonly","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"It's helpful to understand that in MPI programs, all processes execute the same program code, but operate on different data. In a typical Vahana program, up to the finish_init! call, all processes runs the same code that creates the initial graph and therefore, if there are n processes, the complete graph is generated n times. However, at the finish_init! step, only the graph from process 0 (the root process) is considered, and the graphs constructed on all other processes are discarded.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Although this is not necessarily problematic, it can be beneficial to construct the graph only on the root processes, especially if files are being read during the initialization phase.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"To execute instructions only on the root process, you can use the @rootonly macro. For example, the Vahana Episim example includes the following code before the finish_init! call:","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"    @rootonly begin\n        worldid = add_agent!(sim, World())\n        healthauthid = add_agent!(sim, HealthAuthority(0, 0, 0))\n        @info \"read persons\"\n        persons = read_persons!(config.synpop_file)\n        @info \"read events\"\n        read_events!(sim, config.events_all, persons, worldid, healthauthid)\n        @info \"finish init\"\n    end","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Alternatively you could also check the mpi.isroot predicate.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"It is important that finish_init! is called by all processes and not only by the root process, and also some other functions like e.g. write_snapshot must be called collectively from all processes.","category":"page"},{"location":"parallel.html#Write-a-snapshot-after-finish_init!","page":"Parallel Simulations","title":"Write a snapshot after finish_init!","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"If creating the initial state takes time and the process is deterministic, it is a good idea to save the state after finish_init! with write_snapshot and read this snapshot with read_snapshot! instead of recreating the graph each time. ","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"If the process of generating the initial state is time-consuming, it is advisable to save the state after the finish_init! function completes. This can be achieved by calling the write_snapshot function. Subsequently, instead of recreating the initial graph for each simulation, you can read this snapshot using the read_snapshot! function instead.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"The Vahana Episim example serves as a demonstration of how to implement this approach effectively.","category":"page"},{"location":"parallel.html#The-:IgnoreSourceState-hint","page":"Parallel Simulations","title":"The :IgnoreSourceState hint","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"This hint requires additional explanation about what happens internally when apply! is called.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"In a parallel simulation, at the beginning of apply!, it is checked whether the transition function needs to read the state of an agent type that may have changed since the last state read. If this is the case, it checks all accessible edges (specified in the read argument of apply!) and transmits the state of agents that can be accessed (i.e., the agent type must also be included in the read argument) to the corresponding process. However, there are cases where it is clear that only the IDs of the agents will be accessed via a specific edge type, and not the agent state itself. To avoid the overhead of transmitting state between agents that will never be read, the :IgnoreSourceState hint can be used for those edge types.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"This hint only affects parallel simulations, as there is nothing to transmit in a serial simulation.","category":"page"},{"location":"parallel.html#Avoid-agentstate-calls","page":"Parallel Simulations","title":"Avoid agentstate calls","text":"","category":"section"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"Instead of using agentstate to access the state of an agent, sometimes it is possible for an agent to actively send the required state associated with an edge to another agent that needs that information. This can significantly improve performance, especially when combined with the :IgnoreSourceState hint if necessary.","category":"page"},{"location":"parallel.html","page":"Parallel Simulations","title":"Parallel Simulations","text":"For example, in a Game of Life implementation, active cells can generate an edge to their neighbors if the cell is active. If this edge has the :NumEdgesOnly hint, it will directly trigger the counting process of the neighbors without the need to transfer the full state to other agents/processes.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"CurrentModule = Vahana","category":"page"},{"location":"definition.html#Model-Definition","page":"Model Definition","title":"Model Definition","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"This page describes the functions and data structures employed to define the model and to instantiate an uninitialized simulation. In Vahana the simulation state and the transition functions that changes the state are decoupled, eliminating the need to define the transition functions prior to creating the simulation instance.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"The usual workflow is as follows:","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Define the Agent and Edge types\nCreate a ModelTypes instance\nRegister the Agent and Edge types and optionally the Parameters and Globals\nCall create_model to create an model (state space) object\nCall create_simulation to create an uninitialized simulation of this model","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"The simplest example for such a workflow is:","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"struct Agent end\nstruct EdgeState end\n\nconst sim = ModelTypes() |>\n    register_agenttype!(Agent) |>\n    register_edgetype!(EdgeState) |>\n    create_model(\"Minimal Example\") |>\n    create_simulation()","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"After the simulation is created, the next step is its initialization, which is described on the next page.","category":"page"},{"location":"definition.html#Construct-the-Model","page":"Model Definition","title":"Construct the Model","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Before we can construct a model, we need to register all agent and edge types. ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"ModelTypes\nregister_agenttype!\nregister_edgetype!","category":"page"},{"location":"definition.html#Vahana.ModelTypes","page":"Model Definition","title":"Vahana.ModelTypes","text":"ModelTypes\n\nThis struct stores all (internal) information about the agent and edge types of the model and is therefore the starting point of the model definition. \n\nCall the ModelType constructor without parameters, and then use the created object as the first parameter in register_agenttype! and register_edgetype!, whereby the |> operator can be used to concatenate these registrations.\n\nSee also create_model,\n\n\n\n\n\n","category":"type"},{"location":"definition.html#Vahana.register_agenttype!","page":"Model Definition","title":"Vahana.register_agenttype!","text":"register_agenttype!(types::ModelTypes, ::Type{T}, [hints...])\n\nRegister an additional agent type to types. \n\nAn agent type is a struct that define the state space for agents of type T. These structs must be \"bits types\", meaning the type is immutable and contains only primitive types and other bits types.\n\nBy default, it is assumed that an agent can die (be removed from the simulation) by returning nothing in the transition function (see apply!. In the case that agents are never removed, the hint :Immortal can be given to improve the performance of the simulation.\n\nIf agents of this type never access the state of other agents of the same type in a transition function (e.g., via agentstate or neighborstates calls), then the :Independent hint can be given. This avoids unnecessary copies of the agents.\n\nA pipeable version of register_agenttype! is also available, enabling the construction of a Model via a sequence of register_* calls. This pipeline starts with ModelTypes() as the source and terminates in the create_model function as the destination.\n\nSee also add_agent! and add_agents! \n\n\n\n\n\n","category":"function"},{"location":"definition.html#Vahana.register_edgetype!","page":"Model Definition","title":"Vahana.register_edgetype!","text":"register_edgetype!(types::ModelTypes, ::Type{T}, [hints...; kwargs...])\n\nRegister an additional edge type to types. \n\nAn edge type T is a structure that defines the state (field) of Edge{T}.  These structs must be \"bit types\", that is, the type is immutable and contains only primitive types and other bit types. Often these types T are stateless, in which case they are used as a tag to distinguish between the existing types of edges of the model.\n\nThe internal data structures used to store the graph in memory can be modified by  the hints parameters:\n\n:IgnoreFrom: The ID of the source agent is not stored. This implies that the state of the agents on the source of the edge is not accessible via e.g. the neighborstates function.\n:Stateless: Store only the ID of the source agent. \n:SingleType: All target agents have the same type, needs also keyword target (see below).\n:SingleEdge: Each agent can be the target for max. one edge.\n:IgnoreSourceState: The ID of the source agent is not used to access the state of the agent with this ID.\n:NumEdgesOnly: Combines :IgnoreFrom and :Stateless\n:HasEdgeOnly: Combines :IgnoreFrom, :Stateless and :SingleEdge\n\nIf :SingleType is set, the keyword argument target must be added. The value of this argument must be the type of the target node. If the target keyword exists, but the :SingleType hint is not explicitly specified, it will be set implicitly\n\nIf it is known how many agents of this type exist, this can also be specified via the optional size keyword. This can improve performance, but can also increase the memory usage.\n\nA pipeable version of register_edgetype! is also available, enabling the construction of a Model via a sequence of register_* calls. This pipeline starts with ModelTypes() as the source and terminates in the create_model function as the destination.\n\nSee also Edge Hints, add_edge! and  add_edges! \n\n\n\n\n\n","category":"function"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"We can then use the ModelTypes instance to construct the model. Which means that optimized methods that can be used to access or modify the simulation state during the transition function are generated. See Performance Tuning for details.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"The ModelTypes instance can subsequently be utilized to construct the model. This involves that optimized methods are generated, enabling access or modification of the simulation state during the execution of the transition function. For comprehensive details regarding this process, please refer to the Performance Tuning documentation.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"tip: Tip\nAs create_model adds new methods, it increments the \"world age counter\". This means, that you can not construct the model in the same function as you initialize it. But you can call create_simulation in the same function soconst model = create_model(modeltypes, \"Minimal Example\") \n\nfunction create_and_init()\n\tsim = create_simulation(model, nothing, nothing)\n\tadd_agent!(sim, Agent())\nendis valid code. ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"create_model\nModel","category":"page"},{"location":"definition.html#Vahana.create_model","page":"Model Definition","title":"Vahana.create_model","text":"create_model(types::ModelTypes, name::String)\n\nCreates a struct that is a subtype of the Simulation type and methods corresponding to the type information of types to the Julia session. The new structure is named name, and all methods are specific to this structure using Julia's multiple dispatch concept, so it is possible to have different models in the same Julia session (as long as name is different).\n\nReturns a Model that can be used in create_simulation to create a concrete simulation.  \n\n\n\n\n\n","category":"function"},{"location":"definition.html#Vahana.Model","page":"Model Definition","title":"Vahana.Model","text":"Model\n\nA Model instance is created by create_model and can then be used to create one or multiple simulations via create_simulation.\n\n\n\n\n\n","category":"type"},{"location":"definition.html#Register-Parameters-and-Globals","page":"Model Definition","title":"Register Parameters and Globals","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Parameters are constant values used throughout the simulation, while globals are variables that can change during the simulation run. You can register them using register_param! and register_global!, or by defining custom types and pass instances of this types to create_simulation.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"register_param!\nregister_global!","category":"page"},{"location":"definition.html#Vahana.register_param!","page":"Model Definition","title":"Vahana.register_param!","text":"register_param!(types::ModelTypes, name::Symbol, default_value::T)\n\nThere are two ways to set up parameters for a simulation. Either the instance of a struct defined by the modeler must be passed via the param argument to create_simulation, or the individual parameters are passed using register_param! before create_model is called. The parameters can also be set after create_simulation and before finish_init! is called.\n\nA pipeable version of register_param! is also available, enabling the construction of a Model via a sequence of register_* calls. This pipeline starts with ModelTypes() as the source and terminates in the create_model function as the destination.\n\n\n\n\n\n","category":"function"},{"location":"definition.html#Vahana.register_global!","page":"Model Definition","title":"Vahana.register_global!","text":"register_global!(types::ModelTypes, name::Symbol, default_value::T)\n\nThere are two ways to set up globals for a simulation. Either the instance of a struct defined by the modeler must be passed via the globals argument to create_simulation, or the individual parameters are passed using register_global! before create_model is called. \n\nA pipeable version of register_global! is also available, enabling the construction of a Model via a sequence of register_* calls. This pipeline starts with ModelTypes() as the source and terminates in the create_model function as the destination.\n\n\n\n\n\n","category":"function"},{"location":"definition.html#Create-a-Simulation","page":"Model Definition","title":"Create a Simulation","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Finally, create an uninitialized simulation based on your model using ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"create_simulation","category":"page"},{"location":"definition.html#Vahana.create_simulation","page":"Model Definition","title":"Vahana.create_simulation","text":"create_simulation(model::Model, [params = nothing, globals = nothing; name = model.name, filename = name, overwrite_file = true, logging = false, debug = false])\n\nCreates and return a new simulation object, which stores the complete state  of a simulation. \n\nmodel is an Model instance created by create_model.\n\nparams must be a struct (or nothing) that contains all parameters of a simulation. Parameter values are constant in a simulation run and can be retrieved via the param function.\n\nglobals must be a mutable struct (or nothing). The values of these fields are accessible for all agents via the get_global function. The values can be changed by calling set_global! or push_global!. \n\nThe optional keyword argument name is used as meta-information about the simulation and has no effect on the dynamics, since name is not accessible in the transition functions. If name is not given, the name of the model is used instead.\n\nThe optional filename keyword is a string that will be used as the name of the hdf5 file when a simulation or a part of it is written via e.g. write_snapshot. \n\nThe file is created when a write... function is called for the first time, and it is created in an h5 subfolder. By default an existing file with the same filename will be overwritten, but this behavior can be disabled with the overwrite_file keyword, in which case the files will be numbered. If filename is not provided, the name argument is used instead.\n\nThe keywords logging is a boolean flag that enables an automatical log file.  The log file contains information such as the time spent in different functions. When also debug is set to true, the log file contains more details and the stream will be flushed after each write.\n\nAs with the hdf5 files, overwrite_file the keyword determines whether the log files are overwritten or numbered. The numbering is set independently from the numbering of the hdf5 files.\n\nThe simulation starts in an uninitialized state. After adding the agents and edges for the initial state, it is necessary to call finish_init! before applying a transition function for the first time.\n\nSee also create_model, param, get_global, set_global!, push_global! and finish_init!\n\n\n\n\n\n","category":"function"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"This creates a blank simulation ready for initialization.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Remember, in Vahana, a \"model\" specifies the possible state space, while a simulation is a concrete realization within this space. Transition functions, defined later, determine how the simulation evolves over time.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"By following these steps, you set up the structure of your simulation. The next phase involves initializing the simulation with agents and edges.","category":"page"},{"location":"logging.html","page":"Logging","title":"Logging","text":"CurrentModule = Vahana","category":"page"},{"location":"logging.html#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"logging.html","page":"Logging","title":"Logging","text":"Vahana utilize Julia's Standard Logging Library to optionally create log files with e.g. the duration of the transition functions. For each process a seperate file is created.","category":"page"},{"location":"logging.html","page":"Logging","title":"Logging","text":"set_log_path\ncreate_logger!\nwith_logger\nlog_overview","category":"page"},{"location":"logging.html#Vahana.set_log_path","page":"Logging","title":"Vahana.set_log_path","text":"set_log_path(path::String)\n\nSpecify the path that is used to save the log files. If the directory does not exist, it is created the first time a log file is written.\n\nMust be called before create_simulation. If this is not done, the log files are written to a subfolder log of the current working directory.\n\n\n\n\n\n","category":"function"},{"location":"logging.html#Vahana.create_logger!","page":"Logging","title":"Vahana.create_logger!","text":"create_logger!(sim::Simulation, [debug = false, name = sim.name; overwrite = sim.overwrite_file])\n\nThe canonical way to create log files for a simulation is by setting the logging keyword of create_simulation to true. But sometime it can be useful to control this manually, e.g. after a call to copy_simulation.\n\nWhen also debug is set to true, the log file contains more details and the stream will be flushed after each write.\n\nThe filename argument can be used to specify a filename other than sim.filename. If overwrite is true, existing files with this name will be overwritten. If it is false, the filename is automatically extended by an increasing 6-digit number, so that existing files are not overwritten.\n\nThe files are always created in a log subfolder, and this one will be create in the current working directory.\n\n\n\n\n\n","category":"function"},{"location":"logging.html#Logging.with_logger","page":"Logging","title":"Logging.with_logger","text":"with_logger(f::Function, sim::Simulation)\n\nExecute function f, directing all log messages to the logger that is attached to simulation sim.\n\n\n\n\n\n","category":"function"},{"location":"logging.html#Vahana.log_overview","page":"Logging","title":"Vahana.log_overview","text":"log_overview(sim::Simulation)\n\nDump an overview of the simulation sim to the attached logfile.\n\n\n\n\n\n","category":"function"},{"location":"plots.html","page":"Plots","title":"Plots","text":"CurrentModule = Vahana","category":"page"},{"location":"plots.html#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"Visualization is not the main focus of Vahana, but two rudimentary auxiliary functions exist for creating plots with Makie.","category":"page"},{"location":"plots.html","page":"Plots","title":"Plots","text":"plot_globals\ncreate_graphplot","category":"page"},{"location":"plots.html#Vahana.plot_globals","page":"Plots","title":"Vahana.plot_globals","text":"plot_globals(sim, names::Vector{Symbol})\n\nCreates a Makie lineplot with one line for each global in names, wherby those global values must be Vectors (or Iterable).\n\nReturns figure, axis, plots. plots is a vector of Plots, which one plot for element of names.\n\ninfo: Info\nplot_globals is only available when a Makie backend is imported by the client.\n\nSee also push_global!, get_global\n\n\n\n\n\n","category":"function"},{"location":"plots.html#Vahana.create_graphplot","page":"Plots","title":"Vahana.create_graphplot","text":"create_graphplot(sim; [agenttypes, edgestatetypes, update_fn, pos_jitter])\n\nCreates an interactive Makie plot for the the simulation sim.\n\nThe graph can be restricted to a subgraph with the given agentypes and edgestatetypes, see vahanagraph for details.\n\nTo modify the properties of the edges and agents a update_fn can be defined. This function is called for each agent and edge (of types in agenttypes and edgestatetypes) and must have for agents the signature\n\nf(state, id, vp::VahanaPlot)\n\nand for edges\n\nf(state, source, target, vp::VahanaPlot)\n\nThe arguments of this functions are state for the agent or edgestate, ID for the id of the agent called, from and to for the ID of the agents at the source or target of the edge. vp is the struct returned by create_graphplot and can be used to determine the id of last clicked agent by calling clicked_agent(vp). The function must return a Dict with property names (as Symbol) as keys and their values as values. The following properties are available: node_color, node_size, node_marker, nlabels, nlabels_align, nlabels_color, nlabels_distance, nlabels_offset, nlabels_textsize, edge_color, edge_width, elables, elables_align, elables_color, elables_distance, elables_offset, elables_rotation, elables_shift, elables_side, elabes_textsize, arrow_shift, and arrow_size.\n\nReturns a VahanaPlot structure that can be used to access the Makie figure, axis and plot via call to the methods figure, axis and plot with this struct as (single) argument.\n\ninfo: Info\ncreate_graphplot is only available when the GraphMakie package and a Makie backend is imported by the client.\n\nwarning: Warning\nFor the mouse click and hover interaction, the current state of the simulation used to construct the VahanaGraph is accessed. In the case that a transition function is called after the construction of the VahanaGraph, and this transition function modifies the structure of the Graph (add/removes nodes or edges), then this changes are not reflected by the current implementation and can cause errors.\n\nSee also vahanagraph\n\n\n\n\n\n","category":"function"},{"location":"raster.html","page":"Raster","title":"Raster","text":"CurrentModule = Vahana","category":"page"},{"location":"raster.html#Raster","page":"Raster","title":"Raster","text":"","category":"section"},{"location":"raster.html","page":"Raster","title":"Raster","text":"Spatial information can be added to the simulation in the form of one or more n-dimensional rasters. ","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"add_raster!","category":"page"},{"location":"raster.html#Vahana.add_raster!","page":"Raster","title":"Vahana.add_raster!","text":"add_raster!(sim, name::Symbol, dims::NTuple{N, Int}, agent_constructor)\n\nAdds a n-dimensional grid to sim, with the dimensions dims.\n\nFor each cell a new node/agent is added to the graph. To create the agent, the agent_constructor function is called, with the cell position in form of an CartesianIndex as argument.\n\nThe symbol name is an identifier for the created raster, as it is allowed to add multiple rasters to sim. \n\nThe types of the agents created by the agent_constructor must be already registered via register_agenttype!.\n\nReturns a vector with the IDs of the created agents.\n\nCan be only called before finish_init!.\n\nSee also calc_raster connect_raster_neighbors! and move_to!.\n\n\n\n\n\n","category":"function"},{"location":"raster.html","page":"Raster","title":"Raster","text":"Those rasters are implemented as part of the graph structure, with each cell represented as a node, so the cell types must be registered like the types of agents via register_agenttype!.","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"To create edges between the cells, or between the cells and agents of other types via the following two helper functions.","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"connect_raster_neighbors!\nmove_to!","category":"page"},{"location":"raster.html#Vahana.connect_raster_neighbors!","page":"Raster","title":"Vahana.connect_raster_neighbors!","text":"connect_raster_neighbors!(sim, name::Symbol, edge_constructor; [distance::Int, metric:: Symbol, periodic::Bool])\n\nAll cells that are at most distance from each other (using the metric metric) are connected with edges, where the edges are created with the edge_constructor.\n\nThe edge_constructor must be a function with one argument with type Tuple{CartesianIndex, CartesianIndex}. The first CartesianIndex is the position of the source node, and the second CartesianIndex the position of the target node.\n\nValid metrics are :chebyshev, :euclidean and :manhatten.\n\nThe keyword periodic determines whether all dimensions are cyclic (e.g., in the two-dimensional case, the raster is a torus).\n\nThe default values of the optional keyword arguments are 1 for distance, :chebyshev for metric and true for periodic. which is equivalent to a Moore neighborhood. The :manhatten metric can be used to connect cells in the von Neumann neighborhood.\n\nThe agent types of agents created by the agent_constructor must be already registered via register_agenttype!.\n\nSee also add_raster!\n\n\n\n\n\n","category":"function"},{"location":"raster.html#Vahana.move_to!","page":"Raster","title":"Vahana.move_to!","text":"move_to!(sim, name::Symbol, id::AgentID, pos, edge_from_raster, edge_to_raster; [distance = 0, metric = :chebyshev, periodic = true])\n\nCreates up to two edges of type between the agent with ID id and the cell from the raster name at the position pos.\n\npos must be of type CartesianIndex or a Dims{N}. \n\nedge_from_raster is the edge that will be added with the cell as source node and the agent as target node. edge_from_raster can be nothing, in this case no edge will be added with the agent as target node.\n\nedge_to_raster is the edge that will be added with the agent as source node and the cell as target node. edge_to_raster can be nothing, in this case no edge will be added with the agent as source node.\n\nUsing the keyword arguments, it is possible to add additional edges to the surroundings of the cell at position pos in the same raster, i.e. to all cells at distance distance under metric metric, where valid metrics are :chebyshev, :euclidean and :manhatten. And the keyword periodic determines whether all dimensions are cyclic.\n\nWhen the only_surrounding keyword is set to true, only edges to the surroundings cells of pos will be created, not to the cell at position pos itself.\n\nSee also add_raster! and connect_raster_neighbors! \n\n\n\n\n\n","category":"function"},{"location":"raster.html","page":"Raster","title":"Raster","text":"The id of a cell for a given position can be archived via cellid","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"cellid","category":"page"},{"location":"raster.html#Vahana.cellid","page":"Raster","title":"Vahana.cellid","text":"cellid(sim, name::Symbol, pos)\n\nReturns the ID of the agent (node) from the raster name at the position pos. pos must be of type CartesianIndex or a Dims{N}.\n\nSee also add_raster!, move_to!, add_edge! and agentstate\n\n\n\n\n\n","category":"function"},{"location":"raster.html","page":"Raster","title":"Raster","text":"cellid id or position of a random cell can be drawn via:","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"random_pos\nrandom_cell","category":"page"},{"location":"raster.html#Vahana.random_pos","page":"Raster","title":"Vahana.random_pos","text":"random_pos(sim, raster::Symbol, weights::Matrix)\n\nReturn a CartesianIndex with random position coordinates, weighted by a probability matrix weights.\n\nThe likelihood of selecting a particular cell/index is proportional to its corresponding value in the weights matrix.\n\nSee also random_pos(sim, raster) and random_cell\n\n\n\n\n\nrandom_pos(sim, raster::Symbol)\n\nReturn a CartesianIndex with random position coordinates.\n\nThe returned index is sampled from the rasters indizies where each index has the same probability.\n\nSee also random_pos(sim, raster, weights) and random_cell\n\n\n\n\n\n","category":"function"},{"location":"raster.html#Vahana.random_cell","page":"Raster","title":"Vahana.random_cell","text":"random_cell(sim, raster::Symbol)\n\nReturn a random cell id of the raster raster from the simulation sim.\n\n\n\n\n\nrandom_cell(sim, raster::Symbol, weights::Array)\n\nReturn a random cell id of the raster raster from the simulation sim. The likelihood of selecting a particular cell is proportional to its corresponding value in the weights matrix.\n\nSee also random_cell(sim, raster) and random_pos\n\n\n\n\n\n","category":"function"},{"location":"raster.html","page":"Raster","title":"Raster","text":"Such a raster is only a collection of nodes in the graph incl. an Vahana internal mapping from the cartesian coordinates to the cell IDs. Beside this mapping, cells are also just agents, but there are some Vahana functions that utilize the internal cartesian coordinates to create a n-dimensional representation of the state space.","category":"page"},{"location":"raster.html","page":"Raster","title":"Raster","text":"calc_raster\ncalc_rasterstate\nrastervalues","category":"page"},{"location":"raster.html#Vahana.calc_raster","page":"Raster","title":"Vahana.calc_raster","text":"calc_raster(sim, raster::Symbol, f, f_returns::DataType, accessible::Vector{DataType})\n\nCalculate values for the raster raster by applying f to each cell ID of the cells constructed by the add_raster! function.\n\nf_returns must be the type returned by the function f. There must be an implementation of the zero function for this type, and zero(returntype) | f(id) must be equal to f(id).\n\naccessible is a vector of Agent and/or Edge types. This vector must list all types that are accessed directly (e.g. via agentstate or indirectly (e.g. via neighborstates in the transition function.\n\nIf the results of calc_raster depend only on the state of the cells (as in the following example) and all cells have the same type, calc_rasterstate can be used as concise alternatives.\n\nReturns a n-dimensional array (with the same dimensions as raster) with those values.\n\nExample:\n\nThe following code from a \"Game of Life\" implementation generates a boolean matrix indicating which cells are alive (and therefore maps the internal graph structure to the usual representation of a cellular automaton):\n\n    calc_raster(sim, :raster, id -> agentstate(sim, id, Cell).active, Bool, [ Cell ]) \n\nCan be only called after finish_init!.\n\nSee also add_raster! and calc_rasterstate\n\n\n\n\n\n","category":"function"},{"location":"raster.html#Vahana.calc_rasterstate","page":"Raster","title":"Vahana.calc_rasterstate","text":"calc_rasterstate(sim, raster::Symbol, f, f_returns::DataType = Nothing, ::Type{T} = Nothing)\n\nCombined calc_raster with agentstate for the cells of the raster.\n\nCalculate values for the raster raster by applying f to the state of each cell.\n\nf_returns must be the type returned by the function f. There must be an implementation of the zero function for this type, and zero(returntype) + f(state) must be equal to f(state). In the event that all cells in the raster returns the same DataType, f_returns can be set to Nothing, in which case f_returns is automatically derived.\n\nT can be set to Nothing, this decreases the performance, but is necessary in the unusual case that a raster contains different types of agents (in this case agentstate_flexible is used instead of agentstate).\n\nReturns a n-dimensional array (with the same dimensions as raster) with those values.\n\nExample:\n\nInstead of\n\n    calc_raster(sim, :raster, id -> agentstate(sim, id, Cell).active, Bool, [ Cell ]) \n\nit also possible to just write\n\n    calc_rasterstate(sim, :raster, c -> c.active, Bool, Cell)\n\nCan be only called after finish_init!.\n\nSee also add_raster!, calc_rasterstate and rastervalues\n\n\n\n\n\n","category":"function"},{"location":"raster.html#Vahana.rastervalues","page":"Raster","title":"Vahana.rastervalues","text":"rastervalues(sim, raster::Symbol, fieldname::Symbol)\n\nCreates a matrix with the same dims as the raster raster with the values of the field fieldnames. All cells of the raster must have  the same type, and also a zeros function must exist for the type of fieldnames.\n\nExample:\n\nInstead of\n\n    calc_rasterstate(sim, :raster, c -> c.active, Bool, Cell)\n\nit also possible to just write\n\n    rastervalues(sim, :raster, :active) \n\nCan be only called after finish_init!.\n\nSee also add_raster! and calc_rasterstate\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"CurrentModule = Vahana","category":"page"},{"location":"initialization.html#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"After we created a simulation by calling create_simulation, we must build the initial state of the simulation. As in Vahana the state of a model is represented as a graph, this means we must add the nodes (our agents) and edges to the graph.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"add_agent!\nadd_agents!","category":"page"},{"location":"initialization.html#Vahana.add_agent!","page":"Initialization","title":"Vahana.add_agent!","text":"add_agent!(sim, agent::T)::AgentID\n\nAdd a single agent of type T to the simulation sim.\n\nT must have been previously registered by calling register_agenttype!.\n\nadd_agent! returns a new AgentID, which can be used to create edges from or to this agent until finish_init! is called (in the case that add_agent! is called in the initialization phase), or until the transition funcion is finished (in the case that add_agent! is called in an apply! callback). Do not use the ID for other purposes, they are not guaranteed to be stable.\n\nSee also add_agents!, add_edge! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.add_agents!","page":"Initialization","title":"Vahana.add_agents!","text":"add_agents!(sim, agents)::Vector{AgentID}\n\nAdd multiple agents at once to the simulation sim.\n\nagents can be any iterable set of agents, or an arbitrary number of agents as arguments. \n\nThe types of the agents must have been previously registered by calling register_agenttype!.\n\nadd_agents! returns a vector of AgentIDs, which can be used to create edges from or to this agents before finish_init! is called (in the case that add_agents! is called in the initialization phase), or before the transition funcion is finished (in the case that add_agents!  is called in an apply! callback). Do not use the ID for other purposes, they are not guaranteed to be stable.\n\nSee also add_agent!, register_agenttype!, add_edge! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"warning: Warning\nThe IDs created by add_agent(s)! contain Vahana internal information, that can change after an apply! or the finish_init! call. It is even possible that  different agents have the same ID at different times. This has the implication, that  the IDs can only be used temporary and should not be stored in the state of an agent or edge.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"Edge\n\nadd_edge!\nadd_edges!","category":"page"},{"location":"initialization.html#Vahana.Edge","page":"Initialization","title":"Vahana.Edge","text":"struct Edge{T} \n    from::AgentID\n    state::T\nend\n\nAn edge between to agents with (optionally) additional state. T can be also a struct without any field.\n\nThe AgentID of the agent at the target of the edge is not a field of Edge itself, since this information is already part of the containers in which the edges are stored.\n\nSee also register_edgetype!\n\n\n\n\n\n","category":"type"},{"location":"initialization.html#Vahana.add_edge!","page":"Initialization","title":"Vahana.add_edge!","text":"add_edge!(sim, to::AgentID, edge::Edge{T})\n\nAdd a single edge to the simulation sim. The edges is directed from the agent with ID edge.from (the source) to the agent with ID to (the target).\n\nadd_edge!(sim, from::AgentID, to::AgentID, state::T)\n\nAdd a single edge to the simulation sim. The edge is directed from the agent with ID from (the source) to the agent with ID to (the target) and has the state state.\n\nT must have been previously registered in the simulation by calling register_edgetype!.\n\nSee also Edge register_edgetype! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.add_edges!","page":"Initialization","title":"Vahana.add_edges!","text":"add_edges!(sim, to::AgentID, edges)\n\nAdd multiple edges at once to the simulation sim, with all edges are directed to to.\n\nedges can be any iterable set of agents, or an arbitrary number of edges as arguments. \n\nSee also Edge register_edgetype! and add_edge!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Graphs","page":"Initialization","title":"Graphs","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"It is also possible to use graph generators from the Graphs.jl package to construct the initial state. Or parts of it, since you can combine it with all the other functions described on this page. Since Graphs.jl has overlapping function names with Vahana, it is advisable to import only the SimpleGraphs module from Graphs.jl.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"add_graph!","category":"page"},{"location":"initialization.html#Vahana.add_graph!","page":"Initialization","title":"Vahana.add_graph!","text":"add_graph!(sim::Simulation, graph, agent_constructor, edge_constructor) -> Vector{AgentID}\n\nAdds a graph from the Graphs.jl package to sim, incl. all vertices of graph as new agents.\n\ngraph must be a Graphs.Graph or a Graphs.DiGraph.\n\nFor each vertix of graph the agent_constructor function is called, with the Graphs.vertix as argument. For each edge of graph the edge_constructor function is called, with the Graphs.edge as argument.\n\nThe agent types of agents created by the agent_constructor must be already registered via register_agenttype! and vis a vis the edge type via register_edgetype!.\n\ninfo: Info\nadd_graph! is only available when the Graphs.jl package is imported by the model implementation. \n\nReturns a vector with the IDs of the created agents.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"There is also two function with works the other way and converts the underlying graph of an simulation (or a subset of this graph) to a structure that fulfills the AbstractGraph or AbstractSimpleGraph interface from the Graphs.jl package.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"vahanagraph\nvahanasimplegraph","category":"page"},{"location":"initialization.html#Vahana.vahanagraph","page":"Initialization","title":"Vahana.vahanagraph","text":"vahanagraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true, drop_multiedges = false])\n\nCreates a subgraph with nodes for all agents that have one of the agenttypes types, and all edges that have one of the edgetypes types and whose both adjacent agents have are of a type in agenttypes.\n\nThe default values for agenttypes and edgetypes are all registered agents/edgetypes (see register_agenttype! and register_edgetype!).\n\nThis subgraphs implements the AbstractGraph interface from the Graphs.jl package, so that e.g. GraphMakie can be used to visualize the subgraph. See also create_graphplot.\n\nThe AbstractGraph interface allows multiple edges between two nodes, but some functions (e.g. those that convert the graph to a binary (sparse) matrix) may produce undefined results for these graphs, e.g. when graphplot is called from GraphMakie.jl. If the keyword drop_multiedges is true and there are multiple edges, only the edge of the type that is first in the edgetypes vector is added to the generated graph.\n\nThe edge types must not have the :IgnoreFrom property. If there are edge types with this property in the edgetypes vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting show_ignorefrom_warning to false.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.vahanasimplegraph","page":"Initialization","title":"Vahana.vahanasimplegraph","text":"vahanasimplegraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true])\n\nCreates a subgraph with nodes for all agents that have one of the agenttypes types, and all edges that have one of the edgetypes types and whose both adjacent node types are in agenttypes.\n\nThe default values for agenttypes and edgetypes are all registered agents/edgetypes (see register_agenttype! and register_edgetype!).\n\nThis subgraphs implements the AbstractSimpleGraph interface from the Graphs.jl package.\n\nThe edge types must not have the :IgnoreFrom property. If there are edge types with this property in the edgetypes vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting show_ignorefrom_warning to false.\n\nwarning: Warning\nThe AbstractGraph interface allows multiple edges between two nodes, but some function (e.g. those that convert the graph into a binary (sparse)matrix can produce undefined results for those graphs. So use this function with care. \n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Raster","page":"Initialization","title":"Raster","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"The process for adding raster data to a simulation is documented here.","category":"page"},{"location":"initialization.html#Set-Parameters","page":"Initialization","title":"Set Parameters","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"After creating a simulation, you can modify parameter values using set_param! until the simulation is initialized with finish_init!.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"set_param!","category":"page"},{"location":"initialization.html#Vahana.set_param!","page":"Initialization","title":"Vahana.set_param!","text":"set_param!(sim::Simulation, param::Symbol, value)\n\nAssign the specified value to the param parameter. This operation is only allowed prior to calling the finish_init! method.\n\nA pipeable version of set_param! is also available.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Finish-initialization","page":"Initialization","title":"Finish initialization","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"After all the initial state has been built using the functions described above, finish_init! must be called before the first call of apply!","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"finish_init!","category":"page"},{"location":"initialization.html#Vahana.finish_init!","page":"Initialization","title":"Vahana.finish_init!","text":"finish_init!(sim::Simulation; [distribute = true, \n             partition::Dict{AgentID, ProcessID}, \n             partition_algo = :Metis])\n\nFinish the initialization phase of the simulation. \n\npartition is an option keyword and allows to specify an assignment of the agents to the individual MPI ranks. The dictonary must contain all agentids created on the rank as key, the corresponding value is the rank on which the agent \"lives\" after finish_init!.\n\nIn the case that no partition is given and distribute is set to true, the Graph will be partitioned with the given partition_algo. Currently two algorithms are supported:     - :Metis uses the Metis library for the graph partitioning.      - :EqualAgentNumbers just ensures that per agent type more or less       the same number of agents are distributed to each process.\n\nfinish_init! must be called before applying a transition function. \n\ninfo: Info\nWhen a simulation is run on multiple PEs, per default the graph found on rank 0 will be partitioned using Metis, and distributed to the different ranks. Which means that it's allowed to run the initialization phase on all ranks (there is no need for a mpi.isroot check), but then all added agents and edges on other ranks then 0 will be discarded. If this is not intended distribute must be set to false.\n\nSee also register_agenttype!, register_edgetype!, apply! and finish_simulation!\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"CurrentModule = Vahana","category":"page"},{"location":"hdf5.html#HDF5-data-storage","page":"File storage","title":"HDF5 data storage","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"Vahana uses the Hierarchical Data Format version 5 (HDF5) as file format to store simulations to disc, utilizing the HDF5.jl libary. HDF5.jl again uses a C library, which is either installed with HDF5.jl or can be provided by the system. Please check the HDF5.jl documentation for details.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"If the provided library supports Parallel HDF5, this will be used automatically. Using Parallel HDF5 has the advantage that all processes can write to a single file, without Parallel HDF5 multiple files are created for a single (parallel) simulation (but the Vahana API is the same in any case, so for the user this difference is only visible when looking into the h5 directory with a file manager or via the shell). But in the current Vahana version using Parallel HDF5 has the disadvantage, that the files are not compressed (see also set_compression).","category":"page"},{"location":"hdf5.html#Write","page":"File storage","title":"Write","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"To write into a HDF5 file, they are attached to a Vahama simulation. Normally this happens automatically when the first time a write function like write_snapshot is called. All following write_* calls then add additional datasets to the file.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"set_hdf5_path\nwrite_snapshot\ncreate_h5file!\nclose_h5file!","category":"page"},{"location":"hdf5.html#Vahana.set_hdf5_path","page":"File storage","title":"Vahana.set_hdf5_path","text":"set_hdf5_path(path::String)\n\nSpecify the path that is used to save and read the hdf5 files. If the directory does not exist, it is created the first time a file is written or tried to read.\n\nSee also create_h5file!\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_snapshot","page":"File storage","title":"Vahana.write_snapshot","text":"write_snapshot(sim::Simulation, [comment::String = \"\", ignore = []])\n\nWrites the current state of the simulation sim to the attached HDF5 file. comment can be used to identify the snapshot via list_snapshots, and to read this snapshot via the read_snapshot! function by utilizing the comment keyword of this function.\n\nignore is a list of agent and/or edge types, that should not be written.\n\nSee also create_h5file!, read_snapshot!\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.create_h5file!","page":"File storage","title":"Vahana.create_h5file!","text":"create_h5file!(sim::Simulation, [filename = sim.filename; overwrite = sim.overwrite_file])\n\nThe canonical way to create an HDF5 file is to call one of the write_ functions like write_snapshot. If sim does not already have an HDF5 file attached, such a file will then be created automatically using the filename specified as keyword in create_simulation or, if this keyword was not given, the model name. But sometime it can be useful to control this manually, e.g. after a call to copy_simulation.\n\nThe filename argument can be used to specify a filename other than sim.filename. If overwrite is true, existing files with this name will be overwritten. If it is false, the filename is automatically extended by an increasing 6-digit number, so that existing files are not overwritten.\n\nBy default, the files are created in an h5 subfolder, and this is created in the current working directory. However, the path can also be set with the function set_hdf5_path.\n\nIn the case that an HDF5 file was already created for the simulation sim, this will be closed.\n\ncreate_h5file! can be only called after finish_init!\n\nSee also close_h5file!, write_agents, write_edges, write_globals, read_agents!, read_edges!, read_globals, read_snapshot! and list_snapshots\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.close_h5file!","page":"File storage","title":"Vahana.close_h5file!","text":"close_h5file!(sim::Simulation)\n\nCloses the HDF5 file attached to the simulation sim.\n\nBe aware that a following call to one of the write_ functions like write_snapshot will automatically create a new file and, depending on the overwrite_file argument of create_simulation also overwrites to closed file.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"Beside write_snapshot there exists also some more fine grained write functions:","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"write_agents\nwrite_edges\nwrite_globals","category":"page"},{"location":"hdf5.html#Vahana.write_agents","page":"File storage","title":"Vahana.write_agents","text":"write_agents(sim::Simulation, [types])\n\nWrites the current agent state to the attached HDF5 file. If only the agents of a subset of agent types are to be written, this subset can be specified via the optional types argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_edges","page":"File storage","title":"Vahana.write_edges","text":"write_edges(sim::Simulation, [types])\n\nWrites the current edge states to the attached HDF5 file. If only the edges of a subset of edge types are to be written, this subset can be specified via the optional types argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_globals","page":"File storage","title":"Vahana.write_globals","text":"write_globals(sim::Simulation, [fields])\n\nWrites the current global values to the attached HDF5 file. If only a subset of the fields is to be written, this subset can be specified via the optional fields argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Read","page":"File storage","title":"Read","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"In the normal use case we call just write_snapshot(sim, \"snapshot description\") (assuming sim is a Vahama simulation). To read such a snapshot, we can then run another Script that creates the same model (see create_model) and simulation (see create_simulation) and then call read_snapshot!(sim). read_snapshot! can read also a parallel simulation into a single (REPL) process, then the distributed graph is merged into a single one.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"read_snapshot!","category":"page"},{"location":"hdf5.html#Vahana.read_snapshot!","page":"File storage","title":"Vahana.read_snapshot!","text":"read_snapshot!(sim::Simulation, [name::String; transition = typemax(Int64), comment = \"\", writeable = false, ignore_params = false])\nread_snapshot!(sim::Simulation, nr::Int64; [transition = typemax(Int64), comment = \"\", writeable = false, ignore_params = false])\n\nRead a complete snapshot from a file into the simulation sim. If name is given, the snapshot is read from the file with this filename from the h5 subfolder of the current working directory.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written snapshot is read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nIf writeable is set to true, the file is also attached to the simulation and following write_ functions like write_snapshot will be append to the file.\n\nIf ignore_params is set to true, the parameters of sim will not be changed.\n\nReturns false when no snapshot was found \n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"Also here exists also some more fine grained read functions:","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"read_params\nread_globals\nread_agents!\nread_edges!","category":"page"},{"location":"hdf5.html#Vahana.read_params","page":"File storage","title":"Vahana.read_params","text":"read_params(filename::String, T::DataType)\nread_params(sim::Simulation, T::DataType)\nread_params(sim::Simulation, nr::Int64, T::DataType)\nread_params(filename::String)\n\nRead the parameters from an HDF5 file. If filename is given, the parameters are read from the file with this filename from the h5 subfolder of the current working directory.\n\nIf a simulation sim is given instead, the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nIn the case that the DataType T of the argument globals of create_simulation used for the simulation is specified, the result will be an instance of T, elsewhere it will be a Dict with the fields of the written Globals type as keys.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_globals","page":"File storage","title":"Vahana.read_globals","text":"read_globals(filename::String, T::DataType; [ transition = typemax(Int64), comment = \"\" ])\nread_globals(sim::Simulation, T::DataType; [ transition = typemax(Int64), comment = \"\" ])\nread_globals(sim::Simulation, nr::Int64, T::DataType; [ transition = typemax(Int64), comment = \"\" ])\nread_globals(filename::String; [ transition = typemax(Int64), comment = \"\" ])\n\nRead the global values from an HDF5 file. If filename is given, the parameters are read from the file with this filename from the h5 subfolder of the current working directory.\n\nIf a simulation sim is given instead, the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nIn the case that the DataType T of the argument globals of create_simulation used for the simulation is specified, the result will be an instance of T, elsewhere it will be a Dict with the fields of the written Globals type as keys.\n\nPer default, the last written globals are read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nSee also File storage for details.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_agents!","page":"File storage","title":"Vahana.read_agents!","text":"read_agents!(sim::Simulation, [name::String = sim.filename; transition = typemax(Int64), types::Vector{DataType}, comment = \"\" ])\nread_agents!(sim::Simulation, nr::Int64; [transition = typemax(Int64), types::Vector{DataType}, comment = \"\" ])\n\nRead the agents from an HDF5 file into the simulation sim. If name is given, the agent are read from the file with this filename from the h5 subfolder of the current working directory, or from the subfolder set with set_hdf5_path. In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written agents are read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nIf only the agents of a subset of agent types are to be read, this subset can be specified via the optional types argument.\n\nWhen the agents from a distributed simulation is read into a single threaded simulation, the IDs of the agents are modified.  read_agents! returns a dictory that contains the ID mapping.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_edges!","page":"File storage","title":"Vahana.read_edges!","text":"read_edges!(sim::Simulation, [name::String = sim.filename; idmapfunc = identity, transition = typemax(Int64), types::Vector{DataType}, comment = \"\" ])\nread_edges!(sim::Simulation, nr::Int64; [ idmapfunc = identity, transition = typemax(Int64), types::Vector{DataType}, comment = \"\" ])\n\nRead the edges from an HDF5 file into the simulation sim. If name is given, the edges are read from the file with this filename from the h5 subfolder of the current working directory.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written edges are read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nIf only the edges of a subset of edge types are to be read, this subset can be specified via the optional types argument.\n\nWhen the agents from a distributed simulation is read into a single threaded simulation, the IDs of the agents are modified.  The idmapfunc must be a function that must return the new agent id for a given old agent id. read_agents! returns a Dict{AgentID, AgentID} that can be used for this via: idmapfunc = (key) -> idmapping[key], where idmapping is such a Dict.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"For e.g. postprocessing it is possible to read the simulation state without defining a model and simulation. Just import Vahana, use set_hdf5_path to determine where the simulations are stored and use:","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"read_agents\nread_edges","category":"page"},{"location":"hdf5.html#Vahana.read_agents","page":"File storage","title":"Vahana.read_agents","text":"read_agents(filename::String, type; transition = typemax(Int64))\n\nRead the agentstates of type (which can be a DataType, String or Symbol) from an HDF5 file with the name filename. The agent are read from the h5 subfolder of the current working directory, or from the subfolder set with set_hdf5_path.\n\nPer default, the last written agents are read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nReturns a vector of agentstates.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_edges","page":"File storage","title":"Vahana.read_edges","text":"read_edges(filename::String, type; transition = typemax(Int64), comment = \"\")\n\nRead the edgestates of type (which can be a DataType, String or Symbol) from an HDF5 file with the name filename.  The edgestates are read from the h5 subfolder of the current working directory, or from the subfolder set with set_hdf5_path.\n\nPer default, the last written edgestates are read. The transition keyword allows to read also earlier versions. Alternatively, the comment that was specified when write_snapshot was called can be specified with the comment keyword to read the corresponding snapshot.\n\nReturns a vector of edgestates.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"You can also read the parameters and globals of a simulation in the same way using the method implementations of read_params and read_globals without specifing a DataType (this will return Dicts of parameters/globals).","category":"page"},{"location":"hdf5.html#Transition","page":"File storage","title":"Transition","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"All read_* functions have a keyword called transition. If this is not set, the last stored data of a type is always read, but via this keyword it is also possible to read the previous state of the simulation (or a part of it) (assuming it was written multiple times, of course).","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"Vahana counts internally how many times the function apply! is called (in the current Vahana implementation this is stored in a field called num_transitions of the simulation). When a new dataset is created by a write_* call, this information is stored with the dataset.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"When read_snapshot! is called, Vahana looks for the highest num_transition that is less than or equal to the transition keyword for the types to be read. Since the default value for the argument is typemax(Int64), the newest dataset is read by default.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"For snapshots the list_snapshots function returns a list of all stored snapshots in the file.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"list_snapshots","category":"page"},{"location":"hdf5.html#Vahana.list_snapshots","page":"File storage","title":"Vahana.list_snapshots","text":"list_snapshots(name::String)\nlist_snapshots(sim::Simulation)\nlist_snapshots(sim::Simulation, nr::Int64)\n\nList all snapshots of a HDF5 file. If name is given, the snapshots from the file with this filename is returned.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nReturns a vector of tuples, where the first element is the transition number for which a snapshot was saved, and the second element is the comment given in the write_snapshot call.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Metadata","page":"File storage","title":"Metadata","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"It's possible to attach Metadata to the parameters and globals of a simulation.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"write_metadata\nwrite_sim_metadata\nread_metadata\nread_sim_metadata","category":"page"},{"location":"hdf5.html#Vahana.write_metadata","page":"File storage","title":"Vahana.write_metadata","text":"write_metadata(sim::Simulation, type::Union{Symbol, DataType}, field::Symbol, key::Symbol, value)\n\nAttach metadata to a field of an agent- or edgetype or the globals or params struct (see create_simulation) or to a raster (in that case field must be the name of the raster). type must be an agent- or edgetype, :Global, :Param or :Raster. Metadata is stored via key, value pairs, so that multiple data of different types can be attached to a single field.\n\nSee also: read_metadata\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_sim_metadata","page":"File storage","title":"Vahana.write_sim_metadata","text":"write_sim_metadata(sim::Simulation, key::Symbol, value)\n\nAttach additional metadata to a simulation. \n\nSee also: read_sim_metadata\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_metadata","page":"File storage","title":"Vahana.read_metadata","text":"read_metadata(sim::Simulation, type::Union{Symbol, DataType}[, field::Symbol, key::Symbol ])\nread_metadata(filename::String, type::Union{Symbol, DataType}[, field::Symbol, key::Symbol ])\n\nRead metadata for a field of an agent- or edgetype or the globals or params struct (see create_simulation) or to a raster (in that case field must be the name of the raster). type must be an agent- or edgetype :Global, :Param or :Raster. Metadata is stored via key, value pairs. Multiple data of different types can be attached to a single field, a single piece of the metadata can be retrived via the key parameter. If this is not set (or set to Symbol()), a Dict{Symbol, Any} with the complete metadata of this field is returned.\n\nSee also: write_metadata\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_sim_metadata","page":"File storage","title":"Vahana.read_sim_metadata","text":"read_sim_metadata(sim::Simulation, [ key::Symbol = Symbol() ])\nread_sim_metadata(filename::String, [ key::Symbol = Symbol() ])\n\nRead metadata for a simulation or from the file filename. Metadata is stored via key, value pairs. If key is not set (or set to Symbol()), a Dict{Symbol, Any} with the complete metadata of the simulation is returned.\n\nThe following metadata is stored automatically:\n\nsimulation_name\nmodel_name\ndate (in the format \"yyyy-mm-dd hh:mm:ss\")\n\nSee also: write_metadata\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Restrictions-and-Workarounds","page":"File storage","title":"Restrictions and Workarounds","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"The exact datastructs that can be stored and read from a HDF5 depends in the HDF5.jl implementation. E.g. before v0.16.15 Tuples where not supported. ","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"The following functions are workarounds for two current restrictions.","category":"page"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"create_enum_converter\ncreate_namedtuple_converter\ncreate_string_converter","category":"page"},{"location":"hdf5.html#Vahana.create_enum_converter","page":"File storage","title":"Vahana.create_enum_converter","text":"create_enum_converter()\n\nThe HDF5.jl library does not support Enums as fields of structs that should be stored. This function add this support but as this involves type piracy, this support must be enabled explicitly.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.create_namedtuple_converter","page":"File storage","title":"Vahana.create_namedtuple_converter","text":"create_namedtuple_converter(T::DataType)\n\nThe HDF5.jl library does not support the storage of nested structs, but structs can have NamedTuples as fields. This function creates a convert function from a struct to a corresponding NamedTuple (and also the other way around), so after calling this for a type T, T can be the type of an agent/edge/param/global field.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.create_string_converter","page":"File storage","title":"Vahana.create_string_converter","text":"create_string_converter(add_show_method::Bool = true)\n\nThe HDF5.jl library (version 0.17.2) does not support InlineStrings or StaticStrings in structs. Standard Strings are also not suitable for agent and edge types, as these must be bits types.\n\nTo address this limitation, create_string_converter generates gconversion methods between String and SVector{N, UInt8} instances (from the StaticArrays package).  Here, N represents the maximum number of bytes that can be stored, which for Unicode strings may exceed the character count due to variable-length encoding.\n\nFor example, you could create a Person struct with a fixed-size name field:\n\nstruct Foo\n    foo::SVector{20, UInt8}\nend\n\nYou can then construct a Foo instance using a regular string: Foo(\"abc\").\n\nIf add_show_method is set to true (the default), show methods are also defined for these SVectors. To avoid confusion while working with Julia's REPL, where the value might appear as a String while actually being an SVector, the output includes \"(as UInt8-Vector)\" after the value itself.\n\nWhen add_show_method is set to true (which is the default behavior), show methods are automatically defined for the SVector types. To prevent potential confusion arising from the display of SVector values as Strings, the output is formatted to include the annotation \"::UInt8[]\" following the value itself. \n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Example-Model","page":"File storage","title":"Example Model","text":"","category":"section"},{"location":"hdf5.html","page":"File storage","title":"File storage","text":"The tutorials in the documentation does not include examples for the file storage functionality, but this model is a good example, which also demonstrates checkpointing (resuming a simulation after an interruption), and working with initial snapshots (the initialized simulation state is stored after the graph structure is constructed and distributed to the different processes).","category":"page"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"CurrentModule = Vahana","category":"page"},{"location":"changelog.html#Change-Log","page":"Change Log","title":"Change Log","text":"","category":"section"},{"location":"changelog.html#v1.2.1","page":"Change Log","title":"v1.2.1","text":"","category":"section"},{"location":"changelog.html#New-feature","page":"Change Log","title":"New feature","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"Added workaround for strings in structs stored to a HDF5-file. Check the documentation of create_string_converter for details.","category":"page"},{"location":"changelog.html#v1.2","page":"Change Log","title":"v1.2","text":"","category":"section"},{"location":"changelog.html#Breaking-changes","page":"Change Log","title":"Breaking changes","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"The all_ranks default value for num_agents changed to true.","category":"page"},{"location":"changelog.html#New-features","page":"Change Log","title":"New features","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"The functions all_agentids and all_edges allows to get the ids of all agents or the edges on the rank or the complete simulation.\nThe functions write_metadata, write_sim_metadata, read_sim_metadata and read_metadata allows to attach Metadata to the simulation or individual parts of the model.\nInstead of writing structs for Parameters and Globals it is now also possible to use register_param! and register_global!.\nRandom cells or positions of a grid can be obtained via random_pos and random_cell\nThe function cellid allows to retrieve the id of a cell on a given position.\nThe functions remove_edges! allows to remove edges between to agents, or all edges to an agent.\nThe new function rastervalues can be sometimes a useful shorter version then calc_rasterstate.\nNew functions set_log_path allows to set the path for log files.\nThe keyword with_edge of the function apply allows to restrict the called agents to those agents that have an edge of type with_edge. - The new :Independet hint can be given to agent types if agents of this type never access the state of other agents of this type. This allows Vahana to directly modify the state of an agent in its transition functions without having to copy all agents of that type.\nThe new hint :Independent can be given to agent types if agents of this type never access the state of other agents of this type. This allows Vahana to change the state of an agent directly in the corresponding vector in a transition functions without copying all agents of this type.\nFor neighborstates, neighborstates_flexible, neighborids and edgestates there are now also functions that return an iterator for of states/ids instead of a vector these states/ids. They have the same function name, extended with _iter, e.g. neighborstates_iter.\nThe function add_agent_per_process! allows you to add a single agent of an agent type to each process of a parallel simulation.\nNew function modify_global! which is a combination of set_global! and get_global.","category":"page"},{"location":"changelog.html#Improvements","page":"Change Log","title":"Improvements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"read_snapshot! can be also used to read data that was written via calls to write_agents, write_edges etc..\ncalc_rasterstate tries to retrieve the returned type automatically by default.\nWhen show_agent is called with an id, it is no longer necessary to give also the agent type.\nImproved error messages.\nJulia 1.11 introduced a breaking change in Stateful Iterators. Vahana's edge iterators have now been adapted to accommodate this breaking change.","category":"page"},{"location":"changelog.html#Performance-Improvements","page":"Change Log","title":"Performance Improvements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"move_to! improvements.\nRemoved an unnecessary memcpy of edges for the case that the type is in the add_existing argument, but not in the read argument of a transition function.","category":"page"},{"location":"changelog.html#Fixes","page":"Change Log","title":"Fixes","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"When edges were removed as a consequence of removing agents, this change was not written to the hdf5 file until also other changes to the edges of this type happen.\nIn a parallel simulation, sometime not all edges were written to the hdf5 file.\nFixed a compability issue with Microsofts MPI implementation.\nlog folder was also created when no log file was written.\nshow_agent didn't work for all agent hint combinations.\nIt was necessary (and not documented) that add_raster! was called from all ranks. Now it is possible to call it only from rank 0 (like add_agent! etc.).","category":"page"},{"location":"changelog.html#v1.1","page":"Change Log","title":"v1.1","text":"","category":"section"},{"location":"changelog.html#New-features-2","page":"Change Log","title":"New features","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"New functions set_hdf5_path allows to set the path for hdf5 files.","category":"page"},{"location":"changelog.html#Improvements-2","page":"Change Log","title":"Improvements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"Removed usage of Base.memcpy! do be compatible with Julia 1.10.\nImproved error messages.","category":"page"},{"location":"changelog.html#Performance-Improvements-2","page":"Change Log","title":"Performance Improvements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"For calc_raster and calc_rasterstate.","category":"page"},{"location":"changelog.html#Fixes-2","page":"Change Log","title":"Fixes","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"Empty arrays where not supported for parameters or globals when they where writted to a hdf5 file.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"CurrentModule = Vahana","category":"page"},{"location":"transition.html#Transition-Function","page":"Transition Function","title":"Transition Function","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"After the initialization, the state of the simulation is modified by so called transition functions. See Defining Transition Functions for details.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"apply!\napply","category":"page"},{"location":"transition.html#Vahana.apply!","page":"Transition Function","title":"Vahana.apply!","text":"apply!(sim, func, call, read, write; [add_existing, with_edge])\n\nApply the transition function func to the simulation state. \n\ncall must be a single agent type or a collection of agent types, likewise read and write must be a single agent/edge type or a collection of agent/edge types.\n\ncall determines for which agent types the transition function func is called. Within the transition function, an agent has access to the state of agents (including its own state) and to edges only if their types are in the read collection. Accordingly, the agent can change its own state and/or create new agents or edges only if their types are in the write collection.\n\nAssume that T is an agent type that is in call. In case T is also in read, the transition function must have the following signature: transition_function(agent::T, id, sim), where the type declaration of agent is optional if call contains only a single type. If T is not in read, it must have the signature transition_function(::Val{T}, id::AgentID, sim::Simulation).\n\nIf T is in write, the transition function must return either an agent of type T or nothing. If nothing is returned, the agent will be removed from the simulation, otherwise the agent with id id will get the returned state after the transition function was called for all agents.\n\nWhen an edge state type is in write, the current edges of that type are removed from the simulation. If you want to keep the existing edges for a specific type, you can add this type to the optional add_existing collection.\n\nSimilarly, agent types that are in the write but not in the call argument can be part of the add_existing collection, so that the existing agents of this type are retained and can only be added. For agent types in call, however, this is achieved by returning their state in the transition function.\n\nWith the keyword with_edge it is possible to restrict the set of agents for which the transition function is called to those agents who are on the target side of edges of the type with_edge. So  \n\napply!(sim, AT, ET, []) do _, id, sim \n    if has_edge(sim, id, ET)\n       do_something\n    end\nend\n\nis equivalent to \n\napply!(sim, AT, ET, []; with_edge = ET) do _, id, sim \n    do_something\nend\n\nbut saves all the has_edge checks.\n\nThis with_edge keyword should only be set when a small subset of agents possess edges of this particular type, as performance will be adversely impacted in other scenarios. Also the keyword can only be used for edgetypes without the :SingleType hint.\n\nSee also apply and the Applying Transition Function section in the tutorial\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.apply","page":"Transition Function","title":"Vahana.apply","text":"apply!(sim, func, call, read, write; add_existing)\n\nCall apply! with a copy of the simulation so that the state of sim itself is not changed.\n\nCan be very useful during development, especially if Vahana is used in the REPL. However, for performance reasons, this function should not be used in the final code.\n\nReturns the copy of the simulation.\n\nSee also apply!\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"tip: Tip\nThe agent types must be immutable, but in many cases the agent returned by a transition function will have a different state than the agent specified as a parameter. If only one field is changed, we still need to copy all other fields. The Setfield.jl package can be very useful in this case.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"Inside a transition function the following functions can be used to access the state of the simulation:","category":"page"},{"location":"transition.html#Globals-and-Parameters","page":"Transition Function","title":"Globals and Parameters","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"param\nget_global","category":"page"},{"location":"transition.html#Vahana.param","page":"Transition Function","title":"Vahana.param","text":"param(sim::Simulation, name)\n\nReturns the value of the field name of the params struct from the Simulation constructor.\n\nSee also create_model\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.get_global","page":"Transition Function","title":"Vahana.get_global","text":"get_global(sim::Simulation, name)\n\nReturns the value of the field name of the globals struct for simulation sim.\n\nSee also create_simulation, set_global! and push_global!\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Get-Agent(state)","page":"Transition Function","title":"Get Agent(state)","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"agentstate\nagentstate_flexible","category":"page"},{"location":"transition.html#Vahana.agentstate","page":"Transition Function","title":"Vahana.agentstate","text":"agentstate(sim, id::AgentID, ::Type{T})\n\nReturns the state of an agent of type T.\n\nIn the case where the type T is not determinable when writing the code (e.g. since there may be edges between agents of different types, the function edges may also return agentIDs of different agent types), agentstate_flexible must be used instead.\n\nwarning: Warning\nif agentstate is called with a Type{T} that does not match the type of the agent with id and the vahana assertions are disabled via enable_asserts, then it is possible that the state of an incorrect agent will be returned. When the assertions are active, there is a runtime check that the agent with the ID id has indeed the type T.\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.agentstate_flexible","page":"Transition Function","title":"Vahana.agentstate_flexible","text":"agentstate_flexible(sim, id::AgentID)\n\nReturns the state of an agent with the id, where the type of the agent is determined at runtime. If the type is known at compile time, using agentstate is preferable as this improves performance.\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"To retrieve the states of all agents connected to a target agent through edges of a specific type, the neighborstates_iter functions can be beneficial. These functions combine the capabilities of neighborids and agentstate, allowing you to easy access the desired information.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"neighborstates\nneighborstates_flexible\nneighborstates_iter\nneighborstates_flexible_iter","category":"page"},{"location":"transition.html#Vahana.neighborstates","page":"Transition Function","title":"Vahana.neighborstates","text":"neighborstates(sim::Simulation, id::AgentID, ::Type{E}, ::Type{A})\n\nReturns the state of the agent with type A on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these agent states otherwise.\n\nIf there is no edge with agent id as target, neighborstates returns nothing.\n\nWhen the agents on the source side of the edges can have different types, and it is impossible to determine the Type{A} you can use neighborstates_flexible instead.\n\nneighborstates is not defined if T has the hint :IgnoreFrom \n\ntip: Tip\nIf the edge type E does not have the :SingleEdge hint, neighborstates allocates memory for the vector of agent states. To avoid this allocation, you can use neighborstates_iter instead.\n\nSee also apply!, edges, neighborids, num_edges, has_edge and edgestates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborstates_flexible","page":"Transition Function","title":"Vahana.neighborstates_flexible","text":"neighborstates_flexible(sim::Simulation, id::AgentID, ::Type{E})\n\nReturns the state of the agent on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these agent states otherwise.\n\nIf there is no edge with agent id as target, neighborstates_flexible returns nothing.\n\nneighborstates_flexible is the type instable version of neighborstates and should be only used in the case that the type of agent can not be determined.\n\nneighborstates_flexible is not defined if T has the hint :IgnoreFrom.\n\ntip: Tip\nIf the edge type E does not have the :SingleEdge hint, neighborstates_flexible allocates memory for the vector of  agent states. To avoid this allocation, you can use neighborstates_flexible_iter instead.\n\nSee also apply!, edges, neighborids, num_edges, has_edge and edgestates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborstates_iter","page":"Transition Function","title":"Vahana.neighborstates_iter","text":"neighborstates_iter(sim::Simulation, id::AgentID, ::Type{E}, ::Type{A})\n\nReturns an iterator for the states of the agents with type A  on the source of the edges  of type E with agent id as target.\n\nIf there is no edge with agent id as target, the function returns nothing.\n\nWhen the agents on the source side of the edges can have different types, and it is impossible to determine the Type{A} you can use neighborstates_flexible_iter instead.\n\nneighborstates_iter is not defined if T has the hint :IgnoreFrom or :SingleEdge.\n\nSee also neighborstates, apply!, edges, neighborids, num_edges, has_edge and edgestates \n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborstates_flexible_iter","page":"Transition Function","title":"Vahana.neighborstates_flexible_iter","text":"neighborstates_flexible_iter(sim::Simulation, id::AgentID, ::Type{E})\n\nReturns an iterator for the states of the agents on the source of the edges  of type E with agent id as target.\n\nIf there is no edge with agent id as target, the function returns nothing.\n\nneighborstates_flexible_iter is the type instable version of neighborstates_iter and should be only used in the case that the type of agent can not be determined.\n\nneighborstates_flexible_iter is not defined if T has the hint :IgnoreFrom or the hint :SingleEdge.\n\nSee also neighborstates_flexible, apply!, edges, neighborids, num_edges, has_edge and edgestates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Get-Edge(state)","page":"Transition Function","title":"Get Edge(state)","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"edges\nedgestates\nedgestates_iter\nneighborids\nneighborids_iter\nnum_edges(::Simulation, id::AgentID, edgetype::Type) \nhas_edge","category":"page"},{"location":"transition.html#Vahana.edges","page":"Transition Function","title":"Vahana.edges","text":"edges(sim, id::AgentID, ::Type{E})\n\nReturns the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these edges otherwise.\n\nIf there is no edge with agent id as target, edges returns nothing.\n\nedges is not defined if E has the hint :IgnoreFrom or :Stateless.\n\nSee also apply!, neighborids, edgestates, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.edgestates","page":"Transition Function","title":"Vahana.edgestates","text":"edgestates(sim, id::AgentID, ::Type{E})\n\nReturns the state of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these states otherwise.\n\nIf there is no edge with agent id as target, edgestates returns nothing.\n\nedgestates is not defined if E has the hint :Stateless.\n\ntip: Tip\nIf the edge type E does not have the :Stateless or :SingleEdge hint, edgestates allocates memory for the vector of states. To avoid this allocation, you can use edgestates_iter instead.\n\nSee also apply!, edges, neighborids, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.edgestates_iter","page":"Transition Function","title":"Vahana.edgestates_iter","text":"edgestates_iter(sim, id::AgentID, ::Type{E})\n\nReturns an iterator of the states of the edges of type E with agent id as target.\n\nIf there is no edge with agent id as target, the function returns nothing.\n\nedgestates_iter is not defined if E has the hint :Stateless or :SingleEdge.\n\nSee also apply!, edgestates, edges, neighborids, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborids","page":"Transition Function","title":"Vahana.neighborids","text":"neighborids(sim, id::AgentID, ::Type{E})\n\nReturns the ID of the agent on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or otherwise a vector of the IDs of the agents on the source side of those edges.\n\nIf there is no edge with agent id as target, neighborids returns nothing.\n\nneighborids is not defined if E has the hint :IgnoreFrom.\n\ntip: Tip\nIf the edge type E does not have the :Stateless or :SingleEdge  hint, neighborids allocates memory for the vector of agent ids. To avoid this allocation, you can use neighborids_iter  instead.\n\nSee also apply!, edges, edgestates, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborids_iter","page":"Transition Function","title":"Vahana.neighborids_iter","text":"neighborids_iter(sim, id::AgentID, ::Type{E})\n\nReturns an iterator of the IDs of the agents on the source side of edges of type E with agent id as target.\n\nIf there is no edge with agent id as target, the function returns nothing.\n\nneighborids is not defined if E has the hint :SingleEdge or :IgnoreFrom.\n\nSee also apply!, neighborids, edges, edgestates, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.num_edges-Tuple{Vahana.Simulation, UInt64, Type}","page":"Transition Function","title":"Vahana.num_edges","text":"num_edges(sim, id::AgentID, ::Type{E})\n\nReturns the number of edges of type E with agent id as target.\n\nnum_edges is not defined if T has the hint :SingleEdge\n\nSee also apply!, edges, neighborids, edgestates, has_edge and neighborstates\n\n\n\n\n\n","category":"method"},{"location":"transition.html#Vahana.has_edge","page":"Transition Function","title":"Vahana.has_edge","text":"has_edge(sim, id::AgentID, ::Type{E})\n\nReturns true if there is at least one edge of type E with agent id as target.\n\nhas_edge is not defined if T has the :SingleEdge and :SingleType hints, with the exception that it has also the :IgnoreFrom and :Stateless hints.\n\nSee also apply!, edges, neighborids, edgestates, num_edges and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"For all the function like edges that returns nothing in the case that there is no edge with the agent as target, it can be useful to increase the readability of the code by using the checked function to test for nothing.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"checked","category":"page"},{"location":"transition.html#Vahana.checked","page":"Transition Function","title":"Vahana.checked","text":"checked(f, g, itr; kwargs...)\n\nCalls g(f, itr; kwargs...), but only if itr != nothing.\n\nAs all the Vahana functions that access the edges of a specific agent can return nothing in the case, that there exist no incoming edge for this agent, it's often necessery to check this case. \n\nExample:\n\nInstead of writing \n\nnids = neighborids(sim, id, Contact)\nif nids != nothing\n    foreach(nids) do nid\n      add_edge!(sim, id, nid, Inform()\n    end\nend\n\nyou can use the checked function to write\n\nchecked(foreach, neighborids(sim, id, Contact)) do nid\n    add_edge!(sim, id, nid, Inform())\nend\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Add-Agents/Edges","page":"Transition Function","title":"Add Agents/Edges","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"The following functions from the [Initialization] section (initialization.md) that add new agents or edges to a simulation can also be used inside a transition function, namely:","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"add_agent! and add_agents!\nadd_edge! and add_edges!\nconnect_raster_neighbors!\nmove_to!","category":"page"},{"location":"transition.html#Remove-Edges","page":"Transition Function","title":"Remove Edges","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"Since v1.2 it's also possible to remove edges:","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"remove_edges!","category":"page"},{"location":"transition.html#Vahana.remove_edges!","page":"Transition Function","title":"Vahana.remove_edges!","text":"remove_edges!(sim::Simulation, to::AgentID, ::Type{E})\n\nRemove all edges of type E where to is at the target position. \n\nCan only be called within a transition function, where E is in the write argument and also in the add_existing list of apply!.\n\n\n\n\n\nremove_edges!(sim::Simulation, from::AgentID, to::AgentID, ::Type{E})\n\nRemoves all edges of type E with from at the source position and to at the target position of an edge. remove_edges! in this form (with from as argument) can only be called if the edge type E does not have the :IgnoreFrom hint.\n\nCan also only be called within a transition function, where E is in the write argument and also in the add_existing list of apply!.\n\n\n\n\n\n","category":"function"},{"location":"apiindex.html","page":"Index","title":"Index","text":"CurrentModule = Vahana -->","category":"page"},{"location":"apiindex.html","page":"Index","title":"Index","text":"Modules = [Vahana]","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"EditURL = \"../examples/tutorial1.jl\"","category":"page"},{"location":"tutorial1.html#First-Steps","page":"First Steps","title":"First Steps","text":"","category":"section"},{"location":"tutorial1.html#Goal","page":"First Steps","title":"Goal","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In this tutorial, we will build a simple market model with multiple buyers and sellers. Each buyer has a fixed budget and preferences for two goods, x and y. Sellers offer these goods, and buyers purchase from a randomly selected subset of sellers at each time step.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The model illustrates several core concepts in Vahana, including:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Defining agent and edge types as structs\nInitializing a simulation with agents and edges\nImplementing transition functions to update agent states\nTracking simulation results","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This simple model serves as an introduction to Vahana's capabilities for agent-based modeling. While relatively basic, it demonstrates how to represent a multi-agent system with different types of agents, connections between agents, and state transitions driven by agent interactions.","category":"page"},{"location":"tutorial1.html#Model-Overview","page":"First Steps","title":"Model Overview","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Our model simulates a dynamic market with n buyers and m sellers, trading two types of goods: x and y. We use good x as the numeraire, fixing its price at 1, while the price of good y, denoted as p, is variable and adjusted by sellers over time.  Each buyer in our market has a unique preference and a constant budget B for purchasing both commodities. These preference is represented by an individual parameter α, which determines the buyer's relative desire for good x versus good y. Buyers make their purchasing decisions based on a Cobb-Douglas utility function:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"max_xy u(x y) = x^alpha cdot y^1 - alpha","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"subject to their budget constraint: x + y  p  B. This utility maximization leads to an optimal demand for each good:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"beginaligned\nx = B cdot alpha \ny = fracB cdot (1 - alpha)p\nendaligned","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"On the supply side, sellers offer both goods x and y, which we assume to be joint products. Their primary goal is to balance the production and sales of these two goods. To achieve this, sellers adjust their prices based on the aggregate demand from their customers. The price adjustment mechanism is given by:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"beginaligned\np_t = fracd_yd_x cdot p_t-1 \ntextrmwhere  d_x = sum_b in textrmbuyersx_b quad d_y = sum_b in textrmbuyers y_b\nendaligned","category":"page"},{"location":"tutorial1.html#Agent-and-Edge-Types","page":"First Steps","title":"Agent and Edge Types","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Now that we understand our market model, let's implement it using Vahana. We'll start by defining our agent types and edge types, then create and initialize our simulation.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"First, we need to import the necessary modules:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"using Vahana\nimport Random: rand\nimport DataFrames","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In Vahana, agents and the edges between them are represented by Julia structs. However, these structs must meet specific requirements:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"They must be immutable.\nThey must be \"bitstypes\".","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"A bitstype in Julia is a type that is composed entirely of primitive types (like Int, Float64, Bool) or other bitstypes, and has a known, fixed size in memory.  This also implies that the type of a struct variables must be declared.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This restrictions allows Vahana to efficiently manage and distribute agents across processes in parallel simulations.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Let's define our agent types with these requirements in mind:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"struct Buyer\n    α::Float64  # Preference parameter\n    B::Float64  # Budget\nend\n\nstruct Seller\n    p::Float64   # Current price of good y\n    d_y::Float64 # Total demand for good y (used for price adjustment)\nend","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To facilitate agent creation with some randomization, we'll define custom constructors:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Buyer() = Buyer(rand(), rand((1:100)))\n\nSeller() = Seller(rand() + 0.5, 0);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"These constructors create:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Buyers with random alpha (between 0 and 1) and B (between 1 and 100)\nSellers with a random initial price p (between 0.5 and 1.5) and zero initial demand.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Now, let's look at our edge types in more detail:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This KnownSeller network is fixed and describes the sellers known to each buyer. In Vahana, the direction of an edge determines the flow of information. Since buyers need price information from sellers to calculate their demand, we define this as an edge from sellers to buyers. We call this network KnownSeller.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The edges of the KnownSeller network don't carry additional information, so we define them as an empty struct. We'll use this as a kind of tag later to select only the edges of this type.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"struct KnownSeller end","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The Bought network represents actual transactions between buyers and sellers. This network is dynamic, with edges created during the simulation runtime. Each edge in the Bought network carries information about the quantities of goods purchased in a transaction. Specifically:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"struct Bought\n    x::Float64  # Quantity of good x bought\n    y::Float64  # Quantity of good y bought\nend","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To make working with Bought edges easier, we'll define an addition operation:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"import Base.+\n+(a::Bought, b::Bought) = Bought(a.x + b.x, a.y + b.y);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This allows us to easily sum up multiple Bought edges, which will be useful when sellers calculate total demand.","category":"page"},{"location":"tutorial1.html#Defining-the-Model-Structure","page":"First Steps","title":"Defining the Model Structure","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In Vahana, the ModelTypes constructor is the starting point for defining the structure of your agent-based model. To populate this instance, we use the register_agenttype! and register_edgetype! functions. These functions tell Vahana about the types of agents and edges in your model, allowing it to set up the necessary internal data structures and optimizations. The |> operator can be used for function chaining, providing a concise way to register multiple types.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"const modeltypes = ModelTypes() |>\n    register_agenttype!(Buyer) |>\n    register_agenttype!(Seller) |>\n    register_edgetype!(KnownSeller) |>\n    register_edgetype!(Bought);\nnothing #hide","category":"page"},{"location":"tutorial1.html#Defining-Model-Parameters-and-Globals","page":"First Steps","title":"Defining Model Parameters and Globals","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Vahana offers two ways to define parameters for your model: using register_param! or creating a custom parameter struct. The register_param! function allows you to register individual parameters with your model. For example, you might use:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"modeltypes |>\n    register_param!(:numBuyer, 50) |>\n    register_param!(:numSeller, 5) |>\n    register_param!(:knownSellers, 2);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"With this approach, the parameters can then be set to values other than the default value via set_param! calls until the simulation is initialized with finish_init!.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Alternatively you can define a custom parameter struct and then pass an instance of this struct to create_simulation.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In addition to parameters, Vahana allows you to manage global state variables that can change during the simulation. This is particularly useful for tracking aggregate statistics or maintaining shared information across all agents. Similar to parameters, you can register individual global variables:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"modeltypes |>\n    register_global!(:x_minus_y, Vector{Float64}()) |>\n    register_global!(:p, Vector{Float64}());\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Again, you could alternatively, you can define a custom struct for globals and pass an instance of this struct to create_simulation as shown in the other tutorials.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Please note that Vahana's global state is distinct from the functionality of the global keyword in Julia programming language. The two concepts are unrelated and should not be conflated.","category":"page"},{"location":"tutorial1.html#Create-the-Model-and-Simulation","page":"First Steps","title":"Create the Model and Simulation","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In Vahana, the term \"model\" is used in a somewhat unconventional way compared to other agent-based modeling frameworks.  In Vahana, a model created via create_model does not contain any rules about how the state of a simulation changes over time. Instead, a Vahana model is more akin to a specification of the possible state space - it defines the set of all possible graphs that can be created with the specified agent and edge types.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Think of a Vahana model as a blueprint or a schema. It outlines the structure of your simulation - what types of agents can exist, what types of relationships (edges) can exist between them, and what global parameters and variables are available. However, it doesn't dictate how these elements interact or evolve over time.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"A simulation, on the other hand, is a concrete realization within this state space. It's an actual graph with specific agents and edges, representing the current state of your simulated world at a given point in time.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Transition functions, which we'll define later, are the mechanisms that actually change the state of the simulation over time. These functions operate on the current state of the simulation (the current graph of agents and edges) and produce a new state by modifying agent attributes, creating or removing agents and edges, and updating global variables.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To create a model in Vahana, we use the create_model function. This function takes the ModelTypes object we've been building through our type registrations and parameter/globals definitions, and the name of the model:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"const model = create_model(modeltypes, \"Excess Demand\")","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Once we have a model, we can create a simulation based on that model using the create_simulation function:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"const sim = create_simulation(model)","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This function creates a new simulation instance based on our model. At this point, the simulation is empty - it doesn't contain any agents or edges yet. It's essentially a blank canvas ready for us to populate with agents and edges according to our model's specifications.","category":"page"},{"location":"tutorial1.html#Populating-the-Simulation","page":"First Steps","title":"Populating the Simulation","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"After creating our simulation, the next step is to populate it with agents and edges. Vahana provides add_agent!, add_agents!, add_edge!, and add_edges! functions for this purpose.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The add_agent! function returns an AgentID, while add_agents! returns a vector of AgentIDs. These identifiers are unique to each agent at the current state of the simulation.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In parallel simulations, the AgentID incorporates information about the process number to which the agent is assigned. Consequently, the ID may be modified if an agent is reassigned to a different process. In the current implementation of Vahana, agents only change processes during the finish_init! function. However, this design allows for potential future implementation of dynamic load balancing.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"It is also possible that the same AgentID is utilized multiple times for distinct agents. Consequently, an AgentID returned by a Vahana function call or passed as an argument to a callback function (refer to the Transition functions section below for more details) is only valid within a specific scope. This scope is limited to either the period before the finish_init! function is invoked or until the callback/transition function has completed its execution. After these points, the ID should not be considered reliable for further use or reference.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"If your model requires persistent identification of agents, you should implement this yourself by adding an ID field to your agent struct. You would then manage these IDs yourself, ensuring they remain constant throughout the simulation. When working with string-based identifiers or other string fields within a struct that need to be stored in an HDF5 file, please consult the documentation for the create_string_converter function. It is also important to note that the HDF5 format does not support 128-bit integers. Consequently, the UUID package is not compatible with the current version of HDF5.jl.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In our case, we use the IDs returned by add_agents! to iterate over all buyer IDs, randomly select numSellers seller IDs for each buyer ID, and then create edges between them in the KnownSeller network.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"We can see in the following code snippet also how parameters of the Simulation can be accessed via the param function.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"buyerids = add_agents!(sim, [ Buyer() for _ in 1:param(sim, :numBuyer)])\n\nsellerids = add_agents!(sim, [ Seller() for _ in 1:param(sim, :numSeller)])\n\nfor b in buyerids\n    for s in rand(sellerids, param(sim, :knownSellers))\n        add_edge!(sim, s, b, KnownSeller())\n    end\nend\n\nsim","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"As you can see from the result of the code block above, Vahana has \"pretty print\" functions for some of its data structures.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Finally, we call finish_init!. This crucial step completes the initialization process, setting up data structures and, in parallel simulations, distributing agents across processes.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"finish_init!(sim)","category":"page"},{"location":"tutorial1.html#Defining-Transition-Functions","page":"First Steps","title":"Defining Transition Functions","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In Vahana, transition functions define how your simulation evolves from one state to the next. They encapsulate the rules and behaviors of your agents, determining how agents interact, make decisions, and change their states. The transition function is called for each agent separately.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"A typical transition function in Vahana has the following signature:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"function transition_function(state, id, sim)\n    # Function body\n    return new_agent_state\nend","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"A transition function must have three parameters. The first represents the current state of the agent, allowing it to make decisions based on its own attributes and conditions. The second parameter is the temporary ID of the agent. This ID can be used within the transition function to access other elements of the graph that are visible to the agent via functions like edges or neighborstates. It's important to note that this ID should not be stored, as it may change between time steps.  Finally, there's sim, which is the simulation object. This provides access to the global state and parameters of the simulation. These three parameters together give the agent all the context it needs to determine its next state.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The first transition function we are implementing calculates the demand for the goods x and y.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This transition function is called for all Buyers. First, the neighborids function is used to get a vector that contains the (temporary) IDs all the sellers known by the actual buyer.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"One of the IDs of the sellers is selected using the rand function. For this seller, the state is accessed via the agentstate function. In cases where the type of the agent whose state we want to access is unknown, it's possible to use agentstate_flexible instead.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Then the agent calculates it's demand for the goods x and y, and adds an edge with the information about the demand to the Bought network, which is then used in the next transition function by the sellers to sum up the demand and calculate the new price.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"function calc_demand(b::Buyer, id, sim)\n    seller = rand(neighborids(sim, id, KnownSeller))\n    s = agentstate(sim, seller, Seller)\n    x = b.B * b.α\n    y = b.B * (1 - b.α) / s.p\n    add_edge!(sim, id, seller, Bought(x, y))\nend;\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In the calc_price transition function, sellers summarize all the goods x and y they sold. They do this by summing the state of all incoming Bought edges.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"If a seller hasn't made any sales (i.e., no incoming Bought edges exist), edgestates returns nothing, and the seller's state remains unchanged. Otherwise, edgestates returns a Vector containing the states of all relevant edges. We aggregate this vector using the reduce function, leveraging the previously defined + operator for Bought.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Finally, we construct a new seller state. The new price is calculated as q.y / q.x * s.p.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"function calc_price(s::Seller, id, sim)\n    sold = edgestates(sim, id, Bought)\n    if isnothing(sold)\n        return s\n    end\n    q = reduce(+, sold)\n    Seller(q.y / q.x * s.p, q.y)\nend;\nnothing #hide","category":"page"},{"location":"tutorial1.html#Applying-Transition-Functions","page":"First Steps","title":"Applying Transition Functions","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To apply these transition functions to the current state of a simulation, Vahana provides the apply! method. This method is the key mechanism for evolving the simulation state over time, executing our defined transition functions across the population of agents.  Let's examine its signature and behavior in more detail:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"apply!(sim, func, call, read, write; add_existing = [], with_edge = nothing)","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"sim is the simulation instance and func is the transition function to be applied to the simulation state.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The call argument in apply! specifies which agent types the transition function should be applied to. This can be either a single agent type or a collection of agent types. In most cases, as in our market model, call will contain only a single type. For example, when we apply calc_demand, we only want to call it for Buyer agents. However, Vahana allows for more complex scenarios where a single transition function can be applied to multiple agent types. This flexibility allows for more complex agent interactions and behaviors within a single transition function, which can be particularly useful in models where different types of agents share similar behaviors or decision-making processes.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The read argument must include all agent and edge state types that are accessed in the transition function. This is particularly important in parallel simulations, as it ensures that all necessary data is transmitted to the processes that need to access it. When Vahana's assertion system is active, it checks that only these specified types are accessed. However, if assertions are disabled via enable_asserts, forgetting to include a type in read can lead to incorrect results without raising an error. It's worth noting that while including unnecessary types in read doesn't cause errors, it can negatively impact performance.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"A noteworthy scenario occurs when the call type is excluded from the read set. In these instances, the transition function's first argument is altered. Rather than representing the agent state, it becomes a Value Type corresponding to the 'call' type. Consequently, the state of the agent for which the transition function is invoked becomes inaccessible within the function itself.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The write collection must contain all agent and edge state types that are modified in the transition function. Conceptually, one might think of the resulting graph after a transition as the union of all agents and edges returned by individual transition function calls. However, this approach would be inefficient, requiring the reconstruction of even stable parts of the graph. Instead, Vahana optimizes this process by removing only the parts of the graph specified in the write collection. This means you can only change the state of agents or edges of a type if you're also re-adding the state of constant elements of that type.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"But in cases where you want to add new elements (like additional edges) without modifying existing ones, you can use the optional add_existing keyword. This keyword takes a single or a collection of agent or edge state types. For all types in this collection, existing agents or edges will be preserved, even if the type is also in the write collection. This provides a flexible way to extend the graph without completely rebuilding it. But there is the restriction that agent types in add_existing can not be also in call.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The with_edge keyword restricts the application of the transition function to agents that are targets of a specified edge type. It's equivalent to manually checking for the presence of the edge for each agent before applying the function, but allows Vahana to optimize this operation internally. with_edge should only be used when a small proportion of agents have edges of the specified type. If most agents have this edge type, using with_edge may decrease performance compared to a manual check inside the transition function.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The implementation process, while seemingly complex, is quite straightforward in practice. Begin by crafting your transition function as previously demonstrated. Then, follow these steps:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Identify the agent types for which the transition function should be invoked and include these types in the call parameter.\nExamine the function calls, such as edgestates, to determine which types are utilized. Add these types to the read parameter.\nIf you access the first argument of the transition function (representing the agent's state), include that type in the read parameter as well.\nShould you intend to return a modified agent state, add that type to the write parameter.\nIf your function includes additional add_edge! or add_agent! calls, incorporate their respective types into the write parameter.\nBe aware that all existing agents and edges will be removed from the simulation unless their types are also specified in the add_existing parameter.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Following this schema we get for our transition functions","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"apply!(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSeller ], Bought);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"and","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"apply!(sim, calc_price, Seller, [ Seller, Bought ], Seller);\nnothing #hide","category":"page"},{"location":"tutorial1.html#Working-with-Globals","page":"First Steps","title":"Working with Globals","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To summarize the state of a simulation, Vahana uses the map-reduce combination from functional programming. First, a function is applied to each agent or edge state, and then the result is reduced using a binary function.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"E.g. to calculate the excess demand we write","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"mapreduce(sim, b -> b.x - b.y, +, Bought)","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The last argument of Vahana's mapreduce specifies the agent or edge type for which the aggregation should be performed. The anonymous function in the second position describes the assignment for each instance of that type. In this case, the function receives an edge of the 'Bought' type and calculates the additional quantity of good x that was purchased. This value is then summed across all edges of the specified type.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To calculate the average price we define a helper function","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"function calc_average_price(sim)\n    m = mapreduce(sim, s -> s.p * s.d_y, +, Seller)\n    q = mapreduce(sim, s -> s.d_y, +, Seller)\n    m / q\nend\n\ncalc_average_price(sim)","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"And now we have all elements to run the simulation, e.g. for 5 steps:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"for _ in 1:5\n    apply!(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSeller ], Bought)\n    push_global!(sim, :x_minus_y, mapreduce(sim, b -> b.x - b.y, +, Bought))\n    apply!(sim, calc_price, Seller, [ Seller, Bought ], Seller)\n    push_global!(sim, :p, calc_average_price(sim))\nend","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To get a resulting timeseries, we use the get_global function:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"get_global(sim, :p)","category":"page"},{"location":"tutorial1.html#Investigating-the-Simulation-State","page":"First Steps","title":"Investigating the Simulation State","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Vahana offers several methods to examine the current state of your simulation. For example, the user-defined show methods for the model and simulation instances, which provide a quick summary of your model/simulation:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"model","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"sim","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Vahana offers the show_agent function to inspect the state of individual agents. This function displays comprehensive information about a randomly selected agent of the specified type. Additionally, users have the option to specify a particular agent identifier if they wish to examine a specific agent. The show_agent function returns the identifier of the selected agent.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"show( #hide\nshow_agent(sim, Seller, 1)\n) #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"The show_agent function has an optional keyword argument, neighborstate, which enables the user to examine the state of neighboring agents. The neighborstate argument should be a vector of symbols representing the field names that should be displayed.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"show( #hide\nshow_agent(sim, Seller, 1; neighborstate = [ :B ])\n) #hide","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"As mentioned in the Agent and Edge Types section, all agent and edge types in Vahana must be of type bitstype. This has the usefull side effect that the state of the agents and edges can be nicely converted into a DataFrame.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"It is important to note that the DataFrame in a parallel simulation contains only the agents or edges of the process in which the function is called, and not those of the complete simulation. If the latter is required, all_agents or all_edges can be used.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"first(DataFrame(sim, Bought; types = true), 10)","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"To get the DataFrame for the Globals, we call the GlobalsDataFrame function for our sim. Be aware, that only global variable that are vectors are added to the DataFrame.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"GlobalsDataFrame(sim)","category":"page"},{"location":"tutorial1.html#Understanding-Vahana's-Edge-Structure","page":"First Steps","title":"Understanding Vahana's Edge Structure","text":"","category":"section"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"When we define edge types like KnownSeller or Bought, you might notice that these structs don't contain any information about the source or target agents of the edge. This is by design in Vahana, which uses a specific internal structure to represent edges efficiently.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Internally, Vahana declares a parametric type for edges:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"struct Edge{T}\n    from::AgentID\n    state::T\nend","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"In this structure, T is the type of our edge (like KnownSeller or Bought), and from is the ID of the agent at the source of the edge. You might wonder why there's no to field for the target agent. The reason lies in how Vahana stores these edges.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Vahana uses container structures (like dictionaries) to store edges. The exact type of container depends on certain optimization hints (see Edge Hints for more details), but a typical structure might look like this:","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"Dict{AgentID, Vector{Edge{T}}}","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This design means that the target agent's ID is implicitly stored as the dictionary key. Adding it to the Edge struct would be redundant and would unnecessarily consume memory and CPU cycles. As a user of Vahana, you don't need to interact with this internal structure directly, but understanding it can help you design more efficient models and better understand how Vahana works under the hood.","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"","category":"page"},{"location":"tutorial1.html","page":"First Steps","title":"First Steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = Vahana -->","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Vahana.jl is an open-source high-performance software framework for the development of large-scale agent-based models (ABM) of complex social systems. Vahana is based on a discrete dynamical systems formulation referred to as a synchronous graph dynamical system (SyGDS)[1], which is a generalization of cellular automata (CA). In a CA the cells can be interpreted as the agents, and when a cell/agent updates its state according to a rule, the new state depends only on the current state of the cell and the states of the cells in its neighborhood.  In a SyGDS, the vertices of the graph are the agents of the model, and the (directed) edges determine the neighborhood.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Vahana extends the SyGDSs concept so that even complex models like the Mobility Transition Model (https://github.com/CoeGSS-Project/motmo) or MATSim Episim (https://github.com/matsim-org/matsim-episim-libs) can be expressed as a SyGDS. The vertices are representing the agents and may be of different types and have a state that belongs to a type-specific state space.  Edges between the agents are directed, if a transition of agent a depends on the state of agent b, an edge from b to a is needed. Edges may also have different types (represent different kinds of interactions) and may have also a state.  There can be multiple transition functions (which are the equivalent of a rule in a CA), and each transition function can act on a different subgraph.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Discrete) spatial information can be added using Vahana functions that insert grid cells as nodes in the graph and have access to a mapping from the Cartesian index of the underlaying space to the corresponding node. Since the cells are vertices of the graph, they can be treated in the same way as other agents","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To model the system's dynamic evolution, we consider discrete time steps. At each step t, there is a set of vertices which can change their own state and also add new vertices and edges.  The new state of a node at time t is computed based only on information from the previous step.  Information from step t-1 usually includes the previous state of the agent itself, and may include states of adjacent agents in the graph, possibly also the states of the respective edges themselves. The underlying idea is that of a functional programming approach: the transition cannot be implicitly affected by any other mutable state or unintended side effects.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"So expressing a model as a SyGDS has the advantage that a single simulation can be computed in parallel. Vahana therefore allows the simulation to be distributed across multiple nodes of a computer cluster, enabling the simulation of large-scale models that do not fit on a single node.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Parallelization is done through the Message Passing Interface (via the MPI.jl package), but this is hidden to the user. Any model developed with Vahana can be automatically computed in parallel by simply starting the simulation via mpirun. The challenge for the user is mainly to think about how to express the model as a SyGDS, rather than thinking about technical details of the implementation such as which data structure is best to use.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"In addition to this documentation, Fürst et al. (2024)[2] provides a comprehensive discussion of the SyGDS extension for Vahana.jl. It also includes two case studies and performance analyses.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: Adiga, A., Kuhlman, C.J., Marathe, M.V. et al. Graphical dynamical systems and their applications to bio-social systems. https://doi.org/10.1007/s12572-018-0237-6","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: Fürst, S., Conrad, T., Jaeger, C., & Wolf, S. (2024). Vahana.jl - A framework (not only) for large-scale agent-based models. arXiv:2406.14441. https://doi.org/10.48550/arXiv.2406.14441","category":"page"}]
}
