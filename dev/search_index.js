var documenterSearchIndex = {"docs":
[{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"CurrentModule = Vahana","category":"page"},{"location":"global.html#Update-Globals-and-Rasters","page":"Global Layer","title":"Update Globals and Rasters","text":"","category":"section"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"There is also some part of the simulation state that can not be changed inside a transition functions and should be therefore modified between two refapply! calls, namly the globals and rasters.","category":"page"},{"location":"global.html#Globals","page":"Global Layer","title":"Globals","text":"","category":"section"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"You can add a new or additional value to the globals struct with:","category":"page"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"set_global!\npush_global!\nVahana.mapreduce","category":"page"},{"location":"global.html#Vahana.set_global!","page":"Global Layer","title":"Vahana.set_global!","text":"set_global!(sim::Simulation, name, value)\n\nSet the value of the field name of the globals struct for simulation sim.\n\nset_global! must not be called within a transition function. \n\nSee also create_simulation, mapreduce, push_global! and get_global\n\n\n\n\n\n","category":"function"},{"location":"global.html#Vahana.push_global!","page":"Global Layer","title":"Vahana.push_global!","text":"push_global!(sim::Simulation, name, value)\n\nIn the case that a field of the globals struct from the Simulation constructor is a vector (e.g. for time series data), push_global! can be used to add a value to this vector, instead of writing set_global!(sim, name, push!(get_global(sim, name), value).\n\npush_global! must not be called within a transition function. \n\nSee also create_model, mapreduce, set_global! and get_global\n\n\n\n\n\n","category":"function"},{"location":"global.html#Base.mapreduce","page":"Global Layer","title":"Base.mapreduce","text":"mapreduce(sim, f, op, ::Type{T}; [kwargs ...])\n\nCalculate an aggregated value, based on the state of all agents or edges of type T.\n\nf is applied to all of these agents or edges and then op is used to reduce (aggregate) the values returned by f.\n\nmapreduce is calling Base.mapreduce, f, op and kwargs are passed directly to mapreduce, while sim and T are used to determine the iterator.\n\n\n\n\n\n","category":"function"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"warning: Warning\nThe state of the globals struct (the globals argument of the  create_simulation function, and of rasters can not be changed  inside of a transition function, as a transition function is calculated on a per agent basis with many evaluations in parallel, and changes to the global layer must be a single, synchronized operation.","category":"page"},{"location":"global.html#Raster","page":"Global Layer","title":"Raster","text":"","category":"section"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"Even if it looks like rasters are just nodes in the graph, and the type of those nodes must be registered like the types of agents via register_agenttype!, they have a special property: In a parallel simulation the state of the raster nodes are synchronized, so that the complete state of a raster is available on all ranks.  ","category":"page"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"So to update the values of a raster, you can use one of the following functions:","category":"page"},{"location":"global.html","page":"Global Layer","title":"Global Layer","text":"calc_raster\ncalc_rasterstate","category":"page"},{"location":"global.html#Vahana.calc_raster","page":"Global Layer","title":"Vahana.calc_raster","text":"calc_raster(sim, raster::Symbol, f, f_returns::DataType, accessible::Vector{DataType})\n\nCalculate values for the raster raster by applying f to each cell ID of the cells constructed by the add_raster! function.\n\nf_returns must be the type returned by the function f. There must be an implementation of the zero function for this type, and zero(returntype) | f(id) must be equal to f(id).\n\naccessible is a vector of Agent and/or Edge types. This vector must list all types that are accessed directly (e.g. via agentstate or indirectly (e.g. via neighborstates in the transition function.\n\nIf the results of calc_raster depend only on the state of the cells (as in the following example) and all cells have the same type, calc_rasterstate can be used as concise alternatives.\n\nReturns a n-dimensional array (with the same dimensions as raster) with those values.\n\nExample:\n\nThe following code from a \"Game of Life\" implementation generates a boolean matrix indicating which cells are alive (and therefore maps the internal graph structure to the usual representation of a cellular automaton):\n\n    calc_raster(sim, :raster, id -> agentstate(sim, id, Cell).active, Bool, [ Cell ]) \n\nCan be only called after finish_init!.\n\nSee also add_raster! and calc_rasterstate\n\n\n\n\n\n","category":"function"},{"location":"global.html#Vahana.calc_rasterstate","page":"Global Layer","title":"Vahana.calc_rasterstate","text":"calc_rasterstate(sim, raster::Symbol, f, f_returns::DataType, ::Type{T})\n\nCombined calc_raster with agentstate for the cells of the raster.\n\nCalculate values for the raster raster by applying f to the state of each cell.\n\nf_returns must be the type returned by the function f. There must be an implementation of the zero function for this type, and zero(returntype) | f(state) must be equal to f(state).\n\nReturns a n-dimensional array (with the same dimensions as raster) with those values.\n\nExample:\n\nInstead of\n\n    calc_raster(sim, :raster, id -> agentstate(sim, id, Cell).active, Bool, [ Cell ]) \n\nit also possible to just write\n\n    calc_rasterstate(sim, :raster, c -> c.active, Bool, Cell)\n\nCan be only called after finish_init!.\n\nSee also add_raster! and calc_rasterstate\n\n\n\n\n\n","category":"function"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"EditURL = \"../examples/predator.jl\"","category":"page"},{"location":"predator.html#Predator/Prey-Model","page":"Predator / Prey","title":"Predator/Prey Model","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"This example shows how spatial information can be integrated into a model. In its current version, Vahana is not the ideal tool for models that depend mainly on the movement of agents, but as shown here, it is still possible, even though we are actually only working with graphs.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The model is based on the Predator-Prey for High-Performance Computing (PPHPC) model. In PPHPC the agents move randomly, in our implementation the prey move to locations with grass (if one is in sight) and the predators move to locations with prey to demonstrate how features like this can be implemented in Vahana.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"using CairoMakie\n\nusing Vahana\n\nusing Random\n\nRandom.seed!(1); #hide\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We want to run the model with optimized performance, see Performance Tuning for details.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"detect_stateless(true)\n\nenable_asserts(false);\nnothing #hide","category":"page"},{"location":"predator.html#AgentTypes","page":"Predator / Prey","title":"AgentTypes","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Beside the predator and the prey we also have the grid cells, which represent the spatial environment but are also implemented as agents and thus as nodes of the graph.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"struct Predator\n    energy::Int64\n    pos::CartesianIndex{2}\nend\n\nstruct Prey\n    energy::Int64\n    pos::CartesianIndex{2}\nend\n\nstruct Cell\n    pos::CartesianIndex{2}\n    countdown::Int64\nend","category":"page"},{"location":"predator.html#Edges","page":"Predator / Prey","title":"Edges","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"All agents have their position as part of their state, but a cell can only \"see\" the animals if they are connected to the cell via an edge. Vahana supports the creation of such edges via the move_to! function.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Prey/PredatorPosition are edges from the prey/predator to the cell. We use two different types (and not just one type Position) because this allows the cell to differentiate between prey or predators by the type of the edges.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"struct PreyPosition end\n\nstruct PredatorPosition end","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"PreyView and PredatorView are edges from the cells to the prey and predator respectively. These edges represent the cells that are visible to a prey or predator so that, for example, it is possible to check which cell in the visible area contains food.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"struct PreyView end\n\nstruct PredatorView end","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"VisiblePrey are edges from prey to predator. So far, all edge types connect animals to cells, and without an incoming edge from a prey, a predator don't know anything about the prey positions. The VisiblePrey edges are created by the cells through the find_prey transition function, as the cells know which Prey is directly on the cell via the PreyPosition edges and therefore in the view of an predator via the PredatorView edges.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"struct VisiblePrey end","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The last two edge types are messages to inform the agents that they must die or found something to eat.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"struct Die end\n\nstruct Eat end","category":"page"},{"location":"predator.html#Params","page":"Predator / Prey","title":"Params","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We follow the parameter structure from the PPHPC model, but use the same parameters for Prey and Predator for the example run.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Base.@kwdef struct SpeciesParams\n    gain_from_food::Int64 = 5\n    loss_per_turn::Int64 = 1\n    repro_thres::Int64 = 5\n    repro_prob::Int64 = 20\nend\n\nBase.@kwdef struct AllParams\n    raster_size::Tuple{Int64, Int64} = (100, 100)\n    restart::Int64 = 5\n    predator::SpeciesParams = SpeciesParams()\n    prey::SpeciesParams = SpeciesParams()\n    num_predators::Int64 = 500\n    num_prey::Int64 = 2000\nend;\nnothing #hide","category":"page"},{"location":"predator.html#Globals","page":"Predator / Prey","title":"Globals","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We are creating timeseries (in form of Vectors) for the predator and prey population, the number of cells with food and the average energy of the predators and prey.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Base.@kwdef mutable struct PPGlobals\n    predator_pop = Vector{Int64}()\n    prey_pop = Vector{Int64}()\n    cells_with_food = Vector{Int64}()\n    mean_predator_energy = Vector{Float64}()\n    mean_prey_energy = Vector{Float64}()\nend;\nnothing #hide","category":"page"},{"location":"predator.html#Create-the-Simulation","page":"Predator / Prey","title":"Create the Simulation","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We have now defined all the Julia structs needed to create the model and a simulation. We also add some hints to some edgetypes, mainly for performance reasons.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"const ppsim = ModelTypes() |>\n    register_agenttype!(Predator) |>\n    register_agenttype!(Prey) |>\n    register_agenttype!(Cell) |>\n    register_edgetype!(PredatorPosition, :SingleType; target = Cell) |>\n    register_edgetype!(PreyPosition, :SingleType; target = Cell) |>\n    register_edgetype!(PredatorView) |>\n    register_edgetype!(PreyView) |>\n    register_edgetype!(VisiblePrey, :SingleType; target = Predator) |>\n    register_edgetype!(Die, :HasEdgeOnly) |>\n    register_edgetype!(Eat, :HasEdgeOnly) |>\n    create_model(\"Predator Prey\") |>\n    create_simulation(AllParams(), PPGlobals())","category":"page"},{"location":"predator.html#Initialization","page":"Predator / Prey","title":"Initialization","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"First we add the Cells to the Simulation. Therefore we define a constructor functions for the cells. There is a 50% probability that a cell contains food (and in this case countdown is 0).","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"init_cell(pos::CartesianIndex) =\n    Cell(pos, rand() < 0.5 ? 0 : rand(1:param(ppsim, :restart)))\n\nadd_raster!(ppsim, :raster, param(ppsim, :raster_size), init_cell)","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Predator and Pray are starting on a random position.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function random_pos(sim)\n    size = param(sim, :raster_size)\n    CartesianIndex(rand(1:size[1]), rand(1:size[2]))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We define two helper functions to move an animal to a new position. This will add a single (pos)edge from the animal to the cell at the newpos position, and for all cells in the manhatten distance of 1 also (view)edges from those cell to the animal and from the animal to the cell.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function move!(sim, id, newpos, posedge, viewedge)\n    move_to!(sim, :raster, id, newpos, nothing, posedge)\n    move_to!(sim, :raster, id, newpos, viewedge, viewedge;\n             distance = 1, metric = :manhatten)\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Now we can add the Predator and Pray to the simulation, and use the move! function to create also the position and view edges.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"energyrange = 1:(2*param(ppsim, :prey).gain_from_food)\nforeach(1:param(ppsim, :num_prey)) do _\n    energy = rand(energyrange)\n    pos = random_pos(ppsim)\n    id = add_agent!(ppsim, Prey(energy, pos))\n    move!(ppsim, id, pos, PreyPosition(), PreyView())\nend\n\nenergyrange = 1:(2*param(ppsim, :predator).gain_from_food)\nforeach(1:param(ppsim, :num_predators)) do _\n    energy = rand(energyrange)\n    pos = random_pos(ppsim)\n    id = add_agent!(ppsim, Predator(energy, pos))\n    move!(ppsim, id, pos, PredatorPosition(), PredatorView())\nend","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"At the end of the initialization phase we have to call finish_init!","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"finish_init!(ppsim)","category":"page"},{"location":"predator.html#Transition-Functions","page":"Predator / Prey","title":"Transition Functions","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"As mentioned in the comment for the PredatorView, the cells are responsible to connect the Prey with the Predators. So each cell iterate over each prey on the cell and add edges to all predators the can view the cell.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"It may seem strange that the transition function does not return the state of the cell. The apply! method has the keyword argument invariant_compute, if this is set to true as we do this later when we call find_prey, Vahana knows that the state of the agents being called will not be change and the return values of the transition functions are ignored.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function find_prey(_, id, sim)\n    checked(foreach, neighborids(sim, id, PreyPosition)) do preyid\n        checked(foreach, neighborids(sim, id, PredatorView)) do predid\n            add_edge!(sim, preyid, predid, VisiblePrey())\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"If a predator has enough energy left to move and there is a prey in the predator's field of view, a random prey is selected and its position is used as the new position. If no prey is visible, a random cell in the predator's field of view is selected as the new position.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"If there is not enough energy left, the transition function returns nothing, which means that the predator dies and is no longer part of the graph.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function move(state::Predator, id, sim)\n    e = state.energy - param(sim, :predator).loss_per_turn\n    if e > 0\n        # we need to access the pos of the prey which is part of it's state\n        prey = neighborstates(sim, id, VisiblePrey, Prey)\n        newpos = if isnothing(prey)\n            nextcellid = rand(neighborids(sim, id, PredatorView))\n            agentstate(sim, nextcellid, Cell).pos\n        else\n            rand(prey).pos\n        end\n        move!(sim, id, newpos, PredatorPosition(), PredatorView())\n        Predator(e, newpos)\n    else\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The difference in the movement of the prey compared to the movement of the predator is that the prey is looking for cells with grass instead of prey. In the PPHPC model implemented here, grass is available when the countdown field of a cell is equal to 0.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function move(state::Prey, id, sim)\n    e = state.energy - param(sim, :prey).loss_per_turn\n    if e > 0\n        withgrass = filter(neighborids(sim, id, PreyView)) do id\n            agentstate(sim, id, Cell).countdown == 0\n        end\n        nextcellid = if length(withgrass) == 0\n            rand(neighborids(sim, id, PreyView))\n        else\n            rand(withgrass)\n        end\n        newpos = agentstate(sim, nextcellid, Cell).pos\n        move!(sim, id, newpos, PreyPosition(), PreyView())\n        Prey(e, newpos)\n    else\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"If a cell has no grass and the countdown field is therefore > 0, the countdown is decreased by 1.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function grow_food(state::Cell, _, _)\n    Cell(state.pos, max(state.countdown - 1, 0))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"In the try_eat transition function, each cell checks whether predator and prey are on the cell at the same time. In this case, the cell generates random matches between predator and prey, wherby each prey is selected only once at most (only one predator can eat a single prey, and each predator eat not more then one prey).","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"For these matches, Die edges are generated from the cell to the prey and Eat edges are generated from the cell to the predator. Since it is not important for the model at which location a prey animal was eaten, the Die and Eat edgetypes have the property :HasEdgeOnly.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"If prey on the cell has survived and the cell contains grass (countdown == 0), an Eat edge is created with one of the surviving prey as the target.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function try_eat(state::Cell, id, sim)\n    predators = neighborids(sim, id, PredatorPosition)\n    prey = neighborids(sim, id, PreyPosition)\n\n    # first the predators eat the prey, in case that both are on the cell\n    if ! isnothing(predators) && ! isnothing(prey)\n        prey = Set(prey)\n        for pred in shuffle(predators)\n            if length(prey) > 0\n                p = rand(prey)\n                add_edge!(sim, id, p, Die())\n                add_edge!(sim, id, pred, Eat())\n                delete!(prey, p)\n            end\n        end\n    end\n\n    # then check if there is prey left that can eat the grass\n    if  ! isnothing(prey) && length(prey) > 0 && state.countdown == 0\n        add_edge!(sim, id, rand(prey), Eat())\n        Cell(state.pos, param(sim, :restart))\n    else\n        state\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The reproduction rule for predator and prey is almost the same, so we first define a function that can be used for both species. In this function we first check if the animal found something to eat. In this case on of the previous transition functions did create a edge of typ Eat with the animal as target, so we can use the has_edge function to check if this is the case.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"If the energy of the animal is above the threshold given as parameter, an offspring is added to the simulation via the add_agent call and the offspring is also moved it to the same position as its parent.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function try_reproduce_imp(state, id, sim, C, posedge, viewedge, species_params)\n    if has_edge(sim, id, Eat)\n        state = C(state.energy + species_params.gain_from_food, state.pos)\n    end\n    if state.energy > species_params.repro_thres &&\n        rand() * 100 < species_params.repro_prob\n\n        energy_offspring = Int64(round(state.energy / 2))\n        newid = add_agent!(sim, C(energy_offspring, state.pos))\n        move!(sim, newid, state.pos, posedge, viewedge)\n        C(state.energy - energy_offspring, state.pos)\n    else\n        state\n    end\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"For the Predator we can just call the reproduce function with the necessary arguments.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"try_reproduce(state::Predator, id, sim) =\n    try_reproduce_imp(state, id, sim, Predator,\n                    PredatorPosition(), PredatorView(), param(sim, :predator))","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The prey animal needs an extra step because it might have been eaten by a predator. So we check if there is a Die edge leading to the prey animal, and if so, the prey animal is removed from the simulation (by returning nothing). Otherwise, we again just call the reproduce function defined above.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function try_reproduce(state::Prey, id, sim)\n    if has_edge(sim, id, Die)\n        return nothing\n    end\n    try_reproduce_imp(state, id, sim, Prey,\n                    PreyPosition(), PreyView(), param(sim, :prey))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We update the global values and use the mapreduce method to count the population and the number of cells with food. Based on the values, we can then also calculate the mean energy values.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function update_globals(sim)\n    push_global!(sim, :predator_pop, mapreduce(sim, _ -> 1, +, Predator; init = 0))\n    push_global!(sim, :prey_pop, mapreduce(sim, _ -> 1, +, Prey; init = 0))\n    push_global!(sim, :cells_with_food,\n                mapreduce(sim, c -> c.countdown == 0, +, Cell))\n    push_global!(sim, :mean_predator_energy,\n                mapreduce(sim, p -> p.energy, +, Predator; init = 0) /\n                    last(get_global(sim, :predator_pop)))\n    push_global!(sim, :mean_prey_energy,\n                mapreduce(sim, p -> p.energy, +, Prey; init = 0) /\n                    last(get_global(sim, :prey_pop)))\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"We add to our time series the initialzation values.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"update_globals(ppsim);\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"And finally we define in which order our transitions functions are called. Worth mentioning here are the keyword arguments in find_prey and try_reproduce. In the find_prey transition the state of the cell itself does not change, it only creates VisiblePrey edges. By invariant_compute = true Vahana knows that the state of the cells are constant with respect to this transition function.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"The addexisting keyword in the tryreproduce transition function signify that the currently existing position and view edges should not be removed, and only additional edges should be added, in our case the position of the potential offspring.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function step!(sim)\n    apply!(sim, move,\n           [ Prey ],\n           [ Prey, PreyView, Cell ],\n           [ Prey, PreyView, PreyPosition ])\n\n    apply!(sim, find_prey,\n           [ Cell ],\n           [ PreyPosition, PredatorView ],\n           [ VisiblePrey ])\n\n    apply!(sim, move,\n           [ Predator ],\n           [ Predator, PredatorView, Cell, Prey, VisiblePrey ],\n           [ Predator, PredatorView, PredatorPosition ])\n\n    apply!(sim, grow_food, Cell, Cell, Cell)\n\n    apply!(sim, try_eat,\n           [ Cell ],\n           [ Cell, PredatorPosition, PreyPosition ],\n           [ Cell, Die, Eat ])\n\n    apply!(sim, try_reproduce,\n           [ Predator, Prey ],\n           [ Predator, Prey, Die, Eat ],\n           [ Predator, Prey, PredatorPosition, PreyPosition, PredatorView, PreyView ];\n           add_existing = [ PredatorPosition, PreyPosition,\n                                       PredatorView, PreyView ])\n\n    update_globals(sim)\nend;\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Now we can run the simulation","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"for _ in 1:400 step!(ppsim) end","category":"page"},{"location":"predator.html#Plots","page":"Predator / Prey","title":"Plots","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"To visualize the results we use the Makie package.","category":"page"},{"location":"predator.html#Time-series","page":"Predator / Prey","title":"Time series","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"First we create a linechart for the time series stored in the global state. For this purpose Vahana offers the function plot_globals. Since This function returns not only the Makie Figure itself, but also the Axis and Plots, so that the result can be processed further. If the default result is displayed, the Julia function first can be used to extract the mapping from the returned tuple.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"plot_globals(ppsim, [ :predator_pop, :prey_pop, :cells_with_food ]) |> first","category":"page"},{"location":"predator.html#Spatial-distribution","page":"Predator / Prey","title":"Spatial distribution","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"To visualize the spatial information we can use heatmap in combination with the function calc_raster of Vahana. E.g. the number of PreyPosition or PredatorPosition edges connected to an edge give us the number of Prey/Predator currently on that cell.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"Note that the function name num_edges can be confusing when it appears in conjunction with grids. In Vahana, neighbors are always neighbors in a graph, so in our specific case, the neighbors of a cell in the Predator/PreyPosition network are the Predators/Prey that are exactly on the cell, and not in the spatial neighborhood of the cell. Only in the case when a network is constructed with the function connect_raster_neighbors! the neighborhood of the nodes in the network coincides with a spatial neighborhood.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"It would be nice to have a colorbar for the heatmaps so we define a small helper function that can be used in a pipe.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"function add_colorbar(hm)\n    Makie.Colorbar(hm.figure[:,2], hm.plot)\n    hm\nend;\nnothing #hide","category":"page"},{"location":"predator.html#Predators-Positions","page":"Predator / Prey","title":"Predators Positions","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"calc_raster(ppsim, :raster, Int64, [ PredatorPosition ]) do id\n    num_edges(ppsim, id, PredatorPosition)\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html#Prey-Positions","page":"Predator / Prey","title":"Prey Positions","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"calc_raster(ppsim, :raster, Int64, [ PreyPosition ]) do id\n    num_edges(ppsim, id, PreyPosition)\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html#Cells-that-contains-food","page":"Predator / Prey","title":"Cells that contains food","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"calc_raster(ppsim, :raster, Int64, [ Cell ]) do id\n    agentstate(ppsim, id, Cell).countdown == 0\nend |> heatmap |> add_colorbar","category":"page"},{"location":"predator.html#Finish-the-simulation","page":"Predator / Prey","title":"Finish the simulation","text":"","category":"section"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"As always, it is important to call finish_simulation at the end of the simulation to avoid memory leaks.","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"finish_simulation!(ppsim);\nnothing #hide","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"","category":"page"},{"location":"predator.html","page":"Predator / Prey","title":"Predator / Prey","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"EditURL = \"../examples/hegselmann.jl\"","category":"page"},{"location":"hegselmann.html#Opinion-Model","page":"Opinion Model","title":"Opinion Model","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"In this example we demonstrate how we can use the Graphs.jl package to add graphs from other sources (or created by the Graphs.jl package itself) to a Vahana simulation.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"For this, we implement a simple version of the Hegselmann and Krause (2002) opinion dynamics model. An alternative implementation of the same model using the Agents.jl package can be found here.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"using Vahana, Statistics","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We have a finite number n of agents, where the state of the agents are a real number x_i(t) in the [0,1] interval which represents the opinion of that agent.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"struct HKAgent\n    opinion::Float64\nend","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"This time we also have only one network that determine the agents that will be considered when an agent updates its opinion.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"struct Knows end","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"There is a confidence bound epsilon  0, opinions with a difference greater then epsilon are ignored by the agents in the transition function. All agents have the same confidence bound, so we introduce this bound as a parameter.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"struct HKParams\n    ε::Float64\nend","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We have now all elements to create an uninitialized simulation.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"const hkmodel = ModelTypes() |>\n    register_agenttype!(HKAgent) |>\n    register_edgetype!(Knows) |>\n    create_model(\"Hegselmann-Krause\");\nnothing #hide","category":"page"},{"location":"hegselmann.html#Add-the-graph","page":"Opinion Model","title":"Add the graph","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Vahana allows to add SimpleGraphs and SimpleDiGraphs from the Graphs.jl package via the add_graph! function. So it's possible to use e.g. SNAPDatasets to run the opinion model on real datasets. Or the SimpleGraphs module from Graphs.jl to create synthetic graphs.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We show here for both use cases one example and are creating for each one an own simulation","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"const cgsim = create_simulation(hkmodel, HKParams(0.2), nothing);\nconst snapsim = create_simulation(hkmodel, HKParams(0.2), nothing)","category":"page"},{"location":"hegselmann.html#SimpleGraphs","page":"Opinion Model","title":"SimpleGraphs","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"First we will show how we can add a synthetic graph. For this we need to import the SimpleGraphs module. Since there are many functions in the Graphs.jl package with the same name as in Vahana (e.g. add_edge!) it is advisable to import only the needed parts of Graphs.jl instead of loading the whole package via using Graphs.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"import Graphs.SimpleGraphs","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We want to add a complete graph, where each agent is connected with all the other agents, like in the Agents.jl implementation. We can create such a graph via SimpleGraphs.complete_graph.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"g = SimpleGraphs.complete_graph(50)","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Vahana needs the information how to convert the nodes and edges of the SimpleGraphs object to the Vahana structure, this is done by the constructor functions in the third and forth arguments of add_graph!. We do not need the Graph.vertex and Graph.edge arguments of this constructor functions, but for other use cases e.g. for bipartite graphs, it would be possible to create agents of different types depending on this information.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"const agentids = add_graph!(cgsim,\n                            g,\n                            _ -> HKAgent(rand()),\n                            _ -> Knows());\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Each agent also adds its own opinion to the calculation. We can use the ids returned by the add_graph! functions for this.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"foreach(id -> add_edge!(cgsim, id, id, Knows()), agentids)\n\nfinish_init!(cgsim)","category":"page"},{"location":"hegselmann.html#SNAPDataset.jl","page":"Opinion Model","title":"SNAPDataset.jl","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"The SNAPDataset.jl package deliver Graphs.jl formatted datasets from the Stanford Large Network Dataset Collection.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"using SNAPDatasets","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"With this package we can use the loadsnap function to create the graph that is then added to the Vahana graph, e.g. in our example the facebook dataset.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"const snapids = add_graph!(snapsim,\n                           loadsnap(:facebook_combined),\n                           _ -> HKAgent(rand()),\n                           _ -> Knows());\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Again each agent also adds its own opinion to the calculation.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"foreach(id -> add_edge!(snapsim, id, id, Knows()), snapids)\n\nfinish_init!(snapsim)","category":"page"},{"location":"hegselmann.html#Transition-Function","page":"Opinion Model","title":"Transition Function","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Opinions are updated synchronously according to","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"beginaligned\nx_i(t+1) = frac1 mathcalN_i(t)  sum_j in mathcalN_i(t) x_j(t)\ntextrmwhere  quad mathcalN_i(t) =  j   x_j(t) - x_i(t)  leq epsilon \nendaligned","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"So we first filter all agents from the neighbors with an opinion outside of the confidence bound, and then calculate the mean of the opinions of the remaining agents. As we have","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"function step(agent, id, sim)\n    ε = param(sim, :ε)\n\n    opinions = map(a -> a.opinion, neighborstates(sim, id, Knows, HKAgent))\n\n    accepted = filter(opinions) do opinion\n        abs(opinion - agent.opinion) < ε\n    end\n\n    HKAgent(mean(accepted))\nend;\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We can now apply the transition function to the complete graph simulation","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"apply!(cgsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Or to our facebook dataset","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"apply!(snapsim, step, HKAgent, [ HKAgent, Knows ], HKAgent)","category":"page"},{"location":"hegselmann.html#Create-plots","page":"Opinion Model","title":"Create plots","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Finally, we show the visualization possibilities for graphs, and import the necessary packages for this and create a colormap for the nodes.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"import CairoMakie, GraphMakie, NetworkLayout, Colors, Graphs, Makie","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Since the full graph is very cluttered and the Facebook dataset is too large, we construct a Clique graph using Graphs.jl.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"const cysim = create_simulation(hkmodel, HKParams(0.25), nothing);\nconst cyids = add_graph!(cysim,\n                         SimpleGraphs.clique_graph(7, 8),\n                         _ -> HKAgent(rand()),\n                         _ -> Knows());\n\n\nforeach(id -> add_edge!(cysim, id, id, Knows()), cyids)\n\nfinish_init!(cysim);\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Vahana implements an interactive plot function based on GraphMakie, where agents and edges are given different colors per type by default, and the state of each agent/edge is displayed via mouse hover actions.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"vp = create_graphplot(cysim)\n\nfigure(vp)","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"To modify the created plot, the Makie figure, axis and plot, can be accessed via the methods figure, axis and plot. This allows us to modify the graph layout and to remove the decorations.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"Vahana.plot(vp).layout = NetworkLayout.Stress()\n\nMakie.hidedecorations!(axis(vp))\n\nfigure(vp)","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We want that nodes to show the agent's opinion. Instead of modifing the Makie plot node_color property directly, it's also possible to define a helper functions with methods for the different agent and edge types, that are called by create_graphplot to determine properties of the nodes and edges of the plot and also supports interactive plot in the case that GLMakie is used as Makie backend. For details please check create_graphplot.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We define such a function and are calling it modifyvis, and will set the `updatefnkeyword ofcreate_graphplot` to this function.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"colors = Colors.range(Colors.colorant\"red\", stop=Colors.colorant\"green\", length=100)\n\n\nmodify_vis(state::HKAgent, _ ,_) = Dict(:node_color => colors[state.opinion * 100 |> ceil |> Int],\n                                       :node_size => 15)\n\nmodify_vis(_::Knows, _, _, _) = Dict(:edge_color => :lightgrey,\n                                     :edge_width => 0.5);\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"We are using a helper function to modify the node colors to indicate the agent's opinion and add a color bar to the plot.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"function plot_opinion(sim)\n    vp = create_graphplot(cysim,\n                          update_fn = modify_vis)\n    Vahana.plot(vp).layout = NetworkLayout.Stress()\n    Makie.hidedecorations!(axis(vp))\n    Makie.Colorbar(figure(vp)[:, 2]; colormap = colors)\n    figure(vp)\nend;\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"And now we can plot the initial state","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"plot_opinion(cysim)","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"And then the state after 500 iterations","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"for _ in 1:500\n    apply!(cysim, step, [ HKAgent ], [ HKAgent, Knows ], [ HKAgent ])\nend\n\nplot_opinion(cysim)","category":"page"},{"location":"hegselmann.html#Finish-the-simulation","page":"Opinion Model","title":"Finish the simulation","text":"","category":"section"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"As always, it is important to call finish_simulation at the end of the simulation to avoid memory leaks.","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"finish_simulation!(cysim);\nnothing #hide","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"","category":"page"},{"location":"hegselmann.html","page":"Opinion Model","title":"Opinion Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"CurrentModule = Vahana","category":"page"},{"location":"config.html#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"The following functions allows to configure Vahana's behaviour:","category":"page"},{"location":"config.html","page":"Configuration","title":"Configuration","text":"enable_asserts\nsuppress_warnings\ndetect_stateless\nset_compression","category":"page"},{"location":"config.html#Vahana.enable_asserts","page":"Configuration","title":"Vahana.enable_asserts","text":"enable_asserts(enable::Bool)\n\nVahana comes with some internal consistency checks, at the cost of run-time performance (e.g., in agentstate there are checks that the specified agenttype matches the agent's ID, which creates of course some overhead). The assertions that could degrade the run performance can be disabled by calling enable_asssertions(false).\n\nThe recommended approach is therefore to leave the assertions enabled during the development of the model, but to disable them when the model goes \"into production\", e.g. before the start of a parameter space exploration.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.suppress_warnings","page":"Configuration","title":"Vahana.suppress_warnings","text":"suppress_warnings(suppress::Bool)\n\nIn some cases Vahana print some hints or warnings to the stdout. This can be suppressed by calling the suppress_warnings(true) function after importing Vahana.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.detect_stateless","page":"Configuration","title":"Vahana.detect_stateless","text":"detect_stateless(detect::Bool)\n\nPer default, Vahana expects that the :Stateless hint is set manually.\n\nThis design decision was made so as not to confuse users, since then, for example, the edges is not available.\n\nThis behaviour can be customized by calling detect_stateless before calling register_edgetype!.\n\n\n\n\n\n","category":"function"},{"location":"config.html#Vahana.set_compression","page":"Configuration","title":"Vahana.set_compression","text":"set_compression(level::Int, parallel_hdf5_compression = false)\n\nSet the compression level of HDF5 files. \n\nHowever, by default, HDF5 datasets are not compressed when the used HDF5 library supports Parallel HDF5 due to encountered issues. While the necessary code to compress datasets in the Parallel HDF5 case is implemented, its activation via the parallelhdf5compression argument is considered experimental and should be used with awareness of potential risks and the specificities of the HDF5 implementation in use.\n\n\n\n\n\n","category":"function"},{"location":"performance.html#Performance-Tuning","page":"Performance Tuning","title":"Performance Tuning","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"This section provides some explanations on how to fine-tune the simulation performance.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"These tips are specific to Vahana. Of course, all the generic performance tips, such as writing type-stable functions, still apply.","category":"page"},{"location":"performance.html#Optional-Assertions","page":"Performance Tuning","title":"Optional Assertions","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Vahana includes internal consistency checks that can impact runtime performance. For example, in agentstate, there are checks to ensure that the specified agenttype matches the agent's ID, which incurs some overhead. These assertions that could degrade performance can be disabled by calling enable_asserts(false).","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The recommended approach is to enable assertions during the model development phase but disable them when the model goes \"into production,\" such as before starting a parameter space exploration.","category":"page"},{"location":"performance.html#Type-Hints","page":"Performance Tuning","title":"Type Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"It is possible to provide Vahana with hints about the types of agents or edges to improve runtime performance and/or reduce memory requirements.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Apart from the :SingleEdge hint, there is generally no need to change anything in the model code. The interface to Vahana remains the same, with the restriction that not all functions may be available. For example, if the :IgnoreFrom hint is set for an edge type, it is not possible to call the edgestates function because Vahana has not stored the ID of the neighbors and therefore cannot retrieve their state.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"In general, a sensible approach is to keep the assertions active and ignore the hints (except for :SingleEdge, as it can make your code simpler) during the implementation of the model. Once the implementation is complete, the first step is to check which hints are set and how they affect performance. After making a choice that does not trigger any assertions, these can then be deactivated as well.","category":"page"},{"location":"performance.html#Agent-Hints","page":"Performance Tuning","title":"Agent Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Currently, the only hint available for agent types is the :Immortal hint. This hint informs Vahana that agents of this type will not be removed during the simulation (for example, by returning nothing in a transition function).","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The advantage of using this hint is that Vahana doesn't need to check or handle situations where these agents may be removed. This simplifies the internal handling of such agents.","category":"page"},{"location":"performance.html#Edge-Hints","page":"Performance Tuning","title":"Edge Hints","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"There exist four possible hints for the edge types, that can be  set as optional register_edgetype! arguments:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":":IgnoreFrom: Omits storage of the source node's ID \n:Stateless: Only stores the ID of the source node \n:SingleType: All target nodes are of the same type (the source","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"nodes can have different types). This needs also the keyword target set (see below).","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":":SingleEdge: Each agent can be the target of only one edge (of this type).\n:IgnoreSourceState: The ID of the source agent is not used to access the state of the agent with this ID.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The :IgnoreSourceState hint is primarily relevant when running a simulation in parallel. You can find detailed information about this hint below.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Almost all hints can be combined in any way you prefer. For example, the combination of :IgnoreFrom and :Stateless may seem useless at first because no concrete edge information will be stored when add_edge! is called. However, Vahana still keeps track of the number of edges that have the agent as the target node. This information alone, or combined with the :SingleEdge hint, can often be sufficient. You can refer to the Die or Eat edges in the Predator example for an illustration.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The only combination that is not allowed is :SingleType + :SingleEdge, unless you also set :Stateless and :IgnoreFrom.","category":"page"},{"location":"performance.html#:SingleType-target-keyword-argument","page":"Performance Tuning","title":":SingleType target keyword argument","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"When the :SingleType hint is set, it is necessary to add the target keyword argument to the register_edgetype! function. The value of this argument should be the type of the target nodes.","category":"page"},{"location":"performance.html#Defined-Functions","page":"Performance Tuning","title":"Defined Functions","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The following functions can be used to access the graph within apply!, but their availability depends on the edge type hints:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"function not available for edge type with the hint (combination)\nedges :IgnoreFrom or :Stateless\nneighborids :IgnoreFrom\nneighborstates :IgnoreFrom\nedgestates, mapreduce :Stateless\nnum_edges :SingleEdge\nhas_edge always available","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"As mentioned earlier, the Vahana API differs slightly when the :SingleEdge hint is used. This specifically affects the functions listed here, with the exception of num_edges, has_edges, and mapreduce. Normally, these functions return a vector containing edges, IDs, or states (or nothing). However, when used in combination with the :SingleEdge hint, they return only one edge, ID, or state (or nothing), as the hint implies that there is at most one edge of that type.","category":"page"},{"location":"performance.html#Special-Hint-Combinations","page":"Performance Tuning","title":"Special Hint Combinations","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Additionally, there are two property combinations that can be set in register_edgetype! using a single symbol, which directly expresses the intended combination:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":":NumEdgesOnly: This corresponds to the combination of :IgnoreFrom and :Stateless. In this case, only the number of edges is counted, so only calls to num_edges and has_edge are possible.\n:HasEdgeOnly: This corresponds to the combination of :IgnoreFrom, :Stateless, and :SingleEdge. In this case, only calls to has_edge are possible.","category":"page"},{"location":"performance.html#Parallel-simulations","page":"Performance Tuning","title":"Parallel simulations","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The best performance improvement can be achieved by computing a model implemented with Vahana in parallel. This can be easily done by starting the simulation with mpirun or mpiexec. For example:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"mpirun -np 4 julia hegselmann.jl","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The -np parameter indicates the number of processes/threads to be used for the simulation.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"This approach works without any additional changes in the model code. However, there are ways to further optimize performance in a parallel simulation:","category":"page"},{"location":"performance.html#Partitioning","page":"Performance Tuning","title":"Partitioning","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"The simulation graph is partitioned and distributed in the finish_init! call. By default, the Metis.jl package is used for this. However, during this process, the information about the different agent types is lost. As a result, if multiple agent types are used, it is possible that the number of agents is unevenly distributed for a single agent type.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"To address this issue, an alternative partitioning scheme, :EqualAgentNumbers, is available. However, this scheme ignores the edges and number of cuts in the graph.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"In order to optimize the partitioning for your specific model, it can be very useful to perform your own partitioning and pass it to finish_init!. An example of this can be seen in the create_partition function of the Vahana Episim Example.","category":"page"},{"location":"performance.html#@rootonly","page":"Performance Tuning","title":"@rootonly","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"MPI is based on a single program, multiple data (SPMD) model. As a consequence, up until the finish_init! call, all processes execute the exact same instructions on the same data. Therefore, if there are n processes, the complete graph is generated n times.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Although this is not necessarily problematic since only the graph of the root processes is distributed in finish_init!, it can be beneficial to construct the graph only on the root processes, especially if files are being read during the initialization phase.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"To execute instructions only on the root process, you can use the @rootonly macro. For example, the Vahana Episim example includes the following code before the finish_init! call:","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"    @rootonly begin\n        worldid = add_agent!(sim, World())\n        healthauthid = add_agent!(sim, HealthAuthority(0, 0, 0))\n        @info \"read persons\"\n        persons = read_persons!(config.synpop_file)\n        @info \"read events\"\n        read_events!(sim, config.events_all, persons, worldid, healthauthid)\n        @info \"finish init\"\n    end","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"But it is important that finish_init! is called by all processes and not only by the root process.","category":"page"},{"location":"performance.html#Write-a-snapshot-after-finish_init!","page":"Performance Tuning","title":"Write a snapshot after finish_init!","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"If creating the initial state takes time and the process is deterministic, it is a good idea to save the state after finish_init! with write_snapshot and read this snapshot with read_snapshot! instead of recreating the graph each time. ","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Again, the Vahana Episim example demonstrates how to do this.","category":"page"},{"location":"performance.html#:IgnoreSourceState-hint","page":"Performance Tuning","title":":IgnoreSourceState hint","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"This hint requires additional explanation about what happens internally when apply! is called.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"In a parallel simulation, at the beginning of apply!, it is checked whether the transition function needs to read the state of an agent type that may have changed since the last state read. If this is the case, it checks all accessible edges (specified in the read argument of apply!) and transmits the state of agents that can be accessed (i.e., the agent type must also be included in the read argument) to the corresponding process. However, there are cases where it is clear that only the IDs of the agents will be accessed via a specific edge type, and not the agent state itself. To avoid the overhead of transmitting state between agents that will never be read, the :IgnoreSourceState hint can be used for those edge types.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"This hint only affects parallel simulations, as there is nothing to transmit in a serial simulation.","category":"page"},{"location":"performance.html#Avoid-agentstate-calls","page":"Performance Tuning","title":"Avoid agentstate calls","text":"","category":"section"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"Instead of using agentstate to access the state of an agent, sometimes it is possible for an agent to actively send the required state associated with an edge to another agent that needs that information. This can significantly improve performance, especially when combined with the :IgnoreSourceState hint if necessary.","category":"page"},{"location":"performance.html","page":"Performance Tuning","title":"Performance Tuning","text":"For example, in a Game of Life implementation, active cells can generate an edge to their neighbors if the cell is active. If this edge has the :NumEdgesOnly hint, it will directly trigger the counting process of the neighbors without the need to transfer the full state to other agents/processes.","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"CurrentModule = Vahana ","category":"page"},{"location":"misc.html#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Here are the remaining exported Vahana definitions that do not fit into any of the previous categories:","category":"page"},{"location":"misc.html#Agents","page":"Misc","title":"Agents","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"ProcessID\nAgentID\nall_agents\nnum_agents","category":"page"},{"location":"misc.html#Vahana.ProcessID","page":"Misc","title":"Vahana.ProcessID","text":"ProcessID\n\nThe rank on which the agent is currently managed.\n\n\n\n\n\n","category":"type"},{"location":"misc.html#Vahana.AgentID","page":"Misc","title":"Vahana.AgentID","text":" AgentID\n\nThe AgentID is a combination of different (Vahana internal) information about an agent, like e.g. the position where the agent state is stored. It's important to understand that at different times different agents can have the same agent id, therefore those ids can not be used to identify an agent a simulation run. If you need this, you must add an field to the agent state and create an unique value for this field in the agent constructor by yourself.\n\n\n\n\n\n","category":"type"},{"location":"misc.html#Vahana.all_agents","page":"Misc","title":"Vahana.all_agents","text":"all_agents(sim, ::Type{T}, [all_ranks=false])\n\nThis function retrieves a vector of the states for all agents of type T of the simulation sim.\n\nThe all_ranks argument determines whether to include agents from all ranks or just the current rank in parallel simulations. When all_ranks is true, the function returns a vector of all agent identifiers across all ranks.  \n\nSee also [add_agents!] and (@ref)num_agents.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.num_agents","page":"Misc","title":"Vahana.num_agents","text":"num_agents(sim, ::Type{T}, [all_ranks=false])\n\nIf all_ranks is true this function retrieves the number of agents of type T of the simulation sim. When it is set to false, the function will return the number of agents managed by the process.\n\nSee also [add_agents!] and all_agents.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Edges","page":"Misc","title":"Edges","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"num_edges(sim, t::Type{T}, sum_ranks = true; write = nothing) where T","category":"page"},{"location":"misc.html#Vahana.num_edges-Union{Tuple{T}, Tuple{Any, Type{T}}, Tuple{Any, Type{T}, Any}} where T","page":"Misc","title":"Vahana.num_edges","text":"num_edges(sim, ::Type{T}, [sum_ranks=false])\n\nIf all_ranks is true this function retrieves the number of edges of type T of the simulation sim. When it is set to false, the function will only return the number of edges of type T managed by the process.\n\n\n\n\n\n","category":"method"},{"location":"misc.html#REPL","page":"Misc","title":"REPL","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Vahana has some features that support model development via Julia's interactive command line REPL. In this case, the simulation is not parallelized, but the same code runs later via parallelization without requiring any (or minimal) changes.","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"Beside the pretty-printing of a simulation as shown in the tutorial(s), there are also additional functions that allows to investigate the current state of a simulation:","category":"page"},{"location":"misc.html","page":"Misc","title":"Misc","text":"show_agent\nDataFrames.DataFrame(sim::Simulation, T::DataType)","category":"page"},{"location":"misc.html#Vahana.show_agent","page":"Misc","title":"Vahana.show_agent","text":"show_agent(sim, Type{T}, [id=0; max=5, neighborstate = []])\n\nDisplay detailed information about the agent with ID id, or in the case that id is a value < 2^36, the information of the nth agent of type T. If id is 0 (the default value), a random agent of type T is selected.\n\nReturns the ID of the agent (which is especially useful when a random agent is selected).\n\nKeyword arguments:\n\nmax controls the maximal number of edges that are shown per network (per direction).\n\nIf a field of an agent on the source side of an edge is listed in the neighborstate vector, the value of this field will be also shown.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#DataFrames.DataFrame-Tuple{Vahana.Simulation, DataType}","page":"Misc","title":"DataFrames.DataFrame","text":"DataFrame(sim::Simulation, T::DataType; types = false, localnr = false)\n\nCreates a DataFrame with the current state of agents or edges of type T.  By default, the ID columns show the complete AgentID. for readability (and the use of show_agent) it may be useful to show only the lowest 36 bits, which gives a much more readable value, by setting the localnr argument to true. Since for edges the type information of the source and target agents is no longer available in this case, the types argument can be used to create additional columns containing the types of these agents.\n\ninfo: Info\nDataFrame is only available when the DataFrame.jl package is imported by the model implementation. \n\n\n\n\n\n","category":"method"},{"location":"misc.html","page":"Misc","title":"Misc","text":"apply can be used to calculate a transition function without modifying the original state. This can be useful in the development process, but for the final simulation the function should be replaced with the modifying version apply!.","category":"page"},{"location":"misc.html#Simulation","page":"Misc","title":"Simulation","text":"","category":"section"},{"location":"misc.html","page":"Misc","title":"Misc","text":"copy_simulation\nfinish_simulation!","category":"page"},{"location":"misc.html#Vahana.copy_simulation","page":"Misc","title":"Vahana.copy_simulation","text":"copy_simulation(sim)\n\nCreate an independent copy of the simulation sim. Since part of the memory is allocated via MPI, you should not use deepcopy. \n\nAlso, the copy is detached from any output or logger file so that not sim and copy tried to write to the same file(s). If these are needed, you can create these files for the copy by calling create_h5file! and/or create_logger! and assigning the results to the h5file/logging field of the returned simulation.\n\nReturns the copy of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"misc.html#Vahana.finish_simulation!","page":"Misc","title":"Vahana.finish_simulation!","text":"finish_simulation!(sim)\n\nRemove all agents/edges and rasters from the simulation to minimize the memory footprint. The parameters and globals of the simulation are still available, the remaining state of the simulation is undefined.\n\nReturns the globals of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"plots.html","page":"Plots","title":"Plots","text":"CurrentModule = Vahana","category":"page"},{"location":"plots.html#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plots.html","page":"Plots","title":"Plots","text":"Visualization is not the main focus of Vahana, but two rudimentary auxiliary functions exist for creating plots with Makie.","category":"page"},{"location":"plots.html","page":"Plots","title":"Plots","text":"plot_globals\ncreate_graphplot","category":"page"},{"location":"plots.html#Vahana.plot_globals","page":"Plots","title":"Vahana.plot_globals","text":"plot_globals(sim, names::Vector{Symbol})\n\nCreates a Makie lineplot with one line for each global in names, wherby those global values must be Vectors (or Iterable).\n\nReturns figure, axis, plots. plots is a vector of Plots, which one plot for element of names.\n\ninfo: Info\nplot_globals is only available when a Makie backend is imported by the client.\n\nSee also push_global!, get_global\n\n\n\n\n\n","category":"function"},{"location":"plots.html#Vahana.create_graphplot","page":"Plots","title":"Vahana.create_graphplot","text":"create_graphplot(sim; [agenttypes, edgestatetypes, update_fn, pos_jitter])\n\nCreates an interactive Makie plot for the the simulation sim.\n\nThe graph can be restricted to a subgraph with the given agentypes and edgestatetypes, see vahanagraph for details.\n\nTo modify the properties of the edges and agents a update_fn can be defined. This function is called for each agent and edge (of types in agenttypes and edgestatetypes) and must have for agents the signature\n\nf(state, id, vp::VahanaPlot)\n\nand for edges\n\nf(state, source, target, vp::VahanaPlot)\n\nThe arguments of this functions are state for the agent or edgestate, ID for the id of the agent called, from and to for the ID of the agents at the source or target of the edge. vp is the struct returned by create_graphplot and can be used to determine the id of last clicked agent by calling clicked_agent(vp). The function must return a Dict with property names (as Symbol) as keys and their values as values. The following properties are available: node_color, node_size, node_marker, nlabels, nlabels_align, nlabels_color, nlabels_distance, nlabels_offset, nlabels_textsize, edge_color, edge_width, elables, elables_align, elables_color, elables_distance, elables_offset, elables_rotation, elables_shift, elables_side, elabes_textsize, arrow_shift, and arrow_size.\n\nReturns a VahanaPlot structure that can be used to access the Makie figure, axis and plot via call to the methods figure, axis and plot with this struct as (single) argument.\n\ninfo: Info\ncreate_graphplot is only available when the GraphMakie package and a Makie backend is imported by the client.\n\nwarning: Warning\nFor the mouse click and hover interaction, the current state of the simulation used to construct the VahanaGraph is accessed. In the case that a transition function is called after the construction of the VahanaGraph, and this transition function modifies the structure of the Graph (add/removes nodes or edges), then this changes are not reflected by the current implementation and can cause errors.\n\nSee also vahanagraph\n\n\n\n\n\n","category":"function"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"CurrentModule = Vahana","category":"page"},{"location":"definition.html#Model-Definition","page":"Model Definition","title":"Model Definition","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"This page describes all the functions and structures used to define the model and to create an uninitialized simulation. In Vahana the simulation state and the transition functions that changes the state are decoupled, therefore we do not need to define the transition functions before we create the simulation. ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"The usual workflow is as follows:","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Define all Agent and Edge types\nCreate a ModelTypes instance\nRegister the defined Agent and Edge types \nCall create_model to create an model (state space) object\nCall create_simulation to create an uninitialized simulation of this model","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"The simplest example for such a workflow is:","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"struct Agent end\nstruct EdgeState end\n\nconst sim = ModelTypes() |>\n    register_agenttype!(Agent) |>\n    register_edgetype!(EdgeState) |>\n    create_model(\"Minimal Example\") |>\n    create_simulation()","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"After the simulation is created, the next step is its initialization, which is described on the next page.","category":"page"},{"location":"definition.html#Construct-the-Model","page":"Model Definition","title":"Construct the Model","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"Before we can construct a model, we need to register all agent and edge types. ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"ModelTypes\nregister_agenttype!\nregister_edgetype!","category":"page"},{"location":"definition.html#Vahana.ModelTypes","page":"Model Definition","title":"Vahana.ModelTypes","text":"ModelTypes\n\nThis struct stores all (internal) information about the agent and edge types of the model and is therefore the starting point of the model definition. \n\nCall the ModelType constructor without parameters, and then use the created object as the first parameter in register_agenttype! and register_edgetype!, whereby the |> operator can be used to concatenate these registrations.\n\nSee also create_model,\n\n\n\n\n\n","category":"type"},{"location":"definition.html#Vahana.register_agenttype!","page":"Model Definition","title":"Vahana.register_agenttype!","text":"register_agenttype!(types::ModelTypes, ::Type{T}, [hints...])\n\nRegister an additional agent type to types. \n\nAn agent type is a struct that define the state space for agents of type T. These structs must be \"bits types\", meaning the type is immutable and contains only primitive types and other bits types.\n\nBy default, it is assumed that an agent can die (be removed from the simulation) by returning nothing in the transition function (see apply!. In the case that agents are never removed, the hint :Immortal can be given to improve the performance of the simulation.\n\nSee also add_agent! and add_agents! \n\n\n\n\n\n","category":"function"},{"location":"definition.html#Vahana.register_edgetype!","page":"Model Definition","title":"Vahana.register_edgetype!","text":"register_edgetype!(types::ModelTypes, ::Type{T}, [hints...; kwargs...])\n\nRegister an additional edge type to types. \n\nAn edge type T is a structure that defines the state (field) of Edge{T}.  These structs must be \"bit types\", that is, the type is immutable and contains only primitive types and other bit types. Often these types T are stateless, in which case they are used as a tag to distinguish between the existing types of edges of the model.\n\nThe internal data structures used to store the graph in memory can be modified by  the hints parameters:\n\n:IgnoreFrom: The ID of the source agent is not stored. This implies that the state of the agents on the source of the edge is not accessible via e.g. the neighborstates function.\n:Stateless: Store only the ID of the source agent. \n:SingleType: All target agents have the same type, needs also keyword target (see below).\n:SingleEdge: Each agent can be the target for max. one edge.\n:IgnoreSourceState: The ID of the source agent is not used to access the state of the agent with this ID.\n:NumEdgesOnly: Combines :IgnoreFrom and :Stateless\n:HasEdgeOnly: Combines :IgnoreFrom, :Stateless and :SingleEdge\n\nIf :SingleType is set, the keyword argument target must be added. The value of this argument must be the type of the target node. If the target keyword exists, but the :SingleType hint is not explicitly specified, it will be set implicitly\n\nIf it is known how many agents of this type exist, this can also be specified via the optional size keyword. This can improve performance, but can also increase the memory usage.\n\nSee also Edge Hints, add_edge! and  add_edges! \n\n\n\n\n\n","category":"function"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"We can then use the ModelTypes instance to construct the model. Which means that optimized methods that can be used to access or modify the simulation state during the transition function are generated. See Performance Tuning for details.","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"tip: Tip\nAs create_model adds new methods, it increments the \"world age counter\". This means, that you can not construct the model in the same function as you initialize it. But you can call create_simulation in the same function soconst model = create_model(modeltypes, \"Minimal Example\") \n\nfunction create_and_init()\n\tsim = create_simulation(model, nothing, nothing)\n\tadd_agent!(sim, Agent())\nendis valid code. ","category":"page"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"create_model\nModel","category":"page"},{"location":"definition.html#Vahana.create_model","page":"Model Definition","title":"Vahana.create_model","text":"create_model(types::ModelTypes, name::String)\n\nCreates a struct that is a subtype of the Simulation type and methods corresponding to the type information of types to the Julia session. The new structure is named name, and all methods are specific to this structure using Julia's multiple dispatch concept, so it is possible to have different models in the same Julia session (as long as name is different).\n\nReturns a Model that can be used in create_simulation to create a concrete simulation.  \n\n\n\n\n\n","category":"function"},{"location":"definition.html#Vahana.Model","page":"Model Definition","title":"Vahana.Model","text":"Model\n\nA Model instance is created by create_model and can then be used to create one or multiple simulations via create_simulation.\n\n\n\n\n\n","category":"type"},{"location":"definition.html#Create-a-Simulation","page":"Model Definition","title":"Create a Simulation","text":"","category":"section"},{"location":"definition.html","page":"Model Definition","title":"Model Definition","text":"create_simulation","category":"page"},{"location":"definition.html#Vahana.create_simulation","page":"Model Definition","title":"Vahana.create_simulation","text":"create_simulation(model::Model, [params = nothing, globals = nothing; name = model.name, filename = name, overwrite_file = true, logging = false, debug = false])\n\nCreates and return a new simulation object, which stores the complete state  of a simulation. \n\nmodel is an Model instance created by create_model.\n\nparams must be a struct (or nothing) that contains all parameters of a simulation. Parameter values are constant in a simulation run and can be retrieved via the param function.\n\nglobals must be a mutable struct (or nothing). The values of these fields are accessible for all agents via the get_global function. The values can be changed by calling set_global! or push_global!. \n\nThe optional keyword argument name is used as meta-information about the simulation and has no effect on the dynamics, since name is not accessible in the transition functions. If name is not given, the name of the model is used instead.\n\nThe optional filename keyword is a string that will be used as the name of the hdf5 file when a simulation or a part of it is written via e.g. write_snapshot. \n\nThe file is created when a write... function is called for the first time, and it is created in an h5 subfolder. By default an existing file with the same filename will be overwritten, but this behavior can be disabled with the overwrite_file keyword, in which case the files will be numbered. If filename is not provided, the name argument is used instead.\n\nThe keywords logging is a boolean flag that enables an automatical log file.  The log file contains information such as the time spent in different functions. When also debug is set to true, the log file contains more details and the stream will be flushed after each write.\n\nAs with the hdf5 files, overwrite_file the keyword determines whether the log files are overwritten or numbered. The numbering is set independently from the numbering of the hdf5 files.\n\nThe simulation starts in an uninitialized state. After adding the agents and edges for the initial state, it is necessary to call finish_init! before applying a transition function for the first time.\n\nSee also create_model, param, get_global, set_global!, push_global! and finish_init!\n\n\n\n\n\n","category":"function"},{"location":"logging.html","page":"Logging","title":"Logging","text":"CurrentModule = Vahana","category":"page"},{"location":"logging.html#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"logging.html","page":"Logging","title":"Logging","text":"Vahana utilize Julia's Standard Logging Library to optionally create log files with e.g. the duration of the transition functions. For each process a seperate file is created.","category":"page"},{"location":"logging.html","page":"Logging","title":"Logging","text":"create_logger!\nwith_logger\nlog_overview","category":"page"},{"location":"logging.html#Vahana.create_logger!","page":"Logging","title":"Vahana.create_logger!","text":"create_logger!(sim::Simulation, [debug = false, name = sim.name; overwrite = sim.overwrite_file])\n\nThe canonical way to create log files for a simulation is by setting the logging keyword of create_simulation to true. But sometime it can be useful to control this manually, e.g. after a call to copy_simulation.\n\nWhen also debug is set to true, the log file contains more details and the stream will be flushed after each write.\n\nThe filename argument can be used to specify a filename other than sim.filename. If overwrite is true, existing files with this name will be overwritten. If it is false, the filename is automatically extended by an increasing 6-digit number, so that existing files are not overwritten.\n\nThe files are always created in a log subfolder, and this one will be create in the current working directory.\n\n\n\n\n\n","category":"function"},{"location":"logging.html#Logging.with_logger","page":"Logging","title":"Logging.with_logger","text":"with_logger(f::Function, sim::Simulation)\n\nExecute function f, directing all log messages to the logger that is attached to simulation sim.\n\n\n\n\n\n","category":"function"},{"location":"logging.html#Vahana.log_overview","page":"Logging","title":"Vahana.log_overview","text":"log_overview(sim::Simulation)\n\nDump an overview of the simulation sim to the attached logfile.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"CurrentModule = Vahana","category":"page"},{"location":"initialization.html#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"After we created a simulation by calling create_simulation, we must build the initial state of the simulation. As in Vahana the state of a model is represented as a graph, this means we must add the nodes (our agents) and edges to the graph.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"add_agent!\nadd_agents!","category":"page"},{"location":"initialization.html#Vahana.add_agent!","page":"Initialization","title":"Vahana.add_agent!","text":"add_agent!(sim, agent::T)::AgentID\n\nAdd a single agent of type T to the simulation sim.\n\nT must have been previously registered by calling register_agenttype!.\n\nadd_agent! returns a new AgentID, which can be used to create edges from or to this agent until finish_init! is called (in the case that add_agent! is called in the initialization phase), or until the transition funcion is finished (in the case that add_agent! is called in an apply! callback). Do not use the ID for other purposes, they are not guaranteed to be stable.\n\nSee also add_agents!, add_edge! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.add_agents!","page":"Initialization","title":"Vahana.add_agents!","text":"add_agents!(sim, agents)::Vector{AgentID}\n\nAdd multiple agents at once to the simulation sim.\n\nagents can be any iterable set of agents, or an arbitrary number of agents as arguments. \n\nThe types of the agents must have been previously registered by calling register_agenttype!.\n\nadd_agents! returns a vector of AgentIDs, which can be used to create edges from or to this agents before finish_init! is called (in the case that add_agents! is called in the initialization phase), or before the transition funcion is finished (in the case that add_agents!  is called in an apply! callback). Do not use the ID for other purposes, they are not guaranteed to be stable.\n\nSee also add_agent!, register_agenttype!, add_edge! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"warning: Warning\nThe IDs created by add_agent(s)! contain Vahana internal information, that can change after an apply! or the finish_init! call. It is even possible that  different agents have the same ID at different times. This has the implication, that  the IDs can only be used temporary and should not be stored in the state of an agent or edge.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"Edge\n\nadd_edge!\nadd_edges!","category":"page"},{"location":"initialization.html#Vahana.Edge","page":"Initialization","title":"Vahana.Edge","text":"struct Edge{T} \n    from::AgentID\n    state::T\nend\n\nAn edge between to agents with (optionally) additional state. T can be also a struct without any field.\n\nThe AgentID of the agent at the target of the edge is not a field of Edge itself, since this information is already part of the containers in which the edges are stored.\n\nSee also register_edgetype!\n\n\n\n\n\n","category":"type"},{"location":"initialization.html#Vahana.add_edge!","page":"Initialization","title":"Vahana.add_edge!","text":"add_edge!(sim, to::AgentID, edge::Edge{T})\n\nAdd a single edge to the simulation sim. The edges is directed from the agent with ID edge.from (the source) to the agent with ID to (the target).\n\nadd_edge!(sim, from::AgentID, to::AgentID, state::T)\n\nAdd a single edge to the simulation sim. The edge is directed from the agent with ID from (the source) to the agent with ID to (the target) and has the state state.\n\nT must have been previously registered in the simulation by calling register_edgetype!.\n\nSee also Edge register_edgetype! and add_edges!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.add_edges!","page":"Initialization","title":"Vahana.add_edges!","text":"add_edges!(sim, to::AgentID, edges)\n\nAdd multiple edges at once to the simulation sim, with all edges are directed to to.\n\nedges can be any iterable set of agents, or an arbitrary number of edges as arguments. \n\nSee also Edge register_edgetype! and add_edge!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Graphs","page":"Initialization","title":"Graphs","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"It is also possible to use graph generators from the Graphs.jl package to construct the initial state. Or parts of it, since you can combine it with all the other functions described on this page. Since Graphs.jl has overlapping function names with Vahana, it is advisable to import only the SimpleGraphs module from Graphs.jl.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"add_graph!","category":"page"},{"location":"initialization.html#Vahana.add_graph!","page":"Initialization","title":"Vahana.add_graph!","text":"add_graph!(sim::Simulation, graph, agent_constructor, edge_constructor) -> Vector{AgentID}\n\nAdds a graph from the Graphs.jl package to sim, incl. all vertices of graph as new agents.\n\ngraph must be a Graphs.Graph or a Graphs.DiGraph.\n\nFor each vertix of graph the agent_constructor function is called, with the Graphs.vertix as argument. For each edge of graph the edge_constructor function is called, with the Graphs.edge as argument.\n\nThe agent types of agents created by the agent_constructor must be already registered via register_agenttype! and vis a vis the edge type via register_edgetype!.\n\ninfo: Info\nadd_graph! is only available when the Graphs.jl package is imported by the model implementation. \n\nReturns a vector with the IDs of the created agents.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"There is also two function with works the other way and converts the underlying graph of an simulation (or a subset of this graph) to a structure that fulfills the AbstractGraph or AbstractSimpleGraph interface from the Graphs.jl package.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"vahanagraph\nvahanasimplegraph","category":"page"},{"location":"initialization.html#Vahana.vahanagraph","page":"Initialization","title":"Vahana.vahanagraph","text":"vahanagraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true, drop_multiedges = false])\n\nCreates a subgraph with nodes for all agents that have one of the agenttypes types, and all edges that have one of the edgetypes types and whose both adjacent agents have are of a type in agenttypes.\n\nThe default values for agenttypes and edgetypes are all registered agents/edgetypes (see register_agenttype! and register_edgetype!).\n\nThis subgraphs implements the AbstractGraph interface from the Graphs.jl package, so that e.g. GraphMakie can be used to visualize the subgraph. See also create_graphplot.\n\nThe AbstractGraph interface allows multiple edges between two nodes, but some functions (e.g. those that convert the graph to a binary (sparse) matrix) may produce undefined results for these graphs, e.g. when graphplot is called from GraphMakie.jl. If the keyword drop_multiedges is true and there are multiple edges, only the edge of the type that is first in the edgetypes vector is added to the generated graph.\n\nThe edge types must not have the :IgnoreFrom property. If there are edge types with this property in the edgetypes vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting show_ignorefrom_warning to false.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.vahanasimplegraph","page":"Initialization","title":"Vahana.vahanasimplegraph","text":"vahanasimplegraph(sim::Simulation; [agenttypes::Vector{DataType}, edgetypes::Vector{DataType}, show_ignorefrom_warning = true])\n\nCreates a subgraph with nodes for all agents that have one of the agenttypes types, and all edges that have one of the edgetypes types and whose both adjacent node types are in agenttypes.\n\nThe default values for agenttypes and edgetypes are all registered agents/edgetypes (see register_agenttype! and register_edgetype!).\n\nThis subgraphs implements the AbstractSimpleGraph interface from the Graphs.jl package.\n\nThe edge types must not have the :IgnoreFrom property. If there are edge types with this property in the edgetypes vector, a warning will be displayed and these edges will be ignored. The warning can be suppressed by setting show_ignorefrom_warning to false.\n\nwarning: Warning\nThe AbstractGraph interface allows multiple edges between two nodes, but some function (e.g. those that convert the graph into a binary (sparse)matrix can produce undefined results for those graphs. So use this function with care. \n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Raster","page":"Initialization","title":"Raster","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"Spatial information can be added to the simulation in the form of one or more n-dimensional rasters. ","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"add_raster!","category":"page"},{"location":"initialization.html#Vahana.add_raster!","page":"Initialization","title":"Vahana.add_raster!","text":"add_raster!(sim, name::Symbol, dims::NTuple{N, Int}, agent_constructor)\n\nAdds a n-dimensional grid to sim, with the dimensions dims.\n\nFor each cell a new node/agent is added to the graph. To create the agent, the agent_constructor function is called, with the cell position in form of an CartesianIndex as argument.\n\nThe symbol name is an identifier for the created raster, as it is allowed to add multiple rasters to sim. \n\nThe types of the agents created by the agent_constructor must be already registered via register_agenttype!.\n\nReturns a vector with the IDs of the created agents.\n\nCan be only called before finish_init!.\n\nSee also calc_raster connect_raster_neighbors! and move_to!.\n\n\n\n\n\n","category":"function"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"Such a raster is only a collection of nodes in the graph incl. an Vahana internal mapping from the cartesian coordinates to the cell IDs. Beside this mapping, cells are also just agents, but there are some Vahana functions like calc_raster that utilize the internal cartesian coordinates to create a n-dimensional representation of the state space.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"The ID and the state of the cells can not be accessed directly, instead it's necessary to create edges between the cells, or between the cells and agents of other types via the following two helper functions.","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"connect_raster_neighbors!\nmove_to!","category":"page"},{"location":"initialization.html#Vahana.connect_raster_neighbors!","page":"Initialization","title":"Vahana.connect_raster_neighbors!","text":"connect_raster_neighbors!(sim, name::Symbol, edge_constructor; [distance::Int, metric:: Symbol, periodic::Bool])\n\nAll cells that are at most distance from each other (using the metric metric) are connected with edges, where the edges are created with the edge_constructor.\n\nThe edge_constructor must be a function with one argument with type Tuple{CartesianIndex, CartesianIndex}. The first CartesianIndex is the position of the source node, and the second CartesianIndex the position of the target node.\n\nValid metrics are :chebyshev, :euclidean and :manhatten.\n\nThe keyword periodic determines whether all dimensions are cyclic (e.g., in the two-dimensional case, the raster is a torus).\n\nThe default values of the optional keyword arguments are 1 for distance, :chebyshev for metric and true for periodic. which is equivalent to a Moore neighborhood. The :manhatten metric can be used to connect cells in the von Neumann neighborhood.\n\nThe agent types of agents created by the agent_constructor must be already registered via register_agenttype!.\n\nSee also add_raster!\n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Vahana.move_to!","page":"Initialization","title":"Vahana.move_to!","text":"move_to!(sim, name::Symbol, id::AgentID, pos, edge_from_raster, edge_to_raster; [distance = 0, metric = :chebyshev, periodic = true])\n\nCreates up to two edges of type between the agent with ID id and the cell from the raster name at the position pos.\n\npos must be of type CartesianIndex or a Dims{N}. \n\nedge_from_raster is the edge that will be added with the cell as source node and the agent as target node. edge_from_raster can be nothing, in this case no edge will be added with the agent as target node.\n\nedge_to_raster is the edge that will be added with the agent as source node and the cell as target node. edge_to_raster can be nothing, in this case no edge will be added with the agent as source node.\n\nUsing the keyword arguments, it is possible to add additional edges to the surroundings of the cell at position pos in the same raster, i.e. to all cells at distance distance under metric metric, where valid metrics are :chebyshev, :euclidean and :manhatten. And the keywordperiodic` determines whether all dimensions are cyclic.\n\nSee also add_raster! and connect_raster_neighbors! \n\n\n\n\n\n","category":"function"},{"location":"initialization.html#Finish-initialization","page":"Initialization","title":"Finish initialization","text":"","category":"section"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"After all the initial state has been built using the functions described above, finish_init! must be called before the first call of apply!","category":"page"},{"location":"initialization.html","page":"Initialization","title":"Initialization","text":"finish_init!","category":"page"},{"location":"initialization.html#Vahana.finish_init!","page":"Initialization","title":"Vahana.finish_init!","text":"finish_init!(sim::Simulation; [distribute = true, \n             partition::Dict{AgentID, ProcessID}, \n             partition_algo = :Metis])\n\nFinish the initialization phase of the simulation. \n\npartition is an option keyword and allows to specify an assignment of the agents to the individual MPI ranks. The dictonary must contain all agentids created on the rank as key, the corresponding value is the rank on which the agent \"lives\" after finish_init!.\n\nIn the case that no partition is given and distribute is set to true, the Graph will be partitioned with the given partition_algo. Currently two algorithms are supported:     - :Metis uses the Metis library for the graph partitioning.      - :EqualAgentNumbers just ensures that per agent type more or less       the same number of agents are distributed to each process.\n\nfinish_init! must be called before applying a transition function. \n\ninfo: Info\nWhen a simulation is run on multiple PEs, per default the graph found on rank 0 will be partitioned using Metis, and distributed to the different ranks. Which means that it's allowed to run the initialization phase on all ranks (there is no need for a mpi.isroot check), but then all added agents and edges on other ranks then 0 will be discarded. If this is not intended distribute must be set to false.\n\nSee also register_agenttype!, register_edgetype!, apply! and finish_simulation!\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"CurrentModule = Vahana","category":"page"},{"location":"hdf5.html#HDF5-data-storage","page":"HDF5","title":"HDF5 data storage","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"Vahana uses the Hierarchical Data Format version 5 (HDF5) as file format to store simulations to disc, utilizing the HDF5.jl libary. HDF5.jl again uses a C library, which is either installed with HDF5.jl or can be provided by the system. Please check the HDF5.jl documentation for details.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"If the provided library supports Parallel HDF5, this will be used automatically. Using Parallel HDF5 has the advantage that all processes can write to a single file, without Parallel HDF5 multiple files are created for a single (parallel) simulation (but the Vahana API is the same in any case, so for the user this difference is only visible when looking into the h5 directory with a file manager or via the shell). But in the current Vahana version using Parallel HDF5 has the disadvantage, that the files are not compressed (see also set_compression).","category":"page"},{"location":"hdf5.html#Write","page":"HDF5","title":"Write","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"To write into a HDF5 file, they are attached to a Vahama simulation. Normally this happens automatically when the first time a write function like write_snapshot is called. All following write_* calls then add additional datasets to the file.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"write_snapshot\ncreate_h5file!\nclose_h5file!","category":"page"},{"location":"hdf5.html#Vahana.write_snapshot","page":"HDF5","title":"Vahana.write_snapshot","text":"write_snapshot(sim::Simulation, [comment::String = \"\", ignore = []])\n\nWrites the current state of the simulation sim to the attached HDF5 file. comment can be used to identify the snapshot via list_snapshots. ignore is a list of agent and/or edge types, that should not be written.\n\nSee also create_h5file!\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.create_h5file!","page":"HDF5","title":"Vahana.create_h5file!","text":"create_h5file!(sim::Simulation, [filename = sim.filename; overwrite = sim.overwrite_file])\n\nThe canonical way to create an HDF5 file is to call one of the write_ functions like write_snapshot. If sim does not already have an HDF5 file attached, such a file will then be created automatically using the filename specified as keyword in create_simulation or, if this keyword was not given, the model name. But sometime it can be useful to control this manually, e.g. after a call to copy_simulation.\n\nThe filename argument can be used to specify a filename other than sim.filename. If overwrite is true, existing files with this name will be overwritten. If it is false, the filename is automatically extended by an increasing 6-digit number, so that existing files are not overwritten.\n\nBy default, the files are created in an h5 subfolder, and this is created in the current working directory. However, the path can also be set with the function set_hdf5_path.\n\nIn the case that an HDF5 file was already created for the simulation sim, this will be closed.\n\ncreate_h5file! can be only called after finish_init!\n\nSee also close_h5file!, write_agents, write_edges, write_globals, read_agents!, read_edges!, read_globals, read_snapshot! and list_snapshots\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.close_h5file!","page":"HDF5","title":"Vahana.close_h5file!","text":"close_h5file!(sim::Simulation)\n\nCloses the HDF5 file attached to the simulation sim.\n\nBe aware that a following call to one of the write_ functions like write_snapshot will automatically create a new file and, depending on the overwrite_file argument of create_simulation also overwrites to closed file.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"Beside write_snapshot there exists also some more fine grained write functions:","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"write_agents\nwrite_edges\nwrite_globals","category":"page"},{"location":"hdf5.html#Vahana.write_agents","page":"HDF5","title":"Vahana.write_agents","text":"write_agents(sim::Simulation, [types])\n\nWrites the current agent state to the attached HDF5 file. If only the agents of a subset of agent types are to be written, this subset can be specified via the optional types argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_edges","page":"HDF5","title":"Vahana.write_edges","text":"write_edges(sim::Simulation, [types])\n\nWrites the current edge states to the attached HDF5 file. If only the edges of a subset of edge types are to be written, this subset can be specified via the optional types argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.write_globals","page":"HDF5","title":"Vahana.write_globals","text":"write_globals(sim::Simulation, [fields])\n\nWrites the current global values to the attached HDF5 file. If only a subset of the fields is to be written, this subset can be specified via the optional fields argument.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Read","page":"HDF5","title":"Read","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"In the normal use case we call just write_snapshot(sim, \"snapshot description\") (assuming sim is a Vahama simulation). To read such a snapshot, we can then run another Script that creates the same model (see create_model) and simulation (see create_simulation) and then call read_snapshot!(sim). read_snapshot! can read also a parallel simulation into a single (REPL) process, then the distributed graph is merged into a single one.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"read_snapshot!","category":"page"},{"location":"hdf5.html#Vahana.read_snapshot!","page":"HDF5","title":"Vahana.read_snapshot!","text":"read_snapshot!(sim::Simulation, [name::String; transition = typemax(Int64), writeable = false, ignore_params = false])\nread_snapshot!(sim::Simulation, nr::Int64; [transition = typemax(Int64), writeable = false, ignore_params = false])\n\nRead a complete snapshot from a file into the simulation sim. If name is given, the snapshot is read from the file with this filename from the h5 subfolder of the current working directory.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written snapshot is read. The transition keyword allows to read also earlier versions. See also Transition for details.\n\nIf writeable is set to true, the file is also attached to the simulation and following write_ functions like write_snapshot will be append to the file.\n\nIf ignore_params is set to true, the parameters of sim will not be changed.\n\nReturns false when no snapshot was found \n\n\n\n\n\n","category":"function"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"Also here exists also some more fine grained read functions:","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"read_params\nread_globals\nread_agents!\nread_edges!","category":"page"},{"location":"hdf5.html#Vahana.read_params","page":"HDF5","title":"Vahana.read_params","text":"read_params(filename::String, T::DataType)\nread_params(sim::Simulation, T::DataType)\nread_params(sim::Simulation, nr::Int64, T::DataType)\n\nRead the parameters from an HDF5 file. If filename is given, the parameters are read from the file with this filename from the h5 subfolder of the current working directory.\n\nIf a simulation sim is given instead, the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nIn any case, the DataType T of the argument params of create_simulation used for the simulation that wrote the parameters must be specified.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_globals","page":"HDF5","title":"Vahana.read_globals","text":"read_globals(name::String, T::DataType; [ transition = typemax(Int64) ])\nread_globals(sim::Simulation, T::DataType; [ transition = typemax(Int64) ])\nread_globals(sim::Simulation, nr::Int64, T::DataType; [ transition = typemax(Int64) ])\n\nRead the global values from an HDF5 file. If filename is given, the parameters are read from the file with this filename from the h5 subfolder of the current working directory.\n\nIf a simulation sim is given instead, the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nIn any case, the DataType T of the argument globals of create_simulation used for the simulation that wrote the parameters must be specified.\n\nPer default, the last written globals are read. The transition keyword allows to read also earlier versions. See also Write simulations to dics for details.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_agents!","page":"HDF5","title":"Vahana.read_agents!","text":"read_agents!(sim::Simulation, [name::String = sim.filename; transition = typemax(Int64), types::Vector{DataType} ])\nread_agents!(sim::Simulation, nr::Int64; [transition = typemax(Int64), types::Vector{DataType}])\n\nRead the agents from an HDF5 file into the simulation sim. If name is given, the agent are read from the file with this filename from the h5 subfolder of the current working directory.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written agents are read. The transition keyword allows to read also earlier versions. See also Write simulations to dics for details.\n\nIf only the agents of a subset of agent types are to be read, this subset can be specified via the optional types argument.\n\nWhen the agents from a distributed simulation is read into a single threaded simulation, the IDs of the agents are modified.  read_agents! returns a dictory that contains the ID mapping.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.read_edges!","page":"HDF5","title":"Vahana.read_edges!","text":"read_edges!(sim::Simulation, [name::String = sim.filename; idmapfunc = identity, transition = typemax(Int64), types::Vector{DataType}])\nread_edges!(sim::Simulation, nr::Int64; [ idmapfunc = identity, transition = typemax(Int64), types::Vector{DataType} ])\n\nRead the edges from an HDF5 file into the simulation sim. If name is given, the edges are read from the file with this filename from the h5 subfolder of the current working directory.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nPer default, the last written edges are read. The transition keyword allows to read also earlier versions. See also Write simulations to disc for details.\n\nIf only the edges of a subset of edge types are to be read, this subset can be specified via the optional types argument.\n\nWhen the agents from a distributed simulation is read into a single threaded simulation, the IDs of the agents are modified.  The idmapfunc must be a function that must return the new agent id for a given old agent id. read_agents! returns a Dict{AgentID, AgentID} that can be used for this via: idmapfunc = (key) -> idmapping[key], where idmapping is such a Dict.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Transition","page":"HDF5","title":"Transition","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"All read_* functions have a keyword called transition. If this is not set, the last stored data of a type is always read, but via this keyword it is also possible to read the previous state of the simulation (or a part of it) (assuming it was written multiple times, of course).","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"Vahana counts internally how many times the function apply! is called (in the current Vahana implementation this is stored in a field called num_transitions of the simulation). When a new dataset is created by a write_* call, this information is stored with the dataset.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"When read_snapshot! is called, Vahana looks for the highest num_transition that is less than or equal to the transition keyword for the types to be read. Since the default value for the argument is typemax(Int64), the newest dataset is read by default.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"For snapshots the list_snapshots function returns a list of all stored snapshots in the file.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"list_snapshots","category":"page"},{"location":"hdf5.html#Vahana.list_snapshots","page":"HDF5","title":"Vahana.list_snapshots","text":"list_snapshots(name::String)\nlist_snapshots(sim::Simulation)\nlist_snapshots(sim::Simulation, nr::Int64)\n\nList all snapshots of a HDF5 file. If name is given, the snapshots from the file with this filename is returned.  In the other case the filename from the create_simulation call is used.\n\nIf the overwrite_file argument of create_simulation is set to true, and the file names are supplemented with a number, the number of the meant file can be specified via the nr argument.\n\nReturns a vector of tuples, where the first element is the transition number for which a snapshot was saved, and the second element is the comment given in the write_snapshot call.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Restrictions-and-Workarounds","page":"HDF5","title":"Restrictions and Workarounds","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"The exact datastructs that can be stored and read from a HDF5 depends in the HDF5.jl implementation. E.g. before v0.16.15 Tuples where not supported. ","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"The following functions are workarounds for two current restrictions.","category":"page"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"create_namedtuple_converter\ncreate_enum_converter","category":"page"},{"location":"hdf5.html#Vahana.create_namedtuple_converter","page":"HDF5","title":"Vahana.create_namedtuple_converter","text":"create_namedtuple_converter(T::DataType)\n\nThe HDF5.jl library does not support the storage of nested structs, but structs can have NamedTuples as fields. This function creates a convert function from a struct to a corresponding NamedTuple (and also the other way around), so after calling this for a type T, T can be the type of an agent/edge/param/global field.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Vahana.create_enum_converter","page":"HDF5","title":"Vahana.create_enum_converter","text":"create_enum_converter()\n\nThe HDF5.jl library does not support Enums as fields of structs that should be stored. This function add this support but as this involves type piracy, this support must be enabled explicitly.\n\n\n\n\n\n","category":"function"},{"location":"hdf5.html#Example-Model","page":"HDF5","title":"Example Model","text":"","category":"section"},{"location":"hdf5.html","page":"HDF5","title":"HDF5","text":"TODO DOC link to Vahana Episim","category":"page"},{"location":"changelog.html#Change-Log","page":"Change Log","title":"Change Log","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"CurrentModule = Vahana","category":"page"},{"location":"transition.html#Transition-Function","page":"Transition Function","title":"Transition Function","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"As mentioned in the create_model documentation, the model struct is created dynamically incl. the name for this struct. E.g. in the \"Hegselmann\" Example this type is Vahana.var\"Hegselmann\"{Params, Globals}. All of this types are subtypes of the abstract type Simulation.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"After the initialization, the state of the simulation is modified by so called transition functions. ","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"apply!\napply","category":"page"},{"location":"transition.html#Vahana.apply!","page":"Transition Function","title":"Vahana.apply!","text":"apply!(sim, func, call, read, write; [add_existing])\n\nApply the transition function func to the simulation state. \n\ncall must be a single agent type or a collection of agent types, likewise \"read\" and \"write\" must be a single agent/edge type or a collection of agent/edge types.\n\ncall determines for which agent types the transition function func is called. Within the transition function, an agent has access to the state of agents (including its own state) and to edges only if their types are in the read collection. Accordingly, the agent can change its own state and/or create new agents or edges only if their types are in the write collection.\n\nAssume that T is an agent type that is in call. In case T is also in read, the transition function must have the following signature: transition_function(agent::T, id, sim), where the type declaration of agent is optional if call contains only a single type. If T is not in read, it must have the signature transition_function(::Val{T}, id::AgentID, sim::Simulation).\n\nIf T is in write, the transition function must return either an agent of type T or nothing. If nothing is returned, the agent will be removed from the simulation, otherwise the agent with id id will get the returned state after the transition function was called for all agents.\n\nWhen an agent or edge state type is in write, the current agents and edges of that type are removed from the simulation. Usually the agents are read by returning them from the transition function. If you want keep the existing agents/edges for a specific type, you can add this type to the optional add_existing collection.\n\nSee also apply\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.apply","page":"Transition Function","title":"Vahana.apply","text":"apply!(sim, func, call, read, write; add_existing)\n\nCall apply! with a copy of the simulation so that the state of sim itself is not changed.\n\nCan be very useful during development, especially if Vahana is used in the REPL. However, for performance reasons, this function should not be used in the final code.\n\nReturns the copy of the simulation.\n\nSee also apply!\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"tip: Tip\nThe agent types must be immutable, but in most cases the agent returned by a transition function will have a different state than the agent specified as a parameter. If only one field is changed, we still need to copy all other fields. The Setfield.jl package can be very useful in this case.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"Inside a transition function the following functions can be used to access the state of the simulation:","category":"page"},{"location":"transition.html#Globals-and-Parameters","page":"Transition Function","title":"Globals and Parameters","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"param\nget_global","category":"page"},{"location":"transition.html#Vahana.param","page":"Transition Function","title":"Vahana.param","text":"param(sim::Simulation, name)\n\nReturns the value of the field name of the params struct from the Simulation constructor.\n\nSee also create_model\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.get_global","page":"Transition Function","title":"Vahana.get_global","text":"get_global(sim::Simulation, name)\n\nReturns the value of the field name of the globals struct for simulation sim.\n\nSee also create_simulation, set_global! and push_global!\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Get-Agent(state)","page":"Transition Function","title":"Get Agent(state)","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"agentstate\nagentstate_flexible","category":"page"},{"location":"transition.html#Vahana.agentstate","page":"Transition Function","title":"Vahana.agentstate","text":"agentstate(sim, id::AgentID, ::Type{T})\n\nReturns the state of an agent of type T.\n\nIn the case where the type T is not determinable when writing the code (e.g. since there may be edges between agents of different types, the function edges may also return agentIDs of different agent types), agentstate_flexible must be used instead.\n\nwarning: Warning\nif agentstate is called with a Type{T} that does not match the type of the agent with id and the vahana assertions are disabled via enable_asserts, then it is possible that the state of an incorrect agent will be returned. When the assertions are active, there is a runtime check that the agent with the ID id has indeed the type T.\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.agentstate_flexible","page":"Transition Function","title":"Vahana.agentstate_flexible","text":"agentstate_flexible(sim, id::AgentID)\n\nReturns the state of an agent with the id, where the type of the agent is determined at runtime. If the type is known at compile time, using agentstate is preferable as this improves performance.\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"To get the states of all agents that are connected to an agent (with the agent as target) via edges of a specific edge type, the neighborstates functions can be useful (they are combing neighborids and agentstate).","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"neighborstates\nneighborstates_flexible","category":"page"},{"location":"transition.html#Vahana.neighborstates","page":"Transition Function","title":"Vahana.neighborstates","text":"neighborstates(sim::Simulation, id::AgentID, ::Type{E}, ::Type{A})\n\nReturns the state of the agent with type A on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these agent states otherwise.\n\nIf there is no edge with agent id as target, neighborstates returns nothing.\n\nWhen the agents on the source side of the edges can have different types, and it is impossible to determine the Type{A} you can use neighborstates_flexible instead.\n\nneighborstates is not defined if T has the hint :IgnoreFrom \n\nSee also apply!, checked, edges, neighborids, num_edges, has_edge and edgestates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborstates_flexible","page":"Transition Function","title":"Vahana.neighborstates_flexible","text":"neighborstates_flexible(sim::Simulation, id::AgentID, ::Type{E})\n\nReturns the state of the agent on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these agent states otherwise.\n\nIf there is no edge with agent id as target, neighborstates_flexible returns nothing.\n\nneighborstates_flexible is the type instable version of neighborstates and should be only used in the case that the type of agent can not be determined.\n\nneighborstates_flexible is not defined if T has the hint :IgnoreFrom.\n\nSee also apply!, checked, edges, neighborids, num_edges, has_edge and edgestates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Get-Edge(state)","page":"Transition Function","title":"Get Edge(state)","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"edges\nedgestates\nneighborids\nnum_edges(::Simulation, id::AgentID, edgetype::Type) \nhas_edge","category":"page"},{"location":"transition.html#Vahana.edges","page":"Transition Function","title":"Vahana.edges","text":"edges(sim, id::AgentID, ::Type{E})\n\nReturns the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these edges otherwise.\n\nIf there is no edge with agent id as target, edges returns nothing.\n\nedges is not defined if E has the hint :IgnoreFrom or :Stateless.\n\nSee also apply!, checked, neighborids, edgestates, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.edgestates","page":"Transition Function","title":"Vahana.edgestates","text":"edgestates(sim, id::AgentID, ::Type{E})\n\nReturns the state of the edge of type E with agent id as target if E has the hint :SingleEdge, or a vector of these states otherwise.\n\nIf there is no edge with agent id as target, edgestates returns nothing.\n\nedgestates is not defined if E has the hint :Stateless.\n\nSee also apply!, checked, edges, neighborids, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.neighborids","page":"Transition Function","title":"Vahana.neighborids","text":"neighborids(sim, id::AgentID, ::Type{E})\n\nReturns the ID of the agent on the source of the edge of type E with agent id as target if E has the hint :SingleEdge, or otherwise a vector of the IDs of the agents on the source side of those edges.\n\nIf there is no edge with agent id as target, neighborids returns nothing.\n\nneighborids is not defined if E has the hint :IgnoreFrom.\n\nSee also apply!, checked, edges, edgestates, num_edges, has_edge and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Vahana.num_edges-Tuple{Vahana.Simulation, UInt64, Type}","page":"Transition Function","title":"Vahana.num_edges","text":"num_edges(sim, id::AgentID, ::Type{E})\n\nReturns the number of edges of type E with agent id as target.\n\nnum_edges is not defined if T has the hint :SingleEdge\n\nSee also apply!, edges, neighborids, edgestates, has_edge and neighborstates\n\n\n\n\n\n","category":"method"},{"location":"transition.html#Vahana.has_edge","page":"Transition Function","title":"Vahana.has_edge","text":"has_edge(sim, id::AgentID, ::Type{E})\n\nReturns true if there is at least one edge of type E with agent id as target.\n\nhas_edge is not defined if T has the :SingleEdge and :SingleType hints, with the exception that it has also the :IgnoreFrom and :Stateless hints.\n\nSee also apply!, edges, neighborids, edgestates, num_edges and neighborstates\n\n\n\n\n\n","category":"function"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"For all the function like edges that returns nothing in the case that there is no edge with the agent as target, it can be useful to increase the readability of the code by using the checked function to test for nothing.","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"checked","category":"page"},{"location":"transition.html#Vahana.checked","page":"Transition Function","title":"Vahana.checked","text":"checked(f, g, itr; kwargs...)\n\nCalls g(f, itr; kwargs...), but only if itr != nothing.\n\nAs all the Vahana functions that access the edges of a specific agent can return nothing in the case, that there exist no incoming edge for this agent, it's often necessery to check this case. \n\nExample:\n\nInstead of writing \n\nnids = neighborids(sim, id, Contact)\nif nids != nothing\n    foreach(nids) do nid\n      add_edge!(sim, id, nid, Inform()\n    end\nend\n\nyou can use the checked function to write\n\nchecked(foreach, neighborids(sim, id, Contact)) do nid\n    add_edge!(sim, id, nid, Inform())\nend\n\n\n\n\n\n","category":"function"},{"location":"transition.html#Add-Agents/Edges","page":"Transition Function","title":"Add Agents/Edges","text":"","category":"section"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"The following functions from the [Initialization] section (initialization.md) that add new agents or edges to a simulation can also be used inside a transition function, namely:","category":"page"},{"location":"transition.html","page":"Transition Function","title":"Transition Function","text":"add_agent! and add_agents!\nadd_edge! and add_edges!\nconnect_raster_neighbors!\nmove_to!","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../examples/tutorial1.jl\"","category":"page"},{"location":"tutorial1.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial1.html#Goal","page":"Tutorial","title":"Goal","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will build a model with multiple buyers and sellers, whereby the buyers will always randomly choice a seller from a fixed subset of the sellers. This subset is of course different for each buyer.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We use this model to give a first introduction to Vahana, focusing on the core elements but already working with different types of agents and edges between them.","category":"page"},{"location":"tutorial1.html#Model-Background","page":"Tutorial","title":"Model Background","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We have a simple but volatile market with n buyers, m sellers, and two goods called x and y. Each seller sells both commodities, buyers buy both commodities from a single seller, but at each step the buyer randomly selects a seller from a fixed subset of all sellers. We are only interested in relative prices, so the price for good x is set to 1, the price for good y is p.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"At each step, each buyer has a constant fixed budget B for buying the commodities. The quantities are choosen using a Cobb-Douglas utility function:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"beginaligned\nmax_xy u(x y) = x^alpha cdot y^1 - alpha \ntextrmst  x + y cdot p leq B\nendaligned","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The solution of this optimization is:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"beginaligned\nx = B cdot alpha \ny = fracB cdot (1 - alpha)p\nendaligned","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"For illustrative reasons, we neglect production except for the assumption that x and y are joint products, so that the seller tries to find a price where x = y. In the case of a single buyer, the solution is p = frac1 - alphaalpha.  But in our case, the sellers are facing different buyers with different preferences alpha and a different budget B. So they start with a random price and adjust that price at each time step:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"beginaligned\np_t = fracd_yd_x cdot p_t-1 \ntextrmwhere  d_x = sum_b in textrmbuyersx_b quad d_y = sum_b in textrmbuyers y_b\nendaligned","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"It's easy to see that in the single buyer case, this will lead to p = frac1 - alphaalpha after a single step.","category":"page"},{"location":"tutorial1.html#Initialization","page":"Tutorial","title":"Initialization","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In addition to the Vahana package, we also need the Random package to initialize the buyer with different random values for B and alpha and to select a seller from the list of known sellers.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"using Vahana\nusing Random\n\ndetect_stateless(true); #hide\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We have two types of agents, Buyer and Seller. In Vahana, agents are defined as (immutable) structs. The structs define the state of the various agent types. All the types defined for the Model must be \"plain data\" types. Such a type is call isbitstype in Julia, and must fulfill the following contrains: A bitstype is immutable and contains no references to other values, only primitive types and other isbitstype types. This also implies that the type of a struct variables must be declared.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Since we want to calculate the average price of y later, the seller needs to store the quantity of the sold good y. So we have:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"struct Buyer\n    α::Float64\n    B::Float64\nend\n\nstruct Seller\n    p::Float64\n    d_y::Float64 # the sum of bought goods y (for a single time step)\nend","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We also write constructors for these agents. For the Buyer we want for alpha a random value between zero and one, and for B a random integer betwenn 1 and 100. The initial price p of a seller should be between 0.5 and 1.5.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Buyer() = Buyer(rand(), rand((1:100)))\n\nSeller() = Seller(rand() + 0.5, 0);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"And we have also two types of networks. The first is fixed and describes the sellers known to a single buyer. Since the direction of an edge determines the flow of information and the buyer needs the price information to calculate his demand, it is a network from sellers to buyers. We call this network KnownSeller.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"As for the agents we must define a struct for each type of network. The edges of the KnownSeller network do not carry additional information, so we define them just as a struct without any field, and will use them as a kind of a tag later to select only the edges of this type.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"struct KnownSellers end","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"As you can see, this type does not contain any information about the source or target agent of the edge (we have always directed edges in Vahana). Vahana declares the parametric type","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"struct Edge{T}     from::AgentID     state::T end","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"where T is in our case the KnownSeller. from is the agent on the source of the edge, but the target of the edge is missing. The edges are stored in containers like a Dict{AgentID, Vector{Edge{T}}} (the concrete container depends on so called hints, see Edge Hints, where the keys are the target agents, so adding the target also to the Edge struct is redundant and would only consume memory and CPU cycles unnecessarily.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We continue now with the second network Bought that will be constructed in the transition function called calc_demand which will be the implementation of equation (\\ref{eqn:demand}). This network describes from which seller a buyer bought something, so it edge will go from the buyers to the sellers. And those edges come with additional state, which provides the quantity of the bought goods:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"struct Bought\n    x::Float64\n    y::Float64\nend","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Sometimes we want to add these quantities, so we define a + operator for this structure","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"import Base.+\n+(a::Bought, b::Bought) = Bought(a.x + b.x, a.y + b.y);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Before we can construct our simulation, we need to define two additional structures. The first structure contains the parameters of the simulation.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Base.@kwdef struct Params\n    numBuyer::Int64\n    numSeller::Int64\n    knownSellers::Int64\nend;\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We use the @kwdef macro here only for code readability reasons, as this allows us to use the name of the parameters in the Params constructor.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The second struct allows us to add a global state to the simulation, which can be an exogenous input or an (aggregated) state from the simulation itself. This global state can then be used for the agents' decisions or, as in our case, as the output of the simulation, namely the development of the average price and excess demand.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"mutable struct Globals\n    x_minus_y::Vector{Float64}\n    p::Vector{Float64}\nend","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We now have all the elements needed to construct an uninitialized simulation. Therefore we combine first all the Agent- and Edgetypes into a ModelTypes collection, via the register_agenttype! and register_edgetype! functions, and then call contruct_model on this collection.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"const model = ModelTypes() |>\n    register_agenttype!(Buyer) |>\n    register_agenttype!(Seller) |>\n    register_edgetype!(KnownSellers) |>\n    register_edgetype!(Bought) |>\n    create_model(\"Excess Demand\");\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"create_model returns a blueprint for our simulation. Simulations itself can be seen as instances of models, where each simulation has it's individual state and set of parameters. The Simulation is instanciated by the create_simulation function, which needs beside the model also the parameters struct and the globals struct, whereby the parameters and globals can be also nothing.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"const sim = create_simulation(model,\n                              Params(numBuyer = 50,\n                                     numSeller = 5,\n                                     knownSellers = 2),\n                              Globals(Vector(),\n                                      Vector()))","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Now we can also populate our simulation with the agents and the KnownSeller network (the Bought network is a result of the calc_demand transition, and therefore no edges are added in the initialization phase).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Vahana therefore has the functions add_agent! or add_agents!, where add_agents can be used to add multiple agents at once. These functions return ID(s) of the agent(s), which can be used to create edges between agents. Do not use the IDs for other purposes, they are not guaranteed to be stable, e.g. the ID of an agent may change in the finish_init! call. in a parallel simulation finish_init! may \"moved\" to another (MPI) rank, and as the ID contains Vahana internal information like the rank, the agent will have a different ID afterwards. It is also possible that the same ID is used twice for different agents. So an ID returned by a call to a Vahana function or passed as an argument to callback function (see Transition functions below) can only be used until finish_init! is called or the callback/transition function is finished. In the case that you need a stable ID, you need to add such an ID to the agent state and create these IDs by yourself (e.g. using the UUIDs functions).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In our case, we use the IDs returned by add_agents! to iterate over all buyer IDs, randomly select numSellers seller IDs for each buyer ID, and then create edges between them in the KnownSellers network.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We can see in the following code fragment also how parameters of the Simulation can be accessed via the param function.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"buyerids = add_agents!(sim, [ Buyer() for _ in 1:param(sim, :numBuyer)])\n\nsellerids = add_agents!(sim, [ Seller() for _ in 1:param(sim, :numSeller)])\n\nfor b in buyerids\n    for s in rand(sellerids, param(sim, :knownSellers))\n        add_edge!(sim, s, b, KnownSellers())\n    end\nend\n\nsim","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"As you can see from the result of the code block above, Vahana has a \"pretty print\" function for some of its data structures.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"To complete the initialization it is necessary to call finish_init!. In the later MPI version this will be used e.g. to distribute the graph to the different processes. The function also sets all containers to a read-only state, which is why the (R/W) part is now omitted in the output.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"finish_init!(sim)","category":"page"},{"location":"tutorial1.html#Transition-functions","page":"Tutorial","title":"Transition functions","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We have now a simulation with an initial state. To modify the state we need to define transition functions. Those functions have the signature transition_function(agent::T, id::AgentID, sim::Simulation).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The argument agent contains the state of a single agent of the type T. The argument id contains the id of this agent, as the id is not part of the agent state itself, and maybe needed for constructing new edges.","category":"page"},{"location":"tutorial1.html#calc_demand","page":"Tutorial","title":"calc_demand","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The first transition function we are implementing calculates the demand for the goods x and y as shown in equation (\\ref{eqn:demand}).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"This transition function is called for all Buyers. First the edge_to function is used to get a Vector that cotains all the sellers known by b. It's important to call edges only for id, and not e.g. to from IDs of edges derived by edges.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"One of the available edges to a sellers is selected using the rand function. For this seller the state is accessed via the agentstate function. In the case that the type of the agent from which we want to access the state is unknown, it's possible to use the agentstate_flexible instead.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Then the agent calculates it's demand for the goods x and y, and adds an edge with the information about the demand to the Bought network, which is then used in the next transition function by the sellers to sum up the demand and calculate the new price.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"function calc_demand(b::Buyer, id, sim)\n    seller = rand(neighborids(sim, id, KnownSellers))\n    s = agentstate(sim, seller, Seller)\n    x = b.B * b.α\n    y = b.B * (1 - b.α) / s.p\n    add_edge!(sim, id, seller, Bought(x, y))\nend;\nnothing #hide","category":"page"},{"location":"tutorial1.html#calc_price","page":"Tutorial","title":"calc_price","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In the calc_price transition function the sellers summarise all the goods x and y they sold. Therefore they first get all the Bought edges that are pointing to them via the network(sim, Bought).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In the case that a seller did not sold anything, and therefore no edge exists with the seller as target, edgestates returns nothing and the seller does not change its state. Otherwise the edgestates function returns a Vector that contains the states of all the edges. We can aggregate this vector with the reduce function (remember that we have defined the + operator for Bought above).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Then we construct a new seller. q.y / q.x * s.p is thereby the new price as shown in equation (\\ref{eqn:price}).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"function calc_price(s::Seller, id, sim)\n    sold = edgestates(sim, id, Bought)\n    if isnothing(sold)\n        return s\n    end\n    q = reduce(+, sold)\n    Seller(q.y / q.x * s.p, q.y)\nend;\nnothing #hide","category":"page"},{"location":"tutorial1.html#applying-the-transition-functions","page":"Tutorial","title":"applying the transition functions","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"To apply our defined transistion functions to the simulation, Vahana provides the apply! function with the signature apply!(sim, f::Function, call, read, write; add_existing).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"f is in our case one of the transition functions we have already defined above. call is a collection of agent types. In most cases (like here) this collection will only contain a single type, but in general it's possible to define a transition function for multiple agent types (e.g. just define also calc_demand(s::Seller, ...)) in the case that sellers could also bought goods from other sellers, and add Seller to the call collection).","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The read collection must contain all agent and edge state types that are accessed in the transition function. Among other things, this transmit in a parallel run the agents and edges to all processes that need to access them. If the Vahana assertion system is active, it checks that only these types are accessed, but if it is disabled via enable_asserts, forgetting to add types to read can lead to incorrect results. Having more types than necessary in the read collection, on the other hand, only leads to worse performance.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"In the case that the call type is not in read (we do not have this case in this tutorial), the first argument of the transition function is no longer the agent state, and instead the type of the first argument is a Value Type of this call type.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"The write collection must contain all agent and edge state types that are changed in the transition function. In the purest conceptional form (and the first prototypes), the resulting graph of a transition function is the union of the returned agents and edges of all transition function calls, but of course this causes a lot of overhead since stable parts of the graph must also be reconstructed. Instead of this radical behaviour, Vahana removes only the part of the graph that are part of the write collection. Which also implies, that you can only change the state of agents/edges of a types when you readding also the state of constant elements of that type. In the case that you want e.g. additional edges without changing the existing one, you can use the optional keyword add_existing, which is aslo a collection of agent or edge state types. For all types in the collection the existing agents/edges will not be removed even when the type is also in the write collection.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"This may sound complicated, but in practice the procedure is actually quite straightforward. Write your transition function as we did above, then check what types of agents the transition function should be called for and add those types to call. Then check which types appear in function calls like edgestates and add them to read. Are you accessing the first argument of the transition function (the state of the agent itself)? Then add that type to read as well. Do you want to return a changed state of the agent. Then add that type to write. Do you have additional add_edge! or add_agent! calls. Then add their type to write as well. And note that all current agents/edges will be removed from the simulation as long as their type is not also in add_existing.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Following this schema we get for our transition functions","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"sim2 = apply(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSellers ], Bought);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"and","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"sim3 = apply(sim2, calc_price, Seller, [ Seller, Bought ], Seller);\nnothing #hide","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"We used here a version of the apply which returns a copy of the simulation instead of changing the simulation inplace. This can be usefull while implementing the model in the REPL, as the transition does not destroy the original state, but should not be used in production, here always the apply! should be used.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"But here we can now simply compare the simulation states before and after calling the transition functions:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"all_agents(sim, Seller)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"and","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"all_agents(sim3, Seller)","category":"page"},{"location":"tutorial1.html#Globals","page":"Tutorial","title":"Globals","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"However, our goal was to obtain a time series for the average price and the excess demand. Vahana does not allow direct access to agent state, but follows the MapReduce pattern from functional programming. The Map part allows mapping an agent or edge state to a new value, and the Reduce part describes how the new values should be combined into a single value.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"E.g. to calculate the excess demand we write","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"mapreduce(sim2, b -> b.x - b.y, +, Bought)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"where the second argument specifies for which agent or edge type the aggregation should be performed, and the anonymous function in the third place describes the assignment for each instance of that type. In our case, the function gets an edge of type Bought and calculates how much more of good x was bought. And this is then added for all edges.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"To calculate the average price we define a helper function","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"function calc_average_price(sim)\n    m = mapreduce(sim, s -> s.p * s.d_y, +, Seller)\n    q = mapreduce(sim, s -> s.d_y, +, Seller)\n    m / q\nend\n\ncalc_average_price(sim3)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"And now we have all elements to run the simulation, e.g. for 100 steps:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"for _ in 1:100\n    apply!(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSellers ], Bought)\n    push_global!(sim, :x_minus_y, mapreduce(sim, b -> b.x - b.y, +, Bought))\n    apply!(sim, calc_price, Seller, [ Seller, Bought ], Seller)\n    push_global!(sim, :p, calc_average_price(sim))\nend","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"To get the resulting timeseries, we use the getglobal function:","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"get_global(sim, :p)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"and","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"get_global(sim, :x_minus_y)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Or we can convert the globals to a DataFrame. Therefore we must first import the DataFrames package, and can then call a DataFrame constructor","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"import DataFrames\n\nDataFrame(sim, Globals)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"But we can also create a DataFrame for the agent and edgetypes, e.g.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"DataFrame(sim, Bought)","category":"page"},{"location":"tutorial1.html#Finish-the-simulation","page":"Tutorial","title":"Finish the simulation","text":"","category":"section"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"Vahana uses internally a C library and also allocates memory via this library. So when you have finished your simulation and want to free the memory, you must call finish_simulation.","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"finish_simulation!(sim)","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial1.html","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = Vahana -->","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Vahana.jl is an open-source high-performance software framework for the development of large-scale agent-based models (ABM) of complex social systems. Vahana is based on a discrete dynamical systems formulation referred to as a synchronous graph dynamical system (SyGDS)[1], which is a generalization of cellular automata (CA). In a CA the cells can be interpreted as the agents, and when a cell/agent updates its state according to a rule, the new state depends only on the current state of the cell and the states of the cells in its neighborhood.  In a SyGDS, the vertices of the graph are the agents of the model, and the (directed) edges determine the neighborhood.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Vahana extends the SyGDSs concept so that even complex models like the Mobility Transition Model (https://github.com/CoeGSS-Project/motmo) or MATSim Episim (https://github.com/matsim-org/matsim-episim-libs) can be expressed as a SyGDS. The vertices are representing the agents and may be of different types and have a state that belongs to a type-specific state space.  Edges between the agents are directed, if a transition of agent a depends on the state of agent b, an edge from b to a is needed. Edges may also have different types (represent different kinds of interactions) and may have also a state.  There can be multiple transition functions (which are the equivalent of a rule in a CA), and each transition function can act on a different subgraph.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(Discrete) spatial information can be added using Vahana functions that insert grid cells as nodes in the graph and have access to a mapping from the Cartesian index of the underlaying space to the corresponding node. Since the cells are vertices of the graph, they can be treated in the same way as other agents","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To model the system's dynamic evolution, we consider discrete time steps. At each step t, there is a set of vertices which can change their own state and also add new vertices and edges.  The new state of a node at time t is computed based only on information from the previous step.  Information from step t-1 usually includes the previous state of the agent itself, and may include states of adjacent agents in the graph, possibly also the states of the respective edges themselves. The underlying idea is that of a functional programming approach: the transition cannot be implicitly affected by any other mutable state or unintended side effects.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"So expressing a model as a SyGDS has the advantage that a single simulation can be computed in parallel. Vahana therefore allows the simulation to be distributed across multiple nodes of a computer cluster, enabling the simulation of large-scale models that do not fit on a single node.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Parallelization is done through the Message Passing Interface (via the MPI.jl package), but this is hidden to the user. Any model developed with Vahana can be automatically computed in parallel by simply starting the simulation via mpirun. The challenge for the user is mainly to think about how to express the model as a SyGDS, rather than thinking about technical details of the implementation such as which data structure is best to use.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: Adiga, A., Kuhlman, C.J., Marathe, M.V. et al. Graphical dynamical systems and their applications to bio-social systems. https://doi.org/10.1007/s12572-018-0237-6","category":"page"}]
}
