<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>First Steps · Vahana Documentation</title><meta name="title" content="First Steps · Vahana Documentation"/><meta property="og:title" content="First Steps · Vahana Documentation"/><meta property="twitter:title" content="First Steps · Vahana Documentation"/><meta name="description" content="Documentation for Vahana Documentation."/><meta property="og:description" content="Documentation for Vahana Documentation."/><meta property="twitter:description" content="Documentation for Vahana Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Vahana Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href="tutorial1.html">First Steps</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Goal"><span>Goal</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-Overview"><span>Model Overview</span></a></li><li class="toplevel"><a class="tocitem" href="#Agent-and-Edge-Types"><span>Agent and Edge Types</span></a></li><li class="toplevel"><a class="tocitem" href="#Defining-the-Model-Structure"><span>Defining the Model Structure</span></a></li><li class="toplevel"><a class="tocitem" href="#Defining-Model-Parameters-and-Globals"><span>Defining Model Parameters and Globals</span></a></li><li class="toplevel"><a class="tocitem" href="#Create-the-Model-and-Simulation"><span>Create the Model and Simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Populating-the-Simulation"><span>Populating the Simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Defining-Transition-Functions"><span>Defining Transition Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Applying-Transition-Functions"><span>Applying Transition Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Working-with-Globals"><span>Working with Globals</span></a></li><li class="toplevel"><a class="tocitem" href="#Investigating-the-Simulation-State"><span>Investigating the Simulation State</span></a></li><li class="toplevel"><a class="tocitem" href="#Finish-the-Simulation"><span>Finish the Simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Understanding-Vahana&#39;s-Edge-Structure"><span>Understanding Vahana&#39;s Edge Structure</span></a></li></ul></li><li><a class="tocitem" href="hegselmann.html">Utilizing Graphs.jl</a></li><li><a class="tocitem" href="predator.html">Adding Spatial Information</a></li></ul></li><li><a class="tocitem" href="performance.html">Performance Tuning</a></li><li><a class="tocitem" href="parallel.html">Parallel Simulations</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="definition.html">Model Definition</a></li><li><a class="tocitem" href="initialization.html">Initialization</a></li><li><a class="tocitem" href="transition.html">Transition Function</a></li><li><a class="tocitem" href="global.html">Global Layer</a></li><li><a class="tocitem" href="raster.html">Raster</a></li><li><a class="tocitem" href="plots.html">Plots</a></li><li><a class="tocitem" href="hdf5.html">File storage</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="config.html">Configuration</a></li><li><a class="tocitem" href="misc.html">Misc</a></li><li><a class="tocitem" href="apiindex.html">Index</a></li></ul></li><li><a class="tocitem" href="changelog.html">Change Log</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="tutorial1.html">First Steps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial1.html">First Steps</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/s-fuerst/Vahana.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/s-fuerst/Vahana.jl/blob/5ef46fe540983354cdc718c83883db8841a6763d/docs/examples/tutorial1.jl" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="First-Steps"><a class="docs-heading-anchor" href="#First-Steps">First Steps</a><a id="First-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#First-Steps" title="Permalink"></a></h1><h1 id="Goal"><a class="docs-heading-anchor" href="#Goal">Goal</a><a id="Goal-1"></a><a class="docs-heading-anchor-permalink" href="#Goal" title="Permalink"></a></h1><p>In this tutorial, we will build a simple market model with multiple buyers and sellers. Each buyer has a fixed budget and preferences for two goods, x and y. Sellers offer these goods, and buyers purchase from a randomly selected subset of sellers at each time step.</p><p>The model illustrates several core concepts in Vahana, including:</p><ol><li>Defining agent and edge types as structs</li><li>Initializing a simulation with agents and edges</li><li>Implementing transition functions to update agent states</li><li>Tracking simulation results</li></ol><p>This simple model serves as an introduction to Vahana&#39;s capabilities for agent-based modeling. While relatively basic, it demonstrates how to represent a multi-agent system with different types of agents, connections between agents, and state transitions driven by agent interactions.</p><h1 id="Model-Overview"><a class="docs-heading-anchor" href="#Model-Overview">Model Overview</a><a id="Model-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Overview" title="Permalink"></a></h1><p>Our model simulates a dynamic market with <span>$n$</span> buyers and <span>$m$</span> sellers, trading two types of goods: <span>$x$</span> and <span>$y$</span>. We use good <span>$x$</span> as the numeraire, fixing its price at 1, while the price of good <span>$y$</span>, denoted as <span>$p$</span>, is variable and adjusted by sellers over time.  Each buyer in our market has a unique preference and a constant budget <span>$B$</span> for purchasing both commodities. These preference is represented by an individual parameter α, which determines the buyer&#39;s relative desire for good <span>$x$</span> versus good <span>$y$</span>. Buyers make their purchasing decisions based on a Cobb-Douglas utility function:</p><p class="math-container">\[\max_{x,y} u(x, y) = x^\alpha \cdot y^{1 - \alpha}\]</p><p>subject to their budget constraint: <span>$x + y · p ≤ B$</span>. This utility maximization leads to an optimal demand for each good:</p><p class="math-container">\[\begin{aligned}
x &amp;= B \cdot \alpha \\
y &amp;= \frac{B \cdot (1 - \alpha)}{p}
\end{aligned}\]</p><p>On the supply side, sellers offer both goods <span>$x$</span> and <span>$y$</span>, which we assume to be joint products. Their primary goal is to balance the production and sales of these two goods. To achieve this, sellers adjust their prices based on the aggregate demand from their customers. The price adjustment mechanism is given by:</p><p class="math-container">\[\begin{aligned}
p_t &amp;= \frac{d_y}{d_x} \cdot p_{t-1} \\
\textrm{where } d_x &amp;= \sum_{b \in \textrm{buyers}}x_b ,\quad d_y = \sum_{b \in \textrm{buyers}} y_b
\end{aligned}\]</p><h1 id="Agent-and-Edge-Types"><a class="docs-heading-anchor" href="#Agent-and-Edge-Types">Agent and Edge Types</a><a id="Agent-and-Edge-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-and-Edge-Types" title="Permalink"></a></h1><p>Now that we understand our market model, let&#39;s implement it using Vahana. We&#39;ll start by defining our agent types and edge types, then create and initialize our simulation.</p><p>First, we need to import the necessary modules:</p><pre><code class="language-julia hljs">using Vahana
import Random: rand
import DataFrames</code></pre><p>In Vahana, agents and the edges between them are represented by Julia structs. However, these structs must meet specific requirements:</p><ol><li>They must be immutable.</li><li>They must be &quot;bitstypes&quot;.</li></ol><p>A bitstype in Julia is a type that is composed entirely of primitive types (like Int, Float64, Bool) or other bitstypes, and has a known, fixed size in memory.  This also implies that the type of a struct variables must be declared.</p><p>This restrictions allows Vahana to efficiently manage and distribute agents across processes in parallel simulations.</p><p>Let&#39;s define our agent types with these requirements in mind:</p><pre><code class="language-julia hljs">struct Buyer
    α::Float64  # Preference parameter
    B::Float64  # Budget
end

struct Seller
    p::Float64   # Current price of good y
    d_y::Float64 # Total demand for good y (used for price adjustment)
end</code></pre><p>To facilitate agent creation with some randomization, we&#39;ll define custom constructors:</p><pre><code class="language-julia hljs">Buyer() = Buyer(rand(), rand((1:100)))

Seller() = Seller(rand() + 0.5, 0);</code></pre><p>These constructors create:</p><ul><li>Buyers with random <span>$\alpha$</span> (between 0 and 1) and <span>$B$</span> (between 1 and 100)</li><li>Sellers with a random initial price <span>$p$</span> (between 0.5 and 1.5) and zero initial demand.</li></ul><p>Now, let&#39;s look at our edge types in more detail:</p><p>This <code>KnownSeller</code> network is fixed and describes the sellers known to each buyer. In Vahana, the direction of an edge determines the flow of information. Since buyers need price information from sellers to calculate their demand, we define this as an edge from sellers to buyers. We call this network KnownSeller.</p><p>The edges of the <code>KnownSeller</code> network don&#39;t carry additional information, so we define them as an empty struct. We&#39;ll use this as a kind of tag later to select only the edges of this type.</p><pre><code class="language-julia hljs">struct KnownSeller end</code></pre><p>The Bought network represents actual transactions between buyers and sellers. This network is dynamic, with edges created during the simulation runtime. Each edge in the Bought network carries information about the quantities of goods purchased in a transaction. Specifically:</p><pre><code class="language-julia hljs">struct Bought
    x::Float64  # Quantity of good x bought
    y::Float64  # Quantity of good y bought
end</code></pre><p>To make working with Bought edges easier, we&#39;ll define an addition operation:</p><pre><code class="language-julia hljs">import Base.+
+(a::Bought, b::Bought) = Bought(a.x + b.x, a.y + b.y);</code></pre><p>This allows us to easily sum up multiple Bought edges, which will be useful when sellers calculate total demand.</p><h1 id="Defining-the-Model-Structure"><a class="docs-heading-anchor" href="#Defining-the-Model-Structure">Defining the Model Structure</a><a id="Defining-the-Model-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Model-Structure" title="Permalink"></a></h1><p>In Vahana, the <a href="definition.html#Vahana.ModelTypes"><code>ModelTypes</code></a> constructor is the starting point for defining the structure of your agent-based model. To populate this instance, we use the <code>register_agenttype!</code> and <code>register_edgetype!</code> functions. These functions tell Vahana about the types of agents and edges in your model, allowing it to set up the necessary internal data structures and optimizations. The |&gt; operator can be used for function chaining, providing a concise way to register multiple types.</p><pre><code class="language-julia hljs">const modeltypes = ModelTypes() |&gt;
    register_agenttype!(Buyer) |&gt;
    register_agenttype!(Seller) |&gt;
    register_edgetype!(KnownSeller) |&gt;
    register_edgetype!(Bought);</code></pre><h1 id="Defining-Model-Parameters-and-Globals"><a class="docs-heading-anchor" href="#Defining-Model-Parameters-and-Globals">Defining Model Parameters and Globals</a><a id="Defining-Model-Parameters-and-Globals-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Parameters-and-Globals" title="Permalink"></a></h1><p>Vahana offers two ways to define parameters for your model: using <code>register_param!</code> or creating a custom parameter struct. The <code>register_param!</code> function allows you to register individual parameters with your model. For example, you might use:</p><pre><code class="language-julia hljs">modeltypes |&gt;
    register_param!(:numBuyer, 50) |&gt;
    register_param!(:numSeller, 5) |&gt;
    register_param!(:knownSellers, 2);</code></pre><p>With this approach, the parameters can then be set to values other than the default value via <a href="initialization.html#Vahana.set_param!"><code>set_param!</code></a> calls until the simulation is initialized with <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a>.</p><p>Alternatively you can define a custom parameter struct and then pass an instance of this struct to <a href="definition.html#Vahana.create_simulation"><code>create_simulation</code></a>.</p><p>In addition to parameters, Vahana allows you to manage global state variables that can change during the simulation. This is particularly useful for tracking aggregate statistics or maintaining shared information across all agents. Similar to parameters, you can register individual global variables:</p><pre><code class="language-julia hljs">modeltypes |&gt;
    register_global!(:x_minus_y, Vector{Float64}()) |&gt;
    register_global!(:p, Vector{Float64}());</code></pre><p>Again, you could alternatively, you can define a custom struct for globals and pass an instance of this struct to <a href="definition.html#Vahana.create_simulation"><code>create_simulation</code></a> as shown in the other tutorials.</p><p>Please note that Vahana&#39;s global state is distinct from the functionality of the <code>global</code> keyword in Julia programming language. The two concepts are unrelated and should not be conflated.</p><h1 id="Create-the-Model-and-Simulation"><a class="docs-heading-anchor" href="#Create-the-Model-and-Simulation">Create the Model and Simulation</a><a id="Create-the-Model-and-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Create-the-Model-and-Simulation" title="Permalink"></a></h1><p>In Vahana, the term &quot;model&quot; is used in a somewhat unconventional way compared to other agent-based modeling frameworks.  In Vahana, a model created via <a href="definition.html#Vahana.create_model"><code>create_model</code></a> does not contain any rules about how the state of a simulation changes over time. Instead, a Vahana model is more akin to a specification of the possible state space - it defines the set of all possible graphs that can be created with the specified agent and edge types.</p><p>Think of a Vahana model as a blueprint or a schema. It outlines the structure of your simulation - what types of agents can exist, what types of relationships (edges) can exist between them, and what global parameters and variables are available. However, it doesn&#39;t dictate how these elements interact or evolve over time.</p><p>A simulation, on the other hand, is a concrete realization within this state space. It&#39;s an actual graph with specific agents and edges, representing the current state of your simulated world at a given point in time.</p><p>Transition functions, which we&#39;ll define later, are the mechanisms that actually change the state of the simulation over time. These functions operate on the current state of the simulation (the current graph of agents and edges) and produce a new state by modifying agent attributes, creating or removing agents and edges, and updating global variables.</p><p>To create a model in Vahana, we use the <a href="definition.html#Vahana.create_model"><code>create_model</code></a> function. This function takes the ModelTypes object we&#39;ve been building through our type registrations and parameter/globals definitions, and the name of the model:</p><pre><code class="language-julia hljs">const model = create_model(modeltypes, &quot;Excess Demand&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
<span class="sgr35">Model Name: Excess Demand</span>
<span class="sgr36">Agent(s):</span>
	 Type Buyer
	 Type Seller
<span class="sgr36">Edge(s):</span>
	 Type KnownSeller with Hint(s): Stateless
	 Type Bought
<span class="sgr36">Parameter(s) with default values:</span>
	numBuyer: 50
	numSeller: 5
	knownSellers: 2
<span class="sgr36">Global(s) with init values:</span>
	x_minus_y: Float64[]
	p: Float64[]</code></pre><p>Once we have a model, we can create a simulation based on that model using the <a href="definition.html#Vahana.create_simulation"><code>create_simulation</code></a> function:</p><pre><code class="language-julia hljs">const sim = create_simulation(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
<span class="sgr35">Model Name: Excess Demand</span>
<span class="sgr35">Simulation Name: Excess Demand</span>
<span class="sgr36">Agent(s):</span>
	 Type Buyer with 0 agent(s)
	 Type Seller with 0 agent(s)
<span class="sgr36">Edge(s):</span>
	 Type KnownSeller with 0 edge(s) for 0 agent(s)
	 Type Bought with 0 edge(s) for 0 agent(s)
<span class="sgr36">Parameter(s):</span>
	 :numBuyer : 50
	 :numSeller : 5
	 :knownSellers : 2
<span class="sgr36">Global(s):</span>
	 :x_minus_y (empty)<span class="sgr33"> </span>
	 :p (empty)<span class="sgr33"> </span>
<span class="sgr31">Still in initialization process!.</span></code></pre><p>This function creates a new simulation instance based on our model. At this point, the simulation is empty - it doesn&#39;t contain any agents or edges yet. It&#39;s essentially a blank canvas ready for us to populate with agents and edges according to our model&#39;s specifications.</p><h1 id="Populating-the-Simulation"><a class="docs-heading-anchor" href="#Populating-the-Simulation">Populating the Simulation</a><a id="Populating-the-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Populating-the-Simulation" title="Permalink"></a></h1><p>After creating our simulation, the next step is to populate it with agents and edges. Vahana provides <a href="initialization.html#Vahana.add_agent!"><code>add_agent!</code></a>, <a href="initialization.html#Vahana.add_agents!"><code>add_agents!</code></a>, <a href="initialization.html#Vahana.add_edge!"><code>add_edge!</code></a>, and <a href="initialization.html#Vahana.add_edges!"><code>add_edges!</code></a> functions for this purpose.</p><p>The <a href="initialization.html#Vahana.add_agent!"><code>add_agent!</code></a> function returns an <code>AgentID</code>, while <a href="initialization.html#Vahana.add_agents!"><code>add_agents!</code></a> returns a vector of <code>AgentID</code>s. These identifiers are unique to each agent at the current state of the simulation.</p><p>In parallel simulations, the <code>AgentID</code> incorporates information about the process number to which the agent is assigned. Consequently, the ID may be modified if an agent is reassigned to a different process. In the current implementation of Vahana, agents only change processes during the <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> function. However, this design allows for potential future implementation of dynamic load balancing.</p><p>It is also possible that the same <code>AgentID</code> is utilized multiple times for distinct agents. Consequently, an <code>AgentID</code> returned by a Vahana function call or passed as an argument to a callback function (refer to the <a href="performance.html#Transition functions">Transition functions</a> section below for more details) is only valid within a specific scope. This scope is limited to either the period before the finish_init! function is invoked or until the callback/transition function has completed its execution. After these points, the ID should not be considered reliable for further use or reference.</p><p>If your model requires persistent identification of agents, you should implement this yourself by adding an ID field to your agent struct. You would then manage these IDs yourself, ensuring they remain constant throughout the simulation. When working with string-based identifiers or other string fields within a struct that need to be stored in an HDF5 file, please consult the documentation for the <a href="hdf5.html#Vahana.create_string_converter"><code>create_string_converter</code></a> function. It is also important to note that the HDF5 format does not support 128-bit integers. Consequently, the UUID package is not compatible with the current version of HDF5.jl.</p><p>In our case, we use the IDs returned by add_agents! to iterate over all buyer IDs, randomly select <code>numSellers</code> seller IDs for each buyer ID, and then create edges between them in the <code>KnownSeller</code> network.</p><p>We can see in the following code snippet also how parameters of the Simulation can be accessed via the <a href="transition.html#Vahana.param"><code>param</code></a> function.</p><pre><code class="language-julia hljs">buyerids = add_agents!(sim, [ Buyer() for _ in 1:param(sim, :numBuyer)])

sellerids = add_agents!(sim, [ Seller() for _ in 1:param(sim, :numSeller)])

for b in buyerids
    for s in rand(sellerids, param(sim, :knownSellers))
        add_edge!(sim, s, b, KnownSeller())
    end
end

sim</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
<span class="sgr35">Model Name: Excess Demand</span>
<span class="sgr35">Simulation Name: Excess Demand</span>
<span class="sgr36">Agent(s):</span>
	 Type Buyer with 50 agent(s)
	 Type Seller with 5 agent(s)
<span class="sgr36">Edge(s):</span>
	 Type KnownSeller with 100 edge(s) for 50 agent(s)
	 Type Bought with 0 edge(s) for 0 agent(s)
<span class="sgr36">Parameter(s):</span>
	 :numBuyer : 50
	 :numSeller : 5
	 :knownSellers : 2
<span class="sgr36">Global(s):</span>
	 :x_minus_y (empty)<span class="sgr33"> </span>
	 :p (empty)<span class="sgr33"> </span>
<span class="sgr31">Still in initialization process!.</span></code></pre><p>As you can see from the result of the code block above, Vahana has &quot;pretty print&quot; functions for some of its data structures.</p><p>Finally, we call <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a>. This crucial step completes the initialization process, setting up data structures and, in parallel simulations, distributing agents across processes.</p><pre><code class="language-julia hljs">finish_init!(sim)</code></pre><h1 id="Defining-Transition-Functions"><a class="docs-heading-anchor" href="#Defining-Transition-Functions">Defining Transition Functions</a><a id="Defining-Transition-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Transition-Functions" title="Permalink"></a></h1><p>In Vahana, transition functions define how your simulation evolves from one state to the next. They encapsulate the rules and behaviors of your agents, determining how agents interact, make decisions, and change their states. The transition function is called for each agent separately.</p><p>A typical transition function in Vahana has the following signature:</p><pre><code class="language-julia hljs">function transition_function(state, id, sim)
    # Function body
    return new_agent_state
end</code></pre><p>A transition function must have three parameters. The first represents the current state of the agent, allowing it to make decisions based on its own attributes and conditions. The second parameter is the temporary ID of the agent. This ID can be used within the transition function to access other elements of the graph that are visible to the agent via functions like <a href="transition.html#Vahana.edges"><code>edges</code></a> or <a href="transition.html#Vahana.neighborstates"><code>neighborstates</code></a>. It&#39;s important to note that this ID should not be stored, as it may change between time steps.  Finally, there&#39;s <code>sim</code>, which is the simulation object. This provides access to the global state and parameters of the simulation. These three parameters together give the agent all the context it needs to determine its next state.</p><p>The first transition function we are implementing calculates the demand for the goods <span>$x$</span> and <span>$y$</span>.</p><p>This transition function is called for all Buyers. First, the <a href="transition.html#Vahana.neighborids"><code>neighborids</code></a> function is used to get a vector that contains the (temporary) IDs all the sellers known by the actual buyer.</p><p>One of the IDs of the sellers is selected using the <code>rand</code> function. For this seller, the state is accessed via the <a href="transition.html#Vahana.agentstate"><code>agentstate</code></a> function. In cases where the type of the agent whose state we want to access is unknown, it&#39;s possible to use <a href="transition.html#Vahana.agentstate_flexible"><code>agentstate_flexible</code></a> instead.</p><p>Then the agent calculates it&#39;s demand for the goods <span>$x$</span> and <span>$y$</span>, and adds an edge with the information about the demand to the <code>Bought</code> network, which is then used in the next transition function by the sellers to sum up the demand and calculate the new price.</p><pre><code class="language-julia hljs">function calc_demand(b::Buyer, id, sim)
    seller = rand(neighborids(sim, id, KnownSeller))
    s = agentstate(sim, seller, Seller)
    x = b.B * b.α
    y = b.B * (1 - b.α) / s.p
    add_edge!(sim, id, seller, Bought(x, y))
end;</code></pre><p>In the <code>calc_price</code> transition function, sellers summarize all the goods <span>$x$</span> and <span>$y$</span> they sold. They do this by summing the state of all incoming Bought edges.</p><p>If a seller hasn&#39;t made any sales (i.e., no incoming Bought edges exist), <a href="transition.html#Vahana.edgestates"><code>edgestates</code></a> returns <code>nothing</code>, and the seller&#39;s state remains unchanged. Otherwise, <code>edgestates</code> returns a Vector containing the states of all relevant edges. We aggregate this vector using the <code>reduce</code> function, leveraging the previously defined <code>+</code> operator for Bought.</p><p>Finally, we construct a new seller state. The new price is calculated as <code>q.y / q.x * s.p</code>.</p><pre><code class="language-julia hljs">function calc_price(s::Seller, id, sim)
    sold = edgestates(sim, id, Bought)
    if isnothing(sold)
        return s
    end
    q = reduce(+, sold)
    Seller(q.y / q.x * s.p, q.y)
end;</code></pre><h1 id="Applying-Transition-Functions"><a class="docs-heading-anchor" href="#Applying-Transition-Functions">Applying Transition Functions</a><a id="Applying-Transition-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Transition-Functions" title="Permalink"></a></h1><p>To apply these transition functions to the current state of a simulation, Vahana provides the <a href="transition.html#Vahana.apply!"><code>apply!</code></a> method. This method is the key mechanism for evolving the simulation state over time, executing our defined transition functions across the population of agents.  Let&#39;s examine its signature and behavior in more detail:</p><pre><code class="language-julia hljs">apply!(sim, func, call, read, write; add_existing = [], with_edge = nothing)</code></pre><p><code>sim</code> is the simulation instance and <code>func</code> is the transition function to be applied to the simulation state.</p><p>The <code>call</code> argument in <code>apply!</code> specifies which agent types the transition function should be applied to. This can be either a single agent type or a collection of agent types. In most cases, as in our market model, call will contain only a single type. For example, when we apply calc_demand, we only want to call it for Buyer agents. However, Vahana allows for more complex scenarios where a single transition function can be applied to multiple agent types. This flexibility allows for more complex agent interactions and behaviors within a single transition function, which can be particularly useful in models where different types of agents share similar behaviors or decision-making processes.</p><p>The <code>read</code> argument must include all agent and edge state types that are accessed in the transition function. This is particularly important in parallel simulations, as it ensures that all necessary data is transmitted to the processes that need to access it. When Vahana&#39;s assertion system is active, it checks that only these specified types are accessed. However, if assertions are disabled via <a href="config.html#Vahana.enable_asserts"><code>enable_asserts</code></a>, forgetting to include a type in read can lead to incorrect results without raising an error. It&#39;s worth noting that while including unnecessary types in read doesn&#39;t cause errors, it can negatively impact performance.</p><p>A noteworthy scenario occurs when the <code>call</code> type is excluded from the <code>read</code> set. In these instances, the transition function&#39;s first argument is altered. Rather than representing the agent state, it becomes a Value Type corresponding to the &#39;call&#39; type. Consequently, the state of the agent for which the transition function is invoked becomes inaccessible within the function itself.</p><p>The <code>write</code> collection must contain all agent and edge state types that are modified in the transition function. Conceptually, one might think of the resulting graph after a transition as the union of all agents and edges returned by individual transition function calls. However, this approach would be inefficient, requiring the reconstruction of even stable parts of the graph. Instead, Vahana optimizes this process by removing only the parts of the graph specified in the write collection. This means you can only change the state of agents or edges of a type if you&#39;re also re-adding the state of constant elements of that type.</p><p>But in cases where you want to add new elements (like additional edges) without modifying existing ones, you can use the optional <code>add_existing</code> keyword. This keyword takes a single or a collection of agent or edge state types. For all types in this collection, existing agents or edges will be preserved, even if the type is also in the write collection. This provides a flexible way to extend the graph without completely rebuilding it. But there is the restriction that agent types in <code>add_existing</code> can not be also in <code>call</code>.</p><p>The <code>with_edge</code> keyword restricts the application of the transition function to agents that are targets of a specified edge type. It&#39;s equivalent to manually checking for the presence of the edge for each agent before applying the function, but allows Vahana to optimize this operation internally. <code>with_edge</code> should only be used when a small proportion of agents have edges of the specified type. If most agents have this edge type, using with_edge may decrease performance compared to a manual check inside the transition function.</p><p>The implementation process, while seemingly complex, is quite straightforward in practice. Begin by crafting your transition function as previously demonstrated. Then, follow these steps:</p><ol><li>Identify the agent types for which the transition function should be invoked and include these types in the <code>call</code> parameter.</li><li>Examine the function calls, such as <a href="transition.html#Vahana.edgestates"><code>edgestates</code></a>, to determine which types are utilized. Add these types to the <code>read</code> parameter.</li><li>If you access the first argument of the transition function (representing the agent&#39;s state), include that type in the <code>read</code> parameter as well.</li><li>Should you intend to return a modified agent state, add that type to the <code>write</code> parameter.</li><li>If your function includes additional <code>add_edge!</code> or <code>add_agent!</code> calls, incorporate their respective types into the <code>write</code> parameter.</li><li>Be aware that all existing agents and edges will be removed from the simulation unless their types are also specified in the <code>add_existing</code> parameter.</li></ol><p>Following this schema we get for our transition functions</p><pre><code class="language-julia hljs">apply!(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSeller ], Bought);</code></pre><p>and</p><pre><code class="language-julia hljs">apply!(sim, calc_price, Seller, [ Seller, Bought ], Seller);</code></pre><h1 id="Working-with-Globals"><a class="docs-heading-anchor" href="#Working-with-Globals">Working with Globals</a><a id="Working-with-Globals-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Globals" title="Permalink"></a></h1><p>To summarize the state of a simulation, Vahana uses the map-reduce combination from functional programming. First, a function is applied to each agent or edge state, and then the result is reduced using a binary function.</p><p>E.g. to calculate the excess demand we write</p><pre><code class="language-julia hljs">mapreduce(sim, b -&gt; b.x - b.y, +, Bought)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-643.4508421278501</code></pre><p>The last argument of Vahana&#39;s mapreduce specifies the agent or edge type for which the aggregation should be performed. The anonymous function in the second position describes the assignment for each instance of that type. In this case, the function receives an edge of the &#39;Bought&#39; type and calculates the additional quantity of good x that was purchased. This value is then summed across all edges of the specified type.</p><p>To calculate the average price we define a helper function</p><pre><code class="language-julia hljs">function calc_average_price(sim)
    m = mapreduce(sim, s -&gt; s.p * s.d_y, +, Seller)
    q = mapreduce(sim, s -&gt; s.d_y, +, Seller)
    m / q
end

calc_average_price(sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.6138812107905367</code></pre><p>And now we have all elements to run the simulation, e.g. for 5 steps:</p><pre><code class="language-julia hljs">for _ in 1:5
    apply!(sim, calc_demand, Buyer, [ Buyer, Seller, KnownSeller ], Bought)
    push_global!(sim, :x_minus_y, mapreduce(sim, b -&gt; b.x - b.y, +, Bought))
    apply!(sim, calc_price, Seller, [ Seller, Bought ], Seller)
    push_global!(sim, :p, calc_average_price(sim))
end</code></pre><p>To get a resulting timeseries, we use the <a href="transition.html#Vahana.get_global"><code>get_global</code></a> function:</p><pre><code class="language-julia hljs">get_global(sim, :p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 1.287669931251145
 1.173269381255291
 1.1540756786786697
 1.3430127391888713
 1.3728599329103153</code></pre><h1 id="Investigating-the-Simulation-State"><a class="docs-heading-anchor" href="#Investigating-the-Simulation-State">Investigating the Simulation State</a><a id="Investigating-the-Simulation-State-1"></a><a class="docs-heading-anchor-permalink" href="#Investigating-the-Simulation-State" title="Permalink"></a></h1><p>Vahana offers several methods to examine the current state of your simulation. For example, the user-defined show methods for the model and simulation instances, which provide a quick summary of your model/simulation:</p><pre><code class="language-julia hljs">model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
<span class="sgr35">Model Name: Excess Demand</span>
<span class="sgr36">Agent(s):</span>
	 Type Buyer
	 Type Seller
<span class="sgr36">Edge(s):</span>
	 Type KnownSeller with Hint(s): Stateless
	 Type Bought
<span class="sgr36">Parameter(s) with default values:</span>
	numBuyer: 50
	numSeller: 5
	knownSellers: 2
<span class="sgr36">Global(s) with init values:</span>
	x_minus_y: Float64[]
	p: Float64[]</code></pre><pre><code class="language-julia hljs">sim</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
<span class="sgr35">Model Name: Excess Demand</span>
<span class="sgr35">Simulation Name: Excess Demand</span>
<span class="sgr36">Agent(s):</span>
	 Type Buyer with 50 agent(s)
	 Type Seller with 5 agent(s)
<span class="sgr36">Edge(s):</span>
	 Type KnownSeller with 100 edge(s) for 50 agent(s)
	 Type Bought with 50 edge(s) for 5 agent(s)
<span class="sgr36">Parameter(s):</span>
	 :numBuyer : 50
	 :numSeller : 5
	 :knownSellers : 2
<span class="sgr36">Global(s):</span>
	 :x_minus_y |&gt; last : -43.26708128590373 (length: 5)<span class="sgr33"> </span>
	 :p |&gt; last : 1.3728599329103153 (length: 5)<span class="sgr33"> </span></code></pre><p>Vahana offers the <code>show_agent</code> function to inspect the state of individual agents. This function displays comprehensive information about a randomly selected agent of the specified type. Additionally, users have the option to specify a particular agent identifier if they wish to examine a specific agent. The <code>show_agent</code> function returns the identifier of the selected agent.</p><pre><code class="language-julia hljs">show_agent(sim, Seller, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Id / Local Nr: 0x0200000000000001 / 1
State:
    p=0.9110613021731456
    d_y=366.2879763958845
Edge(s):
    Bought
	from:              edge.state:
	0x0100000000000002 Bought(17.067849697434912, 3.952401487539065)
	0x0100000000000008 Bought(18.568427199691737, 80.1109808515726)
	0x010000000000000a Bought(15.338337003796982, 29.198908723698427)
	0x0100000000000011 Bought(35.654331612710834, 66.51565336432876)
	0x0100000000000014 Bought(54.367406213244216, 19.72405213973325)
	... (5 not shown)

0x0200000000000001</code></pre><p>The <code>show_agent</code> function has an optional keyword argument, <code>neighborstate</code>, which enables the user to examine the state of neighboring agents. The <code>neighborstate</code> argument should be a vector of symbols representing the field names that should be displayed.</p><pre><code class="language-julia hljs">show_agent(sim, Seller, 1; neighborstate = [ :B ])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Id / Local Nr: 0x0200000000000001 / 1
State:
    p=0.9110613021731456
    d_y=366.2879763958845
Edge(s):
    Bought
	from:              edge.state:
	0x0100000000000002 Bought(17.067849697434912, 3.952401487539065) B=20.0,
	0x0100000000000008 Bought(18.568427199691737, 80.1109808515726) B=78.0,
	0x010000000000000a Bought(15.338337003796982, 29.198908723698427) B=37.0,
	0x0100000000000011 Bought(35.654331612710834, 66.51565336432876) B=85.0,
	0x0100000000000014 Bought(54.367406213244216, 19.72405213973325) B=69.0,
	... (5 not shown)

0x0200000000000001</code></pre><p>As mentioned in the <a href="tutorial1.html#Agent-and-Edge-Types">Agent and Edge Types</a> section, all agent and edge types in Vahana must be of type <code>bitstype</code>. This has the usefull side effect that the state of the agents and edges can be nicely converted into a DataFrame.</p><p>It is important to note that the DataFrame in a parallel simulation contains only the agents or edges of the process in which the function is called, and not those of the complete simulation. If the latter is required, <a href="misc.html#Vahana.all_agents"><code>all_agents</code></a> or <a href="misc.html#Vahana.all_edges"><code>all_edges</code></a> can be used.</p><pre><code class="language-julia hljs">first(DataFrame(sim, Bought; types = true), 10)</code></pre><div><div style = "float: left;"><span>10×6 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">from</th><th style = "text-align: left;">to</th><th style = "text-align: left;">x</th><th style = "text-align: left;">y</th><th style = "text-align: left;">from_type</th><th style = "text-align: left;">to_type</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "UInt64" style = "text-align: left;">UInt64</th><th title = "UInt64" style = "text-align: left;">UInt64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "DataType" style = "text-align: left;">DataType</th><th title = "DataType" style = "text-align: left;">DataType</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">72057594037927937</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">39.1719</td><td style = "text-align: right;">1.84345</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">72057594037927939</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">8.77185</td><td style = "text-align: right;">5.133</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">72057594037927940</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">14.0165</td><td style = "text-align: right;">11.0654</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">72057594037927941</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">35.1744</td><td style = "text-align: right;">11.0154</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">72057594037927942</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">10.6525</td><td style = "text-align: right;">11.4968</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">72057594037927958</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">5.72068</td><td style = "text-align: right;">21.5969</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">72057594037927961</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">27.0304</td><td style = "text-align: right;">1.5719</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">72057594037927966</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">5.11482</td><td style = "text-align: right;">1.54519</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">72057594037927971</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">11.5827</td><td style = "text-align: right;">10.8863</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: right;">72057594037927973</td><td style = "text-align: right;">144115188075855877</td><td style = "text-align: right;">9.27674</td><td style = "text-align: right;">0.228769</td><td style = "text-align: left;">Buyer</td><td style = "text-align: left;">Seller</td></tr></tbody></table></div><p>To get the DataFrame for the Globals, we call the <code>GlobalsDataFrame</code> function for our sim. Be aware, that only global variable that are vectors are added to the DataFrame.</p><pre><code class="language-julia hljs">GlobalsDataFrame(sim)</code></pre><div><div style = "float: left;"><span>5×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">x_minus_y</th><th style = "text-align: left;">p</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">-92.8452</td><td style = "text-align: right;">1.28767</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">-173.418</td><td style = "text-align: right;">1.17327</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">-60.523</td><td style = "text-align: right;">1.15408</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">-20.1729</td><td style = "text-align: right;">1.34301</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">-43.2671</td><td style = "text-align: right;">1.37286</td></tr></tbody></table></div><h1 id="Finish-the-Simulation"><a class="docs-heading-anchor" href="#Finish-the-Simulation">Finish the Simulation</a><a id="Finish-the-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Finish-the-Simulation" title="Permalink"></a></h1><p>Vahana employs an internal C library for memory allocation during simulations. Upon completing a simulation, it is necessary to invoke the <code>finish_simulation</code> function to properly deallocate the memory resources utilized. This function returns the global variables associated with the concluded simulation.</p><pre><code class="language-julia hljs">finish_simulation!(sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vahana.var&quot;Globals_Excess Demand&quot;([-92.84518265560759, -173.41767821162122, -60.5229521761736, -20.17287682197647, -43.26708128590373], [1.287669931251145, 1.173269381255291, 1.1540756786786697, 1.3430127391888713, 1.3728599329103153])</code></pre><h1 id="Understanding-Vahana&#39;s-Edge-Structure"><a class="docs-heading-anchor" href="#Understanding-Vahana&#39;s-Edge-Structure">Understanding Vahana&#39;s Edge Structure</a><a id="Understanding-Vahana&#39;s-Edge-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-Vahana&#39;s-Edge-Structure" title="Permalink"></a></h1><p>When we define edge types like <code>KnownSeller</code> or <code>Bought</code>, you might notice that these structs don&#39;t contain any information about the source or target agents of the edge. This is by design in Vahana, which uses a specific internal structure to represent edges efficiently.</p><p>Internally, Vahana declares a parametric type for edges:</p><pre><code class="nohighlight hljs">struct Edge{T}
    from::AgentID
    state::T
end</code></pre><p>In this structure, <code>T</code> is the type of our edge (like <code>KnownSeller</code> or <code>Bought</code>), and from is the ID of the agent at the source of the edge. You might wonder why there&#39;s no to field for the target agent. The reason lies in how Vahana stores these edges.</p><p>Vahana uses container structures (like dictionaries) to store edges. The exact type of container depends on certain optimization hints (see Edge Hints for more details), but a typical structure might look like this:</p><p><code>Dict{AgentID, Vector{Edge{T}}}</code></p><p>This design means that the target agent&#39;s ID is implicitly stored as the dictionary key. Adding it to the Edge struct would be redundant and would unnecessarily consume memory and CPU cycles. As a user of Vahana, you don&#39;t need to interact with this internal structure directly, but understanding it can help you design more efficient models and better understand how Vahana works under the hood.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="hegselmann.html">Utilizing Graphs.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 18 October 2024 15:35">Friday 18 October 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
