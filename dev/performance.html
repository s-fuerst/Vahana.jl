<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance Tuning · Vahana Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Vahana Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorial1.html">Tutorial</a></li><li><a class="tocitem" href="hegselmann.html">Opinion Model</a></li><li><a class="tocitem" href="predator.html">Predator / Prey</a></li></ul></li><li class="is-active"><a class="tocitem" href="performance.html">Performance Tuning</a><ul class="internal"><li><a class="tocitem" href="#Optional-Assertions"><span>Optional Assertions</span></a></li><li><a class="tocitem" href="#Type-Hints"><span>Type Hints</span></a></li><li><a class="tocitem" href="#Parallel-simulations"><span>Parallel simulations</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="definition.html">Model Definition</a></li><li><a class="tocitem" href="initialization.html">Initialization</a></li><li><a class="tocitem" href="transition.html">Transition Function</a></li><li><a class="tocitem" href="global.html">Global Layer</a></li><li><a class="tocitem" href="plots.html">Plots</a></li><li><a class="tocitem" href="hdf5.html">HDF5</a></li><li><a class="tocitem" href="logging.html">Logging</a></li><li><a class="tocitem" href="config.html">Configuration</a></li><li><a class="tocitem" href="misc.html">Misc</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="performance.html">Performance Tuning</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="performance.html">Performance Tuning</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-fuerst/Vahana.jl/blob/main/docs/src/performance.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance-Tuning"><a class="docs-heading-anchor" href="#Performance-Tuning">Performance Tuning</a><a id="Performance-Tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tuning" title="Permalink"></a></h1><p>This section provides some explanations on how to fine-tune the simulation performance.</p><p>These tips are specific to Vahana. Of course, all the generic performance tips, such as writing <code>type-stable</code> functions, still apply.</p><h2 id="Optional-Assertions"><a class="docs-heading-anchor" href="#Optional-Assertions">Optional Assertions</a><a id="Optional-Assertions-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Assertions" title="Permalink"></a></h2><p>Vahana includes internal consistency checks that can impact runtime performance. For example, in <a href="transition.html#Vahana.agentstate"><code>agentstate</code></a>, there are checks to ensure that the specified agenttype matches the agent&#39;s ID, which incurs some overhead. These assertions that could degrade performance can be disabled by calling <code>enable_asserts(false)</code>.</p><p>The recommended approach is to enable assertions during the model development phase but disable them when the model goes &quot;into production,&quot; such as before starting a parameter space exploration.</p><h2 id="Type-Hints"><a class="docs-heading-anchor" href="#Type-Hints">Type Hints</a><a id="Type-Hints-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hints" title="Permalink"></a></h2><p>It is possible to provide Vahana with hints about the types of agents or edges to improve runtime performance and/or reduce memory requirements.</p><p>Apart from the <code>:SingleEdge</code> hint, there is generally no need to change anything in the model code. The interface to Vahana remains the same, with the restriction that not all functions may be available. For example, if the <code>:IgnoreFrom</code> hint is set for an edge type, it is not possible to call the <a href="transition.html#Vahana.edgestates"><code>edgestates</code></a> function because Vahana has not stored the ID of the neighbors and therefore cannot retrieve their state.</p><p>In general, a sensible approach is to keep the assertions active and ignore the hints (except for <code>:SingleEdge</code>, as it can make your code simpler) during the implementation of the model. Once the implementation is complete, the first step is to check which hints are set and how they affect performance. After making a choice that does not trigger any assertions, these can then be deactivated as well.</p><h3 id="Agent-Hints"><a class="docs-heading-anchor" href="#Agent-Hints">Agent Hints</a><a id="Agent-Hints-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-Hints" title="Permalink"></a></h3><p>Currently, the only hint available for agent types is the <code>:Immortal</code> hint. This hint informs Vahana that agents of this type will not be removed during the simulation (for example, by returning <code>nothing</code> in a transition function).</p><p>The advantage of using this hint is that Vahana doesn&#39;t need to check or handle situations where these agents may be removed. This simplifies the internal handling of such agents.</p><h3 id="Edge-Hints"><a class="docs-heading-anchor" href="#Edge-Hints">Edge Hints</a><a id="Edge-Hints-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Hints" title="Permalink"></a></h3><p>There exist four possible hints for the edge types, that can be  set as optional <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a> arguments:</p><ul><li><code>:IgnoreFrom</code>: Omits storage of the source node&#39;s ID </li><li><code>:Stateless</code>: Only stores the ID of the source node </li><li><code>:SingleType</code>: All target nodes are of the same type (the source</li></ul><p>nodes can have different types). This needs also the keyword <code>target</code> set (see below).</p><ul><li><code>:SingleEdge</code>: Each agent can be the target of only one edge (of this type).</li><li><code>:IgnoreSourceState</code>: The ID of the source agent is not used to access the state of the agent with this ID.</li></ul><p>The <code>:IgnoreSourceState</code> hint is primarily relevant when running a simulation in parallel. You can find detailed information about this hint <a href="performance.html#:IgnoreSourceState">below</a>.</p><p>Almost all hints can be combined in any way you prefer. For example, the combination of <code>:IgnoreFrom</code> and <code>:Stateless</code> may seem useless at first because no concrete edge information will be stored when <a href="initialization.html#Vahana.add_edge!"><code>add_edge!</code></a> is called. However, Vahana still keeps track of the number of edges that have the agent as the target node. This information alone, or combined with the <code>:SingleEdge</code> hint, can often be sufficient. You can refer to the <code>Die</code> or <code>Eat</code> edges in the <a href="predator.html">Predator example</a> for an illustration.</p><p>The only combination that is not allowed is <code>:SingleType</code> + <code>:SingleEdge</code>, unless you also set <code>:Stateless</code> and <code>:IgnoreFrom</code>.</p><h4 id=":SingleType-target-keyword-argument"><a class="docs-heading-anchor" href="#:SingleType-target-keyword-argument">:SingleType <code>target</code> keyword argument</a><a id=":SingleType-target-keyword-argument-1"></a><a class="docs-heading-anchor-permalink" href="#:SingleType-target-keyword-argument" title="Permalink"></a></h4><p>When the <code>:SingleType</code> hint is set, it is necessary to add the <code>target</code> keyword argument to the <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a> function. The value of this argument should be the type of the target nodes.</p><h4 id="Defined-Functions"><a class="docs-heading-anchor" href="#Defined-Functions">Defined Functions</a><a id="Defined-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defined-Functions" title="Permalink"></a></h4><p>The following functions can be used to access the graph within <a href="transition.html#Vahana.apply!"><code>apply!</code></a>, but their availability depends on the edge type hints:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">not available for edge type with the hint (combination)</th></tr><tr><td style="text-align: left"><a href="transition.html#Vahana.edges"><code>edges</code></a></td><td style="text-align: left"><code>:IgnoreFrom</code> or <code>:Stateless</code></td></tr><tr><td style="text-align: left"><a href="transition.html#Vahana.neighborids"><code>neighborids</code></a></td><td style="text-align: left"><code>:IgnoreFrom</code></td></tr><tr><td style="text-align: left"><a href="transition.html#Vahana.neighborstates"><code>neighborstates</code></a></td><td style="text-align: left"><code>:IgnoreFrom</code></td></tr><tr><td style="text-align: left"><a href="transition.html#Vahana.edgestates"><code>edgestates</code></a>, <a href="global.html#Base.mapreduce"><code>mapreduce</code></a></td><td style="text-align: left"><code>:Stateless</code></td></tr><tr><td style="text-align: left"><a href="misc.html#Vahana.num_edges-Union{Tuple{T}, Tuple{Any, Type{T}}, Tuple{Any, Type{T}, Any}} where T"><code>num_edges</code></a></td><td style="text-align: left"><code>:SingleEdge</code></td></tr><tr><td style="text-align: left"><a href="transition.html#Vahana.has_edge"><code>has_edge</code></a></td><td style="text-align: left">always available</td></tr></table><p>As mentioned earlier, the Vahana API differs slightly when the <code>:SingleEdge</code> hint is used. This specifically affects the functions listed here, with the exception of <code>num_edges</code>, <code>has_edges</code>, and <code>mapreduce</code>. Normally, these functions return a vector containing edges, IDs, or states (or <code>nothing</code>). However, when used in combination with the <code>:SingleEdge</code> hint, they return only one edge, ID, or state (or <code>nothing</code>), as the hint implies that there is at most one edge of that type.</p><h4 id="Special-Hint-Combinations"><a class="docs-heading-anchor" href="#Special-Hint-Combinations">Special Hint Combinations</a><a id="Special-Hint-Combinations-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Hint-Combinations" title="Permalink"></a></h4><p>Additionally, there are two property combinations that can be set in <a href="definition.html#Vahana.register_edgetype!"><code>register_edgetype!</code></a> using a single symbol, which directly expresses the intended combination:</p><ul><li><p><code>:NumEdgesOnly</code>: This corresponds to the combination of <code>:IgnoreFrom</code> and <code>:Stateless</code>. In this case, only the number of edges is counted, so only calls to <a href="misc.html#Vahana.num_edges-Union{Tuple{T}, Tuple{Any, Type{T}}, Tuple{Any, Type{T}, Any}} where T"><code>num_edges</code></a> and <a href="transition.html#Vahana.has_edge"><code>has_edge</code></a> are possible.</p></li><li><p><code>:HasEdgeOnly</code>: This corresponds to the combination of <code>:IgnoreFrom</code>, <code>:Stateless</code>, and <code>:SingleEdge</code>. In this case, only calls to <a href="transition.html#Vahana.has_edge"><code>has_edge</code></a> are possible.</p></li></ul><h2 id="Parallel-simulations"><a class="docs-heading-anchor" href="#Parallel-simulations">Parallel simulations</a><a id="Parallel-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-simulations" title="Permalink"></a></h2><p>The best performance improvement can be achieved by computing a model implemented with Vahana in parallel. This can be easily done by starting the simulation with <code>mpirun</code> or <code>mpiexec</code>. For example:</p><p><code>mpirun -np 4 julia hegselmann.jl</code></p><p>The <code>-np</code> parameter indicates the number of processes/threads to be used for the simulation.</p><p>This approach works without any additional changes in the model code. However, there are ways to further optimize performance in a parallel simulation:</p><h3 id="Partitioning"><a class="docs-heading-anchor" href="#Partitioning">Partitioning</a><a id="Partitioning-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioning" title="Permalink"></a></h3><p>The simulation graph is partitioned and distributed in the <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> call. By default, the <a href="https://github.com/JuliaSparse/Metis.jl">Metis.jl</a> package is used for this. However, during this process, the information about the different agent types is lost. As a result, if multiple agent types are used, it is possible that the number of agents is unevenly distributed for a single agent type.</p><p>To address this issue, an alternative partitioning scheme, <code>:EqualAgentNumbers</code>, is available. However, this scheme ignores the edges and number of cuts in the graph.</p><p>In order to optimize the partitioning for your specific model, it can be very useful to perform your own partitioning and pass it to <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a>. An example of this can be seen in the <code>create_partition</code> function of the <a href="https://git.zib.de/sfuerst/vahana-episim/-/blob/main/src/init.jl">Vahana Episim Example</a>.</p><h3 id="@rootonly"><a class="docs-heading-anchor" href="#@rootonly">@rootonly</a><a id="@rootonly-1"></a><a class="docs-heading-anchor-permalink" href="#@rootonly" title="Permalink"></a></h3><p>MPI is based on a <a href="https://en.wikipedia.org/wiki/Single_program,_multiple_data">single program, multiple data (SPMD)</a> model. As a consequence, up until the <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> call, all processes execute the exact same instructions on the same data. Therefore, if there are <code>n</code> processes, the complete graph is generated <code>n</code> times.</p><p>Although this is not necessarily problematic since only the graph of the root processes is distributed in <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a>, it can be beneficial to construct the graph only on the root processes, especially if files are being read during the initialization phase.</p><p>To execute instructions only on the root process, you can use the <code>@rootonly</code> macro. For example, the Vahana Episim example includes the following code before the <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> call:</p><pre><code class="nohighlight hljs">    @rootonly begin
        worldid = add_agent!(sim, World())
        healthauthid = add_agent!(sim, HealthAuthority(0, 0, 0))
        @info &quot;read persons&quot;
        persons = read_persons!(config.synpop_file)
        @info &quot;read events&quot;
        read_events!(sim, config.events_all, persons, worldid, healthauthid)
        @info &quot;finish init&quot;
    end</code></pre><p>But it is important that <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> is called by all processes and not only by the root process.</p><h3 id="Write-a-snapshot-after-finish_init!"><a class="docs-heading-anchor" href="#Write-a-snapshot-after-finish_init!">Write a snapshot after <code>finish_init!</code></a><a id="Write-a-snapshot-after-finish_init!-1"></a><a class="docs-heading-anchor-permalink" href="#Write-a-snapshot-after-finish_init!" title="Permalink"></a></h3><p>If creating the initial state takes time and the process is deterministic, it is a good idea to save the state after <a href="initialization.html#Vahana.finish_init!"><code>finish_init!</code></a> with <a href="hdf5.html#Vahana.write_snapshot"><code>write_snapshot</code></a> and read this snapshot with <a href="hdf5.html#Vahana.read_snapshot!"><code>read_snapshot!</code></a> instead of recreating the graph each time. </p><p>Again, the <a href="https://git.zib.de/sfuerst/vahana-episim/">Vahana Episim example</a> demonstrates how to do this.</p><h3 id=":IgnoreSourceState-hint"><a class="docs-heading-anchor" href="#:IgnoreSourceState-hint">:IgnoreSourceState hint</a><a id=":IgnoreSourceState-hint-1"></a><a class="docs-heading-anchor-permalink" href="#:IgnoreSourceState-hint" title="Permalink"></a></h3><p>This hint requires additional explanation about what happens internally when <a href="transition.html#Vahana.apply!"><code>apply!</code></a> is called.</p><p>In a parallel simulation, at the beginning of <a href="transition.html#Vahana.apply!"><code>apply!</code></a>, it is checked whether the transition function needs to read the state of an agent type that may have changed since the last state read. If this is the case, it checks all accessible edges (specified in the <code>read</code> argument of <code>apply!</code>) and transmits the state of agents that can be accessed (i.e., the agent type must also be included in the <code>read</code> argument) to the corresponding process. However, there are cases where it is clear that only the IDs of the agents will be accessed via a specific edge type, and not the agent state itself. To avoid the overhead of transmitting state between agents that will never be read, the <code>:IgnoreSourceState</code> hint can be used for those edge types.</p><p>This hint only affects parallel simulations, as there is nothing to transmit in a serial simulation.</p><h3 id="Avoid-agentstate-calls"><a class="docs-heading-anchor" href="#Avoid-agentstate-calls">Avoid agentstate calls</a><a id="Avoid-agentstate-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-agentstate-calls" title="Permalink"></a></h3><p>Instead of using <a href="transition.html#Vahana.agentstate"><code>agentstate</code></a> to access the state of an agent, sometimes it is possible for an agent to actively send the required state associated with an edge to another agent that needs that information. This can significantly improve performance, especially when combined with the <code>:IgnoreSourceState</code> hint if necessary.</p><p>For example, in a Game of Life implementation, active cells can generate an edge to their neighbors if the cell is active. If this edge has the <code>:NumEdgesOnly</code> hint, it will directly trigger the counting process of the neighbors without the need to transfer the full state to other agents/processes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="predator.html">« Predator / Prey</a><a class="docs-footer-nextpage" href="definition.html">Model Definition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 3 January 2024 11:19">Wednesday 3 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
